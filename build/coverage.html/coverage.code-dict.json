{"/home/travis/build/npmtest/node-npmtest-cassandra-driver/test.js":"/* istanbul instrument in package npmtest_cassandra_driver */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/lib.npmtest_cassandra_driver.js":"/* istanbul instrument in package npmtest_cassandra_driver */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cassandra_driver = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cassandra_driver = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cassandra-driver && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cassandra_driver */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cassandra_driver\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cassandra_driver.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_cassandra_driver.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cassandra_driver.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_cassandra_driver.__dirname +\n                    '/lib.npmtest_cassandra_driver.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/index.js":"var clientOptions = require('./lib/client-options');\nexports.Client = require('./lib/client');\nexports.ExecutionProfile = require('./lib/execution-profile').ExecutionProfile;\nexports.types = require('./lib/types');\nexports.errors = require('./lib/errors');\nexports.policies = require('./lib/policies');\nexports.auth = require('./lib/auth');\nexports.metadata = {\n  Metadata: require('./lib/metadata')\n};\nexports.Encoder = require('./lib/encoder');\n/**\n * Returns a new instance of the default [options]{@link ClientOptions} used by the driver.\n */\nexports.defaultOptions = function () {\n  return clientOptions.defaultOptions();\n};\nexports.version = require('./package.json').version;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/client-options.js":"\"use strict\";\nvar util = require('util');\n\nvar policies = require('./policies');\nvar types = require('./types');\nvar utils = require('./utils');\nvar errors = require('./errors');\n\n/**\n * @returns {ClientOptions}\n */\nfunction defaultOptions () {\n  return ({\n    policies: {\n      addressResolution: policies.defaultAddressTranslator(),\n      loadBalancing: policies.defaultLoadBalancingPolicy(),\n      reconnection: policies.defaultReconnectionPolicy(),\n      retry: policies.defaultRetryPolicy(),\n      timestampGeneration: policies.defaultTimestampGenerator()\n    },\n    queryOptions: {\n      consistency: types.consistencies.localOne,\n      fetchSize: 5000,\n      prepare: false,\n      retryOnTimeout: true,\n      captureStackTrace: false\n    },\n    protocolOptions: {\n      port: 9042,\n      maxSchemaAgreementWaitSeconds: 10,\n      maxVersion: 0\n    },\n    pooling: {\n      heartBeatInterval: 30000\n    },\n    socketOptions: {\n      connectTimeout: 5000,\n      defunctReadTimeoutThreshold: 64,\n      keepAlive: true,\n      keepAliveDelay: 0,\n      readTimeout: 12000,\n      tcpNoDelay: true,\n      coalescingThreshold: 8000\n    },\n    authProvider: null,\n    maxPrepared: 500,\n    refreshSchemaDelay: 1000,\n    isMetadataSyncEnabled: true,\n    encoding: {\n      copyBuffer: true,\n      useUndefinedAsUnset: true\n    }\n  });\n}\n\n/**\n * Extends and validates the user options\n * @param {Object} [baseOptions] The source object instance that will be overridden\n * @param {Object} userOptions\n * @returns {Object}\n */\nfunction extend(baseOptions, userOptions) {\n  if (arguments.length === 1) {\n    userOptions = arguments[0];\n    baseOptions = {};\n  }\n  var options = utils.deepExtend(baseOptions, defaultOptions(), userOptions);\n  if (!util.isArray(options.contactPoints) || options.contactPoints.length === 0) {\n    throw new TypeError('Contacts points are not defined.');\n  }\n  for (var i = 0; i < options.contactPoints.length; i++) {\n    var hostName = options.contactPoints[i];\n    if (!hostName) {\n      throw new TypeError(util.format('Contact point %s (%s) is not a valid host name, ' +\n        'the following values are valid contact points: ipAddress, hostName or ipAddress:port', i, hostName));\n    }\n  }\n  if (!options.policies) {\n    throw new TypeError('policies not defined in options');\n  }\n  if (!(options.policies.loadBalancing instanceof policies.loadBalancing.LoadBalancingPolicy)) {\n    throw new TypeError('Load balancing policy must be an instance of LoadBalancingPolicy');\n  }\n  if (!(options.policies.reconnection instanceof policies.reconnection.ReconnectionPolicy)) {\n    throw new TypeError('Reconnection policy must be an instance of ReconnectionPolicy');\n  }\n  if (!(options.policies.retry instanceof policies.retry.RetryPolicy)) {\n    throw new TypeError('Retry policy must be an instance of RetryPolicy');\n  }\n  if (!(options.policies.addressResolution instanceof policies.addressResolution.AddressTranslator)) {\n    throw new TypeError('Address resolution policy must be an instance of AddressTranslator');\n  }\n  if (options.policies.timestampGeneration !== null &&\n      !(options.policies.timestampGeneration instanceof policies.timestampGeneration.TimestampGenerator)) {\n    throw new TypeError('Timestamp generation policy must be an instance of TimestampGenerator');\n  }\n  if (!options.queryOptions) {\n    throw new TypeError('queryOptions not defined in options');\n  }\n  if (!options.protocolOptions) {\n    throw new TypeError('protocolOptions not defined in options');\n  }\n  if (!options.socketOptions) {\n    throw new TypeError('socketOptions not defined in options');\n  }\n  if (typeof options.socketOptions.readTimeout !== 'number') {\n    throw new TypeError('socketOptions.readTimeout must be a Number');\n  }\n  if (typeof options.socketOptions.coalescingThreshold !== 'number' || options.socketOptions.coalescingThreshold <= 0) {\n    throw new TypeError('socketOptions.coalescingThreshold must be a positive Number');\n  }\n  if (!options.logEmitter) {\n    options.logEmitter = function () {};\n  }\n  if (!options.encoding) {\n    options.encoding = {};\n  }\n  if (options.encoding.map) {\n    var mapConstructor = options.encoding.map;\n    if (typeof mapConstructor !== 'function' ||\n      typeof mapConstructor.prototype.forEach !== 'function' ||\n      typeof mapConstructor.prototype.set !== 'function') {\n      throw new TypeError('Map constructor not valid');\n    }\n  }\n  if (options.encoding.set) {\n    var setConstructor = options.encoding.set;\n    if (typeof setConstructor !== 'function' ||\n      typeof setConstructor.prototype.forEach !== 'function' ||\n      typeof setConstructor.prototype.add !== 'function') {\n      throw new TypeError('Set constructor not valid');\n    }\n  }\n  if (options.profiles && !util.isArray(options.profiles)) {\n    throw new TypeError('profiles must be an Array of ExecutionProfile instances');\n  }\n  return options;\n}\n\n/**\n * Creates a new instance of query options with the values from the user.\n * When some values are not defined, it takes the default values from\n * - {@link ExecutionProfile}.\n * - {@link QueryOptions} from the default options.\n * @param {Client} client\n * @param {QueryOptions|function} userOptions\n * @param {Function} [rowCallback]\n * @param {Boolean} [logged]\n * @returns {Object|Error} Returns a new instance of an object with the query options or returns an Error\n * instance (doesn't throw the Error).\n */\nfunction createQueryOptions(client, userOptions, rowCallback, logged) {\n  var profile =\n    client.profileManager.getProfile(userOptions && userOptions.executionProfile);\n  if (!profile) {\n    return new errors.ArgumentError(util.format('Execution profile \"%s\" not found', userOptions.executionProfile));\n  }\n  // userOptions can be undefined and could be of type function (is an optional parameter)\n  userOptions = (!userOptions || typeof userOptions === 'function') ? utils.emptyObject : userOptions;\n  var defaultQueryOptions = client.options.queryOptions;\n\n  // Using fixed property names is 2 order of magnitude faster than dynamically shallow clone objects\n  var result = {\n    autoPage: ifUndefined(userOptions.autoPage, defaultQueryOptions.autoPage),\n    captureStackTrace: ifUndefined(userOptions.captureStackTrace, defaultQueryOptions.captureStackTrace),\n    consistency: ifUndefined3(userOptions.consistency, profile.consistency, defaultQueryOptions.consistency),\n    customPayload: ifUndefined(userOptions.customPayload, defaultQueryOptions.customPayload),\n    executionProfile: profile,\n    fetchSize: ifUndefined(userOptions.fetchSize, defaultQueryOptions.fetchSize),\n    hints: userOptions.hints,\n    isIdempotent: ifUndefined(userOptions.isIdempotent, defaultQueryOptions.isIdempotent),\n    logged: ifUndefined(userOptions.logged, logged),\n    pageState: userOptions.pageState,\n    prepare: ifUndefined(userOptions.prepare, defaultQueryOptions.prepare),\n    readTimeout: ifUndefined3(userOptions.readTimeout, profile.readTimeout, client.options.socketOptions.readTimeout),\n    retry: ifUndefined3(userOptions.retry, profile.retry, client.options.policies.retry),\n    retryOnTimeout: ifUndefined3(\n      userOptions.retryOnTimeout, profile.retryOnTimeout, defaultQueryOptions.retryOnTimeout),\n    routingIndexes: userOptions.routingIndexes,\n    routingKey: userOptions.routingKey,\n    routingNames: userOptions.routingNames,\n    serialConsistency: ifUndefined3(\n      userOptions.serialConsistency, profile.serialConsistency, defaultQueryOptions.serialConsistency),\n    timestamp: getTimestamp(client, userOptions, defaultQueryOptions.timestamp),\n    traceQuery: ifUndefined(userOptions.traceQuery, defaultQueryOptions.traceQuery),\n    // not part of query options\n    rowCallback: rowCallback\n  };\n  if (userOptions === utils.emptyObject) {\n    return result;\n  }\n  var userOptionsKeys = Object.keys(userOptions);\n  var key, value;\n  // Use the fastest iteration of array\n  var i = userOptionsKeys.length;\n  while (i--) {\n    key = userOptionsKeys[i];\n    if (key === 'executionProfile') {\n      // Execution profile was the only value that could has been \"replaced\"\n      continue;\n    }\n    value = userOptions[key];\n    if (value === undefined) {\n      continue;\n    }\n    result[key] = value;\n  }\n  return result;\n}\n\nfunction ifUndefined(v1, v2) {\n  return v1 !== undefined ? v1 : v2;\n}\n\nfunction ifUndefined3(v1, v2, v3) {\n  if (v1 !== undefined) {\n    return v1;\n  }\n  return v2 !== undefined ? v2 : v3;\n}\n\nfunction getTimestamp(client, userOptions, defaultValue) {\n  var value = defaultValue;\n  if (typeof userOptions.timestamp !== 'undefined') {\n    value = userOptions.timestamp;\n  }\n  else if (client.controlConnection.protocolVersion > 2 && client.options.policies.timestampGeneration) {\n    // Use the timestamp generator\n    value = client.options.policies.timestampGeneration.next(client);\n  }\n  return value;\n}\n\n/**\n * Core connections per host for protocol versions 1 and 2\n */\nvar coreConnectionsPerHostV2 = {};\ncoreConnectionsPerHostV2[types.distance.local] = 2;\ncoreConnectionsPerHostV2[types.distance.remote] = 1;\ncoreConnectionsPerHostV2[types.distance.ignored] = 0;\n/**\n * Core connections per host for protocol version 3 and above\n */\nvar coreConnectionsPerHostV3 = {};\ncoreConnectionsPerHostV3[types.distance.local] = 1;\ncoreConnectionsPerHostV3[types.distance.remote] = 1;\ncoreConnectionsPerHostV3[types.distance.ignored] = 0;\n\nexports.extend = extend;\nexports.defaultOptions = defaultOptions;\nexports.coreConnectionsPerHostV2 = coreConnectionsPerHostV2;\nexports.coreConnectionsPerHostV3 = coreConnectionsPerHostV3;\nexports.createQueryOptions = createQueryOptions;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/index.js":"'use strict';\n\n/**\n * Contains driver tuning policies to determine [load balancing]{@link module:policies/loadBalancing},\n *  [retrying]{@link module:policies/retry} queries, [reconnecting]{@link module:policies/reconnection} to a node,\n *  [address resolution]{@link module:policies/addressResolution} and\n *  [timestamp generation]{@link module:policies/timestampGeneration}.\n * @module policies\n */\nvar addressResolution = exports.addressResolution = require('./address-resolution');\nvar loadBalancing = exports.loadBalancing = require('./load-balancing');\nvar reconnection = exports.reconnection = require('./reconnection');\nvar retry = exports.retry = require('./retry');\nvar timestampGeneration = exports.timestampGeneration = require('./timestamp-generation');\n\n/**\n * Returns a new instance of the default address translator policy used by the driver.\n * @returns {AddressTranslator}\n */\nexports.defaultAddressTranslator = function () {\n  return new addressResolution.AddressTranslator();\n};\n\n/**\n * Returns a new instance of the default load-balancing policy used by the driver.\n * @returns {LoadBalancingPolicy}\n */\nexports.defaultLoadBalancingPolicy = function () {\n  return new loadBalancing.TokenAwarePolicy(new loadBalancing.DCAwareRoundRobinPolicy());\n};\n\n/**\n * Returns a new instance of the default retry policy used by the driver.\n * @returns {RetryPolicy}\n */\nexports.defaultRetryPolicy = function () {\n  return new retry.RetryPolicy();\n};\n\n/**\n * Returns a new instance of the default reconnection policy used by the driver.\n * @returns {ReconnectionPolicy}\n */\nexports.defaultReconnectionPolicy = function () {\n  return new reconnection.ExponentialReconnectionPolicy(1000, 10 * 60 * 1000, false);\n};\n\n/**\n * Returns a new instance of the default timestamp generator used by the driver.\n * @returns {TimestampGenerator}\n */\nexports.defaultTimestampGenerator = function () {\n  return new timestampGeneration.MonotonicTimestampGenerator();\n};","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/address-resolution.js":"\"use strict\";\nvar dns = require('dns');\nvar util = require('util');\nvar utils = require('../utils');\n/** @module policies/addressResolution */\n/**\n * @class\n * @classdesc\n * Translates IP addresses received from Cassandra nodes into locally queryable\n * addresses.\n * <p>\n * The driver auto-detects new Cassandra nodes added to the cluster through server\n * side pushed notifications and through checking the system tables. For each\n * node, the address received will correspond to the address set as\n * <code>rpc_address</code> in the node yaml file. In most case, this is the correct\n * address to use by the driver and that is what is used by default. However,\n * sometimes the addresses received through this mechanism will either not be\n * reachable directly by the driver or should not be the preferred address to use\n * to reach the node (for instance, the <code>rpc_address</code> set on Cassandra nodes\n * might be a private IP, but some clients  may have to use a public IP, or\n * pass by a router to reach that node). This interface allows to deal with\n * such cases, by allowing to translate an address as sent by a Cassandra node\n * to another address to be used by the driver for connection.\n * <p>\n * Please note that the contact points addresses provided while creating the\n * {@link Client} instance are not \"translated\", only IP address retrieve from or sent\n * by Cassandra nodes to the driver are.\n * @constructor\n */\nfunction AddressTranslator() {\n\n}\n\n/**\n * Translates a Cassandra <code>rpc_address</code> to another address if necessary.\n * @param {String} address the address of a node as returned by Cassandra.\n * <p>\n * Note that if the <code>rpc_address</code> of a node has been configured to <code>0.0.0.0</code>\n * server side, then the provided address will be the node <code>listen_address</code>,\n * *not* <code>0.0.0.0</code>.\n * </p>\n * @param {Number} port The port number, as specified in the [protocolOptions]{@link ClientOptions} at Client instance creation (9042 by default).\n * @param {Function} callback Callback to invoke with endpoint as first parameter.\n * The endpoint is an string composed of the IP address and the port number in the format <code>ipAddress:port</code>.\n */\nAddressTranslator.prototype.translate = function (address, port, callback) {\n  callback(address + ':' + port);\n};\n\n/**\n * @class\n * @classdesc\n * {@link AddressTranslator} implementation for multi-region EC2 deployments <strong>where clients are also deployed in EC2</strong>.\n * <p>\n * Its distinctive feature is that it translates addresses according to the location of the Cassandra host:\n * </p>\n * <ul>\n *  <li>addresses in different EC2 regions (than the client) are unchanged</li>\n *  <li>addresses in the same EC2 region are <strong>translated to private IPs</strong></li>\n * </ul>\n * <p>\n * This optimizes network costs, because Amazon charges more for communication over public IPs.\n * </p>\n * @constructor\n */\nfunction EC2MultiRegionTranslator() {\n\n}\n\nutil.inherits(EC2MultiRegionTranslator, AddressTranslator);\n\n/**\n * Addresses in the same EC2 region are translated to private IPs and addresses in\n * different EC2 regions (than the client) are unchanged\n */\nEC2MultiRegionTranslator.prototype.translate = function (address, port, callback) {\n  var newAddress = address;\n  var self = this;\n  var name;\n  utils.series([\n    function resolve(next) {\n      dns.reverse(address, function (err, hostNames) {\n        if (err) {\n          return next(err);\n        }\n        if (!hostNames) {\n          return next();\n        }\n        name = hostNames[0];\n        next();\n      });\n    },\n    function lookup(next) {\n      if (!name) {\n        return next();\n      }\n      dns.lookup(name, function (err, lookupAddress) {\n        if (err) {\n          return next(err);\n        }\n        newAddress = lookupAddress;\n        next();\n      });\n    }], function (err) {\n    if (err) {\n      //there was an issue while doing dns resolution\n      self.logError(address, err);\n    }\n    callback(newAddress + ':' + port);\n  });\n};\n\n/**\n * Log method called to log errors that occurred while performing dns resolution.\n * You can assign your own method to the class instance to do proper logging.\n * @param {String} address\n * @param {Error} err\n */\nEC2MultiRegionTranslator.prototype.logError = function (address, err) {\n  //Do nothing by default\n};\n\nexports.AddressTranslator = AddressTranslator;\nexports.EC2MultiRegionTranslator = EC2MultiRegionTranslator;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/utils.js":"\"use strict\";\nvar util = require('util');\nvar errors = require('./errors');\nvar utils = require('./utils');\n\n/**\n * Max int that can be accurately represented with 64-bit Number (2^53)\n * @type {number}\n * @const\n */\nvar maxInt = 9007199254740992;\n\nfunction noop() {}\n\n/**\n * Creates a copy of a buffer\n */\nfunction copyBuffer(buf) {\n  var targetBuffer = new Buffer(buf.length);\n  buf.copy(targetBuffer);\n  return targetBuffer;\n}\n\n/**\n * Appends the original stack trace to the error after a tick of the event loop\n */\nfunction fixStack(stackTrace, error) {\n  if (stackTrace) {\n    error.stack += '\\n  (event loop)\\n' + stackTrace.substr(stackTrace.indexOf(\"\\n\") + 1);\n  }\n  return error;\n}\n\n/**\n * Uses the logEmitter to emit log events\n * @param {String} type\n * @param {String} info\n * @param [furtherInfo]\n */\nfunction log(type, info, furtherInfo) {\n  if (!this.logEmitter) {\n    //noinspection JSUnresolvedVariable\n    if (!this.options || !this.options.logEmitter) {\n      throw new Error('Log emitter not defined');\n    }\n    //noinspection JSUnresolvedVariable\n    this.logEmitter = this.options.logEmitter;\n  }\n  this.logEmitter('log', type, this.constructor.name, info, furtherInfo || '');\n}\n\n/**\n * Gets the sum of the length of the items of an array\n */\nfunction totalLength (arr) {\n  if (arr.length === 1) {\n    return arr[0].length;\n  }\n  var total = 0;\n  arr.forEach(function (item) {\n    var length = item.length;\n    length = length ? length : 0;\n    total += length;\n  });\n  return total;\n}\n\n/**\n * Merge the contents of two or more objects together into the first object. Similar to jQuery.extend\n */\nfunction extend(target) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n    var keys = Object.keys(source);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = source[key];\n      if (value === undefined) {\n        continue;\n      }\n      target[key] = value;\n    }\n  });\n  return target;\n}\n\nfunction lowerCaseExtend(target) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        target[prop.toLowerCase()] = source[prop];\n      }\n    }\n  });\n  return target;\n}\n\n/**\n * Extends the target by the most inner props of sources\n * @param {Object} target\n * @returns {Object}\n */\nfunction deepExtend(target) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    for (var prop in source) {\n      if (!source.hasOwnProperty(prop)) {\n        continue;\n      }\n      var targetProp = target[prop];\n      var targetType = (typeof targetProp);\n      //target prop is\n      // a native single type\n      // or not existent\n      // or is not an anonymous object (not class instance)\n      //noinspection JSUnresolvedVariable\n      if (!targetProp ||\n        targetType === 'number' ||\n        targetType === 'string' ||\n        util.isArray(targetProp) ||\n        util.isDate(targetProp) ||\n        targetProp.constructor.name !== 'Object'\n        ) {\n        target[prop] = source[prop];\n      }\n      else {\n        //inner extend\n        target[prop] = deepExtend({}, targetProp, source[prop]);\n      }\n    }\n  });\n  return target;\n}\n\nfunction propCompare(propName) {\n  return function (a, b) {\n    if (a[propName] > b[propName]) {\n      return 1;\n    }\n    if (a[propName] < b[propName]) {\n      return -1;\n    }\n    return 0;\n  };\n}\n\nfunction funcCompare(name, argArray) {\n  return (function (a, b) {\n    if (typeof a[name] === 'undefined') {\n      return 0;\n    }\n    var valA = a[name].apply(a, argArray);\n    var valB = b[name].apply(b, argArray);\n    if (valA > valB) {\n      return 1;\n    }\n    if (valA < valB) {\n      return -1;\n    }\n    return 0;\n  });\n}\n/**\n * Uses the iterator protocol to go through the items of the Array\n * @param arr\n * @returns {{next: function}}\n */\nfunction arrayIterator (arr) {\n  var index = 0;\n  return { next : function () {\n    if (index >= arr.length) {\n      return {done: true};\n    }\n    return {value: arr[index++], done: false };\n  }};\n}\n\n/**\n * Convert the iterator values into an array\n * @param iterator\n * @returns {Array}\n */\nfunction iteratorToArray(iterator) {\n  var values = [];\n  var item = iterator.next();\n  while (!item.done) {\n    values.push(item.value);\n    item = iterator.next();\n  }\n  return values;\n}\n\n/**\n * Searches the specified Array for the provided key using the binary\n * search algorithm.  The Array must be sorted.\n * @param {Array} arr\n * @param key\n * @param {function} compareFunc\n * @returns {number} The position of the key in the Array, if it is found.\n * If it is not found, it returns a negative number which is the bitwise complement of the index of the first element that is larger than key.\n */\nfunction binarySearch(arr, key, compareFunc) {\n  var low = 0;\n  var high = arr.length-1;\n\n  while (low <= high) {\n    var mid = (low + high) >>> 1;\n    var midVal = arr[mid];\n    var cmp = compareFunc(midVal, key);\n    if (cmp < 0) {\n      low = mid + 1;\n    }\n    else if (cmp > 0) {\n      high = mid - 1;\n    }\n    else\n    {\n      //The key was found in the Array\n      return mid;\n    }\n  }\n  return ~low;  // key not found\n}\n\n/**\n * Inserts the value in the position determined by its natural order determined by the compare func\n * @param {Array} arr\n * @param item\n * @param {function} compareFunc\n */\nfunction insertSorted(arr, item, compareFunc) {\n  if (arr.length === 0) {\n    return arr.push(item);\n  }\n  var position = binarySearch(arr, item, compareFunc);\n  if (position < 0) {\n    position = ~position;\n  }\n  arr.splice(position, 0, item);\n}\n\n/**\n * Binds the domain (if any) to the callback\n * @param {Function} callback\n * @param {String} [name]\n * @returns {Function}\n */\nfunction bindDomain(callback, name) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError(util.format('%s is not a function', name || 'callback'));\n  }\n  if (process.domain) {\n    callback = process.domain.bind(callback);\n  }\n  return callback;\n}\n\n/**\n * Adapts the parameters based on the prepared metadata.\n * If the params are passed as an associative array (Object),\n * it adapts the object into an array with the same order as columns\n * @param {Array|Object} params\n * @param {Array} columns\n * @returns {{ params: Array, keys: Object}} Returns an array of parameters and the keys as an associative array.\n * @throws {Error} In case a parameter with a specific name is not defined\n */\nfunction adaptNamedParamsPrepared(params, columns) {\n  if (!params || util.isArray(params) || !columns || columns.length === 0) {\n    //The parameters is an Array or there isn't parameter\n    return { params: params, keys: null};\n  }\n  var paramsArray = new Array(columns.length);\n  params = lowerCaseExtend({}, params);\n  var keys = {};\n  for (var i = 0; i < columns.length; i++) {\n    var name = columns[i].name;\n    if (!params.hasOwnProperty(name)) {\n      throw new errors.ArgumentError(util.format('Parameter \"%s\" not defined', name));\n    }\n    paramsArray[i] = params[name];\n    keys[name] = i;\n  }\n  return { params: paramsArray, keys: keys};\n}\n\n/**\n * Adapts the associative-array of parameters and hints for simple statements\n * into Arrays based on the (arbitrary) position of the keys.\n * @param {Array|Object} params\n * @param {QueryOptions} options\n * @returns {{ params: Array.<{name, value}>, keys: Object}} Returns an array of parameters and the keys as an associative array.\n */\nfunction adaptNamedParamsWithHints(params, options) {\n  if (!params || util.isArray(params)) {\n    //The parameters is an Array or there isn't parameter\n    return { params: params, keys: null};\n  }\n  options.namedParameters = true;\n  var keys = Object.keys(params);\n  var paramsArray = new Array(keys.length);\n  var hints = new Array(keys.length);\n  var userHints = options.hints || utils.emptyObject;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    //As lower cased identifiers\n    paramsArray[i] = { name: key.toLowerCase(), value: params[key]};\n    hints[i] = userHints[key];\n  }\n  options.hints = hints;\n  return { params: paramsArray, keys: keys};\n}\n\n/**\n * Returns a string with a value repeated n times\n * @param {String} val\n * @param {Number} times\n * @returns {String}\n */\nfunction stringRepeat(val, times) {\n  if (!times || times < 0) {\n    return null;\n  }\n  if (times === 1) {\n    return val;\n  }\n  return new Array(times + 1).join(val);\n}\n\n/**\n * Returns an array containing the values of the Object, similar to Object.values().\n * If obj is null or undefined, it will return an empty array.\n * @param {Object} obj\n * @returns {Array}\n */\nfunction objectValues(obj) {\n  if (!obj) {\n    return exports.emptyArray;\n  }\n  var keys = Object.keys(obj);\n  var values = new Array(keys.length);\n  for (var i = 0; i < keys.length; i++) {\n    values[i] = obj[keys[i]];\n  }\n  return values;\n}\n\n/**\n * Wraps the callback-based method. When no originalCallback is not defined, it returns a Promise.\n * @param {ClientOptions} options\n * @param {Function} originalCallback\n * @param {Boolean} allowNoPromiseSupport\n * @param {Function} handler\n * @returns {Promise|undefined}\n */\nfunction promiseWrapper(options, originalCallback, allowNoPromiseSupport, handler) {\n  if (allowNoPromiseSupport && !originalCallback && !options.promiseFactory && typeof Promise === 'undefined') {\n    // Optional callback on some methods is supported, even for js engines without Promise support\n    originalCallback = noop;\n  }\n  if (typeof originalCallback === 'function') {\n    // Callback-based invocation\n    handler.call(this, bindDomain(originalCallback));\n    return undefined;\n  }\n  var factory = options.promiseFactory;\n  if (!factory) {\n    if (typeof Promise === 'undefined') {\n      throw new errors.ArgumentError(\n        'Callback was not provided and Promise is undefined. See ' +\n        'ClientOptions.promiseFactory documentation.');\n    }\n    factory = defaultPromiseFactory;\n  }\n  var self = this;\n  return factory(function handlerWrapper(callback) {\n    handler.call(self, callback);\n  });\n}\n\n/**\n * @param {Function} handler\n * @returns {Promise}\n */\nfunction defaultPromiseFactory(handler) {\n  return new Promise(function executor(resolve, reject) {\n    handler(function handlerCallback(err, result) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(result);\n    });\n  });\n}\n\n// Classes\n\n/**\n * Represents a unique set of values.\n * @constructor\n */\nfunction HashSet() {\n  this.length = 0;\n  this.items = {};\n}\n\n/**\n * Adds a new item to the set.\n * @param {Object} key\n * @returns {boolean} Returns true if it was added to the set; false if the key is already present.\n */\nHashSet.prototype.add = function (key) {\n  if (this.items[key]) {\n    return false;\n  }\n  this.items[key] = true;\n  this.length++;\n  return true;\n};\n\n/**\n * @returns {boolean} Returns true if the key is present in the set.\n */\nHashSet.prototype.contains = function (key) {\n  return this.items[key] === true;\n};\n\n/**\n * Returns an array containing the set items.\n * @returns {Array}\n */\nHashSet.prototype.toArray = function () {\n  return Object.keys(this.items);\n};\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction each(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter is not an Array');\n  }\n  callback = callback || noop;\n  var length = arr.length;\n  if (length === 0) {\n    return callback();\n  }\n  var completed = 0;\n  for (var i = 0; i < length; i++) {\n    fn(arr[i], next);\n  }\n  function next(err) {\n    if (err) {\n      var cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction eachSeries(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter is not an Array');\n  }\n  callback = callback || noop;\n  var length = arr.length;\n  if (length === 0) {\n    return callback();\n  }\n  var sync;\n  var index = 1;\n  fn(arr[0], next);\n  if (sync === undefined) {\n    sync = false;\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (index >= length) {\n      return callback();\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    if (sync) {\n      return process.nextTick(function () {\n        fn(arr[index++], next);\n      });\n    }\n    fn(arr[index++], next);\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction forEachOf(arr, fn, callback) {\n  return mapEach(arr, fn, true, callback);\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction map(arr, fn, callback) {\n  return mapEach(arr, fn, false, callback);\n}\n\nfunction mapEach(arr, fn, useIndex, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  var length = arr.length;\n  if (length === 0) {\n    return callback(null, []);\n  }\n  var result = new Array(length);\n  var completed = 0;\n  var invoke = useIndex ? invokeWithIndex : invokeWithoutIndex;\n  for (var i = 0; i < length; i++) {\n    invoke(i);\n  }\n\n  function invokeWithoutIndex(i) {\n    fn(arr[i], function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function invokeWithIndex(i) {\n    fn(arr[i], i, function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function next(err) {\n    if (err) {\n      var cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback(null, result);\n  }\n}\n\n/**\n * @param {Array} arr\n * @param {Function} fn\n * @param {Function} [callback]\n */\nfunction mapSeries(arr, fn, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  var length = arr.length;\n  if (length === 0) {\n    return callback(null, []);\n  }\n  var result = new Array(length);\n  var index = 0;\n  var sync;\n  invoke(0);\n  if (sync === undefined) {\n    sync = false;\n  }\n\n  function invoke(i) {\n    fn(arr[i], function mapItemCallback(err, transformed) {\n      result[i] = transformed;\n      next(err);\n    });\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (++index === length) {\n      return callback(null, result);\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    var i = index;\n    if (sync) {\n      return process.nextTick(function () {\n        invoke(i);\n      });\n    }\n    invoke(index);\n  }\n}\n\n/**\n * @param {Array.<Function>} arr\n * @param {Function} [callback]\n */\nfunction parallel(arr, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  var length = arr.length;\n  var completed = 0;\n  for (var i = 0; i < length; i++) {\n    arr[i](next);\n  }\n  function next(err) {\n    if (err) {\n      var cb = callback;\n      callback = noop;\n      return cb(err);\n    }\n    if (++completed !== length) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * Similar to async.series(), but instead accumulating the result in an Array, it callbacks with the result of the last\n * function in the array.\n * @param {Array.<Function>} arr\n * @param {Function} [callback]\n */\nfunction series(arr, callback) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('First parameter must be an Array');\n  }\n  callback = callback || noop;\n  var index = 0;\n  var sync;\n  next();\n  function next(err, result) {\n    if (err) {\n      return callback(err);\n    }\n    if (index === arr.length) {\n      return callback(null, result);\n    }\n    if (sync) {\n      return process.nextTick(function () {\n        //noinspection JSUnusedAssignment\n        sync = true;\n        arr[index++](next);\n        sync = false;\n      });\n    }\n    sync = true;\n    arr[index++](next);\n    sync = false;\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Function} iteratorFunc\n * @param {Function} [callback]\n */\nfunction times(count, iteratorFunc, callback) {\n  callback = callback || noop;\n  count = +count;\n  if (isNaN(count) || count === 0) {\n    return callback();\n  }\n  var completed = 0;\n  for (var i = 0; i < count; i++) {\n    iteratorFunc(i, next);\n  }\n  function next(err) {\n    if (err) {\n      var cb = callback;\n      callback = noop;\n      return cb(err);\n    }\n    if (++completed !== count) {\n      return;\n    }\n    callback();\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Number} limit\n * @param {Function} iteratorFunc\n * @param {Function} [callback]\n */\nfunction timesLimit(count, limit, iteratorFunc, callback) {\n  callback = callback || noop;\n  limit = Math.min(limit, count);\n  var index = limit - 1;\n  var i;\n  var completed = 0;\n  for (i = 0; i < limit; i++) {\n    iteratorFunc(i, next);\n  }\n  i = -1;\n  var sync = undefined;\n  function next(err) {\n    if (err) {\n      var cb = callback;\n      callback = noop;\n      cb(err);\n      return;\n    }\n    if (++completed === count) {\n      return callback();\n    }\n    index++;\n    if (index >= count) {\n      return;\n    }\n    if (sync === undefined) {\n      sync = (i >= 0);\n    }\n    if (sync) {\n      var captureIndex = index;\n      return process.nextTick(function () {\n        iteratorFunc(captureIndex, next);\n      });\n    }\n    iteratorFunc(index, next);\n  }\n}\n\n/**\n * @param {Number} count\n * @param {Function} iteratorFunction\n * @param {Function} callback\n */\nfunction timesSeries(count, iteratorFunction, callback) {\n  count = +count;\n  if (isNaN(count) || count < 1) {\n    return callback();\n  }\n  var index = 1;\n  var sync;\n  iteratorFunction(0, next);\n  if (sync === undefined) {\n    sync = false;\n  }\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (index === count) {\n      return callback();\n    }\n    if (sync === undefined) {\n      sync = true;\n    }\n    var i = index++;\n    if (sync) {\n      //Prevent \"Maximum call stack size exceeded\"\n      return process.nextTick(function () {\n        iteratorFunction(i, next);\n      });\n    }\n    //do a sync call as the callback is going to call on a future tick\n    iteratorFunction(i, next);\n  }\n}\n\n/**\n * @param {Function} condition\n * @param {Function} fn\n * @param {Function} callback\n */\nfunction whilst(condition, fn, callback) {\n  var sync = 0;\n  next();\n  function next(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (!condition()) {\n      return callback();\n    }\n    if (sync === 0) {\n      sync = 1;\n      fn(function (err) {\n        if (sync === 1) {\n          //sync function\n          sync = 4;\n        }\n        next(err);\n      });\n      if (sync === 1) {\n        //async function\n        sync = 2;\n      }\n      return;\n    }\n    if (sync === 4) {\n      //Prevent \"Maximum call stack size exceeded\"\n      return process.nextTick(function () {\n        fn(next);\n      });\n    }\n    //do a sync call as the callback is going to call on a future tick\n    fn(next);\n  }\n}\n\nexports.adaptNamedParamsPrepared = adaptNamedParamsPrepared;\nexports.adaptNamedParamsWithHints = adaptNamedParamsWithHints;\nexports.arrayIterator = arrayIterator;\nexports.binarySearch = binarySearch;\nexports.bindDomain = bindDomain;\nexports.copyBuffer = copyBuffer;\nexports.deepExtend = deepExtend;\nexports.each = each;\nexports.eachSeries = eachSeries;\n/** @const */\nexports.emptyArray = Object.freeze([]);\n/** @const */\nexports.emptyObject = Object.freeze({});\nexports.extend = extend;\nexports.fixStack = fixStack;\nexports.forEachOf = forEachOf;\nexports.funcCompare = funcCompare;\nexports.insertSorted = insertSorted;\nexports.iteratorToArray = iteratorToArray;\nexports.log = log;\nexports.map = map;\nexports.mapSeries = mapSeries;\nexports.maxInt = maxInt;\nexports.noop = noop;\nexports.objectValues = objectValues;\nexports.parallel = parallel;\nexports.promiseWrapper = promiseWrapper;\nexports.propCompare = propCompare;\nexports.series = series;\nexports.stringRepeat = stringRepeat;\nexports.times = times;\nexports.timesLimit = timesLimit;\nexports.timesSeries = timesSeries;\nexports.totalLength = totalLength;\nexports.whilst = whilst;\nexports.HashSet = HashSet;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/errors.js":"\"use strict\";\nvar util = require('util');\n/**\n * Contains the error classes exposed by the driver.\n * @module errors\n */\n/**\n * Base Error\n * @private\n */\nfunction DriverError (message, constructor) {\n  if (constructor) {\n    this.name = constructor.name;\n    this.stack = (new Error(message)).stack;\n  }\n  this.message = message || 'Error';\n  this.info = 'Cassandra Driver Error';\n}\nutil.inherits(DriverError, Error);\n/**\n * Represents an error when a query cannot be performed because no host is available or could be reached by the driver.\n * @param {Object} innerErrors An object map containing the error per host tried\n * @param {String} [message]\n * @constructor\n */\nfunction NoHostAvailableError(innerErrors, message) {\n  this.innerErrors = innerErrors;\n  this.info = 'Represents an error when a query cannot be performed because no host is available or could be reached by the driver.';\n  this.message = message;\n  if (!message) {\n    this.message = 'All host(s) tried for query failed.';\n    if (innerErrors) {\n      var hostList = Object.keys(innerErrors);\n      if (hostList.length > 0) {\n        var host = hostList[0];\n        this.message += util.format(' First host tried, %s: %s. See innerErrors.', host, innerErrors[host]);\n      }\n    }\n  }\n}\n\nutil.inherits(NoHostAvailableError, DriverError);\n\n/**\n * Represents an error message from the server\n * @param {Number} code Cassandra exception code\n * @param {String} message\n * @constructor\n */\nfunction ResponseError(code, message) {\n  ResponseError.super_.call(this, message, this.constructor);\n  /**\n   * The error code as defined in [responseErrorCodes]{@link module:types~responseErrorCodes}.\n   * @type {Number}\n   */\n  this.code = code;\n  this.info = 'Represents an error message from the server';\n}\n\nutil.inherits(ResponseError, DriverError);\n\n/**\n * Represents a bug inside the driver or in a Cassandra host.\n * @param {String} message\n * @constructor\n */\nfunction DriverInternalError(message) {\n  DriverInternalError.super_.call(this, message, this.constructor);\n  this.info = 'Represents a bug inside the driver or in a Cassandra host.';\n}\n\nutil.inherits(DriverInternalError, DriverError);\n\n/**\n * Represents an error when trying to authenticate with auth-enabled host\n * @param {String} message\n * @constructor\n */\nfunction AuthenticationError(message) {\n  AuthenticationError.super_.call(this, message, this.constructor);\n  this.info = 'Represents an authentication error from the driver or from a Cassandra node.';\n}\n\nutil.inherits(AuthenticationError, DriverError);\n\n/**\n * Represents an error that is raised when one of the arguments provided to a method is not valid\n * @param {String} message\n * @constructor\n */\nfunction ArgumentError(message) {\n  ArgumentError.super_.call(this, message, this.constructor);\n  this.info = 'Represents an error that is raised when one of the arguments provided to a method is not valid.';\n}\n\nutil.inherits(ArgumentError, DriverError);\n\n/**\n * Represents a client-side error that is raised when the client didn't hear back from the server within\n * {@link ClientOptions.socketOptions.readTimeout}.\n * @constructor\n */\nfunction OperationTimedOutError(message) {\n  OperationTimedOutError.super_.call(this, message, this.constructor);\n  this.info = 'Represents a client-side error that is raised when the client did not hear back from the server ' +\n    'within socketOptions.readTimeout';\n}\n\nutil.inherits(OperationTimedOutError, DriverError);\n\n/**\n * Represents an error that is raised when a feature is not supported in the driver or in the current Cassandra version.\n * @param message\n * @constructor\n */\nfunction NotSupportedError(message) {\n  NotSupportedError.super_.call(this, message, this.constructor);\n  this.info = 'Represents a feature that is not supported in the driver or in the Cassandra version.';\n}\n\nutil.inherits(NotSupportedError, DriverError);\n\nexports.ArgumentError = ArgumentError;\nexports.AuthenticationError = AuthenticationError;\nexports.DriverError = DriverError;\nexports.OperationTimedOutError = OperationTimedOutError;\nexports.DriverInternalError = DriverInternalError;\nexports.NoHostAvailableError = NoHostAvailableError;\nexports.NotSupportedError = NotSupportedError;\nexports.ResponseError = ResponseError;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/load-balancing.js":"\"use strict\";\n\nvar util = require('util');\nvar types = require('../types');\nvar utils = require('../utils.js');\nvar errors = require('../errors.js');\n\nvar doneIteratorObject = Object.freeze({ done: true });\n\n/** @module policies/loadBalancing */\n/**\n * Base class for Load Balancing Policies\n * @constructor\n */\nfunction LoadBalancingPolicy() {\n\n}\n\n/**\n * Initializes the load balancing policy, called after the driver obtained the information of the cluster.\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nLoadBalancingPolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  callback();\n};\n\n//noinspection JSUnusedLocalSymbols\n/**\n * Returns the distance assigned by this policy to the provided host.\n * @param {Host} host\n */\nLoadBalancingPolicy.prototype.getDistance = function (host) {\n  return types.distance.local;\n};\n\n/**\n * Returns an iterator with the hosts for a new query.\n * Each new query will call this method. The first host in the result will\n * then be used to perform the query.\n * @param {String} keyspace Name of the keyspace\n * @param queryOptions options evaluated for this execution\n * @param {Function} callback\n */\nLoadBalancingPolicy.prototype.newQueryPlan = function (keyspace, queryOptions, callback) {\n  callback(new Error('You must implement a query plan for the LoadBalancingPolicy class'));\n};\n\n/**\n * This policy yield nodes in a round-robin fashion.\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction RoundRobinPolicy() {\n  this.index = 0;\n}\n\nutil.inherits(RoundRobinPolicy, LoadBalancingPolicy);\n\n/**\n * @param {String} keyspace Name of the keyspace\n * @param queryOptions options evaluated for this execution\n * @param {Function} callback\n */\nRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, queryOptions, callback) {\n  if (!this.hosts) {\n    return callback(new Error('Load balancing policy not initialized'));\n  }\n  var hosts = this.hosts.values();\n  var self = this;\n  var counter = 0;\n\n  var planIndex = self.index % hosts.length;\n  self.index += 1;\n  if (self.index >= utils.maxInt) {\n    self.index = 0;\n  }\n\n  callback(null, {\n    next: function () {\n      if (++counter > hosts.length) {\n        return doneIteratorObject;\n      }\n      return {value: hosts[planIndex++ % hosts.length], done: false};\n    }\n  });\n};\n\n/**\n * A data-center aware Round-robin load balancing policy.\n * This policy provides round-robin queries over the node of the local\n * data center. It also includes in the query plans returned a configurable\n * number of hosts in the remote data centers, but those are always tried\n * after the local nodes. In other words, this policy guarantees that no\n * host in a remote data center will be queried unless no host in the local\n * data center can be reached.\n * @param {?String} [localDc] local datacenter name.\n * @param {Number} [usedHostsPerRemoteDc] the number of host per remote datacenter that the policy will yield \\\n * in a newQueryPlan after the local nodes.\n * @extends {LoadBalancingPolicy}\n * @constructor\n */\nfunction DCAwareRoundRobinPolicy(localDc, usedHostsPerRemoteDc) {\n  this.localDc = localDc;\n  this.usedHostsPerRemoteDc = usedHostsPerRemoteDc || 0;\n  this.index = 0;\n  /** @type {Array} */\n  this.localHostsArray = null;\n  /** @type {Array} */\n  this.remoteHostsArray = null;\n}\n\nutil.inherits(DCAwareRoundRobinPolicy, LoadBalancingPolicy);\n\n/**\n * Initializes the load balancing policy.\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nDCAwareRoundRobinPolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  hosts.on('add', this._cleanHostCache.bind(this));\n  hosts.on('remove', this._cleanHostCache.bind(this));\n  if (!this.localDc) {\n    //get the first alive local, it should be local on top\n    var hostsArray = hosts.values();\n    for (var i = 0; i < hostsArray.length; i++) {\n      var h = hostsArray[i];\n      if (h.datacenter) {\n        this.localDc = h.datacenter;\n        break;\n      }\n    }\n    //this should never happen but it does not hurt\n    if (!this.localDc) {\n      return callback(new errors.DriverInternalError('Local datacenter could not be determined'));\n    }\n  }\n  callback();\n};\n\n/**\n * Returns the distance depending on the datacenter.\n * @param {Host} host\n */\nDCAwareRoundRobinPolicy.prototype.getDistance = function (host) {\n  if (!host.datacenter) {\n    return types.distance.ignored;\n  }\n  if (host.datacenter === this.localDc) {\n    return types.distance.local;\n  }\n  return types.distance.remote;\n};\n\nDCAwareRoundRobinPolicy.prototype._cleanHostCache = function () {\n  this.localHostsArray = null;\n  this.remoteHostsArray = null;\n};\n\nDCAwareRoundRobinPolicy.prototype._sliceNodesByDc = function() {\n  var hosts = this.hosts.values();\n  if (this.remoteHostsArray) {\n    //there were already calculated\n    return;\n  }\n  //do a full lookup to cache the remote hosts by dc\n  var remoteHostsByDc = {};\n  this.localHostsArray = [];\n  this.remoteHostsArray = [];\n  hosts.forEach(function (h) {\n    if (!h.datacenter) {\n      //not a remote dc node\n      return;\n    }\n    if (h.datacenter === this.localDc) {\n      this.localHostsArray.push(h);\n      return;\n    }\n    if (this.usedHostsPerRemoteDc === 0) {\n      return;\n    }\n    var hostPerDc = remoteHostsByDc[h.datacenter];\n    if (!hostPerDc) {\n      remoteHostsByDc[h.datacenter] = hostPerDc = [];\n    }\n    if (hostPerDc.length < this.usedHostsPerRemoteDc) {\n      hostPerDc.push(h);\n      this.remoteHostsArray.push(h);\n    }\n  }, this);\n};\n\n/**\n * It returns an iterator that yields local nodes first and remotes nodes afterwards.\n * The amount of remote nodes returned will depend on the usedHostsPerRemoteDc\n * @param {String} keyspace Name of the keyspace\n * @param queryOptions\n * @param {Function} callback\n */\nDCAwareRoundRobinPolicy.prototype.newQueryPlan = function (keyspace, queryOptions, callback) {\n  if (!this.hosts) {\n    return callback(new Error('Load balancing policy not initialized'));\n  }\n  this.index += 1;\n  if (this.index >= utils.maxInt) {\n    this.index = 0;\n  }\n  this._sliceNodesByDc();\n  // Use a local reference of hosts\n  var localHostsArray = this.localHostsArray;\n  var remoteHostsArray = this.remoteHostsArray;\n  var planLocalIndex = this.index;\n  var planRemoteIndex = this.index;\n  var counter = 0;\n  var remoteCounter = 0;\n  callback(null, {\n    next: function () {\n      var host;\n      if (counter++ < localHostsArray.length) {\n        host = localHostsArray[planLocalIndex++ % localHostsArray.length];\n        return { value: host, done: false };\n      }\n      if (remoteCounter++ < remoteHostsArray.length) {\n        host = remoteHostsArray[planRemoteIndex++ % remoteHostsArray.length];\n        return { value: host, done: false };\n      }\n      return doneIteratorObject;\n    }\n  });\n};\n\n/**\n * A wrapper load balancing policy that add token awareness to a child policy.\n * @param {LoadBalancingPolicy} childPolicy\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction TokenAwarePolicy (childPolicy) {\n  if (!childPolicy) {\n    throw new Error(\"You must specify a child load balancing policy\");\n  }\n  this.childPolicy = childPolicy;\n}\n\nutil.inherits(TokenAwarePolicy, LoadBalancingPolicy);\n\nTokenAwarePolicy.prototype.init = function (client, hosts, callback) {\n  this.client = client;\n  this.hosts = hosts;\n  this.childPolicy.init(client, hosts, callback);\n};\n\nTokenAwarePolicy.prototype.getDistance = function (host) {\n  return this.childPolicy.getDistance(host);\n};\n\n/**\n * Returns the hosts to use for a new query.\n * The returned plan will first return replicas (whose HostDistance\n * for the child policy is local) for the query if it can determine\n * them is not.\n * Following what it will return the plan of the child policy.\n * @param {String} keyspace Name of the keyspace\n * @param queryOptions\n * @param {Function} callback\n */\nTokenAwarePolicy.prototype.newQueryPlan = function (keyspace, queryOptions, callback) {\n  var routingKey;\n  if (queryOptions) {\n    routingKey = queryOptions.routingKey;\n  }\n  var replicas;\n  if (routingKey) {\n    replicas = this.client.getReplicas(keyspace, routingKey);\n  }\n  if (!routingKey || !replicas) {\n    return this.childPolicy.newQueryPlan(keyspace, queryOptions, callback);\n  }\n  var iterator = new TokenAwareIterator(keyspace, queryOptions, replicas, this.childPolicy);\n  iterator.iterate(callback);\n};\n\n/**\n * An iterator that holds the context for the subsequent next() calls\n * @param {String} keyspace\n * @param queryOptions\n * @param {Array} replicas\n * @param childPolicy\n * @constructor\n * @ignore\n */\nfunction TokenAwareIterator(keyspace, queryOptions, replicas, childPolicy) {\n  this.keyspace = keyspace;\n  this.childPolicy = childPolicy;\n  this.queryOptions = queryOptions;\n  this.localReplicas = [];\n  this.replicaIndex = 0;\n  this.replicaMap = {};\n  this.childIterator = null;\n  // Memoize the local replicas\n  // The amount of local replicas should be defined before start iterating, in order to select an\n  // appropriate (pseudo random) startIndex\n  for (var i = 0; i < replicas.length; i++) {\n    var host = replicas[i];\n    if (this.childPolicy.getDistance(host) !== types.distance.local) {\n      continue;\n    }\n    this.replicaMap[host.address] = true;\n    this.localReplicas.push(host);\n  }\n  // We use a PRNG to set the replica index\n  // We only care about proportional fair scheduling between replicas of a given token\n  // Math.random() has an extremely short permutation cycle length but we don't care about collisions\n  this.startIndex = Math.floor(Math.random() * this.localReplicas.length);\n}\n\nTokenAwareIterator.prototype.iterate = function (callback) {\n  //Load the child policy hosts\n  var self = this;\n  this.childPolicy.newQueryPlan(this.keyspace, this.queryOptions, function (err, iterator) {\n    if (err) {\n      return callback(err);\n    }\n    //get the iterator of the child policy in case is needed\n    self.childIterator = iterator;\n    callback(null, {\n      next: function () { return self.computeNext(); }\n    });\n  });\n};\n\nTokenAwareIterator.prototype.computeNext = function () {\n  var host;\n  if (this.replicaIndex < this.localReplicas.length) {\n    host = this.localReplicas[(this.startIndex + (this.replicaIndex++)) % this.localReplicas.length];\n    return { value: host, done: false };\n  }\n  // Return hosts from child policy\n  var item;\n  while ((item = this.childIterator.next()) && !item.done) {\n    if (this.replicaMap[item.value.address]) {\n      // Avoid yielding local replicas from the child load balancing policy query plan\n      continue;\n    }\n    return item;\n  }\n  return doneIteratorObject;\n};\n\n/**\n * Create a new policy that wraps the provided child policy but only \"allow\" hosts\n * from the provided while list.\n * @class\n * @classdesc\n * A load balancing policy wrapper that ensure that only hosts from a provided\n * white list will ever be returned.\n * <p>\n * This policy wraps another load balancing policy and will delegate the choice\n * of hosts to the wrapped policy with the exception that only hosts contained\n * in the white list provided when constructing this policy will ever be\n * returned. Any host not in the while list will be considered ignored\n * and thus will not be connected to.\n * <p>\n * This policy can be useful to ensure that the driver only connects to a\n * predefined set of hosts. Keep in mind however that this policy defeats\n * somewhat the host auto-detection of the driver. As such, this policy is only\n * useful in a few special cases or for testing, but is not optimal in general.\n * If all you want to do is limiting connections to hosts of the local\n * data-center then you should use DCAwareRoundRobinPolicy and *not* this policy\n * in particular.\n * @param {LoadBalancingPolicy} childPolicy the wrapped policy.\n * @param {Array.<string>}  whiteList the white listed hosts address in the format ipAddress:port.\n * Only hosts from this list may get connected\n * to (whether they will get connected to or not depends on the child policy).\n * @extends LoadBalancingPolicy\n * @constructor\n */\nfunction WhiteListPolicy (childPolicy, whiteList) {\n  if (!childPolicy) {\n    throw new Error(\"You must specify a child load balancing policy\");\n  }\n  if (!util.isArray(whiteList)) {\n    throw new Error(\"You must provide the white list of host addresses\");\n  }\n  this.childPolicy = childPolicy;\n  var map = {};\n  whiteList.forEach(function (address) {\n    map[address] = true;\n  });\n  this.whiteList = map;\n}\n\nutil.inherits(WhiteListPolicy, LoadBalancingPolicy);\n\nWhiteListPolicy.prototype.init = function (client, hosts, callback) {\n  this.childPolicy.init(client, hosts, callback);\n};\n\n/**\n * Uses the child policy to return the distance to the host if included in the white list.\n * Any host not in the while list will be considered ignored.\n * @param host\n */\nWhiteListPolicy.prototype.getDistance = function (host) {\n  if (!this._contains(host)) {\n    return types.distance.ignored;\n  }\n  return this.childPolicy.getDistance(host);\n};\n\n/**\n * @param {Host} host\n * @returns {boolean}\n * @private\n */\nWhiteListPolicy.prototype._contains = function (host) {\n  return !!this.whiteList[host.address];\n};\n\n/**\n * Returns the hosts to use for a new query filtered by the white list.\n */\nWhiteListPolicy.prototype.newQueryPlan = function (keyspace, queryOptions, callback) {\n  var self = this;\n  this.childPolicy.newQueryPlan(keyspace, queryOptions, function (err, iterator) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, self._filter(iterator));\n  });\n};\n\nWhiteListPolicy.prototype._filter = function (childIterator) {\n  var self = this;\n  return {\n    next: function () {\n      var item = childIterator.next();\n      if (!item.done && !self._contains(item.value)) {\n        return this.next();\n      }\n      return item;\n    }\n  };\n};\n\n\nexports.DCAwareRoundRobinPolicy = DCAwareRoundRobinPolicy;\nexports.LoadBalancingPolicy = LoadBalancingPolicy;\nexports.RoundRobinPolicy = RoundRobinPolicy;\nexports.TokenAwarePolicy = TokenAwarePolicy;\nexports.WhiteListPolicy = WhiteListPolicy;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/index.js":"'use strict';\nvar util = require('util');\n\nvar errors = require('../errors');\nvar TimeUuid = require('./time-uuid');\nvar Uuid = require('./uuid');\n\n/** @module types */\n/**\n * Long constructor, wrapper of the internal library used: {@link http://docs.closure-library.googlecode.com/git/class_goog_math_Long.html Google Closure Long}.\n * @constructor\n */\nvar Long = require('long');\n\n/**\n * Consistency levels\n * @type {Object}\n * @property {Number} any Writing: A write must be written to at least one node. If all replica nodes for the given row key are down, the write can still succeed after a hinted handoff has been written. If all replica nodes are down at write time, an ANY write is not readable until the replica nodes for that row have recovered.\n * @property {Number} one Returns a response from the closest replica, as determined by the snitch.\n * @property {Number} two Returns the most recent data from two of the closest replicas.\n * @property {Number} three Returns the most recent data from three of the closest replicas.\n * @property {Number} quorum Reading: Returns the record with the most recent timestamp after a quorum of replicas has responded regardless of data center. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes.\n * @property {Number} all Reading: Returns the record with the most recent timestamp after all replicas have responded. The read operation will fail if a replica does not respond. Writing: A write must be written to the commit log and memory table on all replica nodes in the cluster for that row.\n * @property {Number} localQuorum Reading: Returns the record with the most recent timestamp once a quorum of replicas in the current data center as the coordinator node has reported. Writing: A write must be written to the commit log and memory table on a quorum of replica nodes in the same data center as the coordinator node. Avoids latency of inter-data center communication.\n * @property {Number} eachQuorum Reading: Returns the record once a quorum of replicas in each data center of the cluster has responded. Writing: Strong consistency. A write must be written to the commit log and memtable on a quorum of replica nodes in all data centers.\n * @property {Number} serial Achieves linearizable consistency for lightweight transactions by preventing unconditional updates.\n * @property {Number} localSerial Same as serial but confined to the data center. A write must be written conditionally to the commit log and memtable on a quorum of replica nodes in the same data center.\n * @property {Number} localOne Similar to One but only within the DC the coordinator is in.\n */\nvar consistencies = {\n  any:          0x00,\n  one:          0x01,\n  two:          0x02,\n  three:        0x03,\n  quorum:       0x04,\n  all:          0x05,\n  localQuorum:  0x06,\n  eachQuorum:   0x07,\n  serial:       0x08,\n  localSerial:  0x09,\n  localOne:     0x0a\n};\n\n/**\n * CQL data types\n * @type {Object}\n * @property {Number} custom A custom type.\n * @property {Number} ascii ASCII character string.\n * @property {Number} bigint 64-bit signed long.\n * @property {Number} blob Arbitrary bytes (no validation).\n * @property {Number} boolean true or false.\n * @property {Number} counter Counter column (64-bit signed value).\n * @property {Number} decimal Variable-precision decimal.\n * @property {Number} double 64-bit IEEE-754 floating point.\n * @property {Number} float 32-bit IEEE-754 floating point.\n * @property {Number} int 32-bit signed integer.\n * @property {Number} text UTF8 encoded string.\n * @property {Number} timestamp A timestamp.\n * @property {Number} uuid Type 1 or type 4 UUID.\n * @property {Number} varchar UTF8 encoded string.\n * @property {Number} varint Arbitrary-precision integer.\n * @property {Number} timeuuid  Type 1 UUID.\n * @property {Number} inet An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6).\n * @property {Number} date A date without a time-zone in the ISO-8601 calendar system.\n * @property {Number} time A value representing the time portion of the day.\n * @property {Number} smallint 16-bit two's complement integer.\n * @property {Number} tinyint 8-bit two's complement integer.\n * @property {Number} list A collection of elements.\n * @property {Number} map Key/value pairs.\n * @property {Number} set A collection that contains no duplicate elements.\n * @property {Number} udt User-defined type.\n * @property {Number} tuple A sequence of values.\n */\nvar dataTypes = {\n  custom:     0x0000,\n  ascii:      0x0001,\n  bigint:     0x0002,\n  blob:       0x0003,\n  boolean:    0x0004,\n  counter:    0x0005,\n  decimal:    0x0006,\n  double:     0x0007,\n  float:      0x0008,\n  int:        0x0009,\n  text:       0x000a,\n  timestamp:  0x000b,\n  uuid:       0x000c,\n  varchar:    0x000d,\n  varint:     0x000e,\n  timeuuid:   0x000f,\n  inet:       0x0010,\n  date:       0x0011,\n  time:       0x0012,\n  smallint:   0x0013,\n  tinyint:    0x0014,\n  list:       0x0020,\n  map:        0x0021,\n  set:        0x0022,\n  udt:        0x0030,\n  tuple:      0x0031,\n  /**\n   * Returns the typeInfo of a given type name\n   * @param name\n   * @returns {{code: number, info: *|Object}}\n   */\n  getByName:  function(name) {\n    name = name.toLowerCase();\n    if (name.indexOf('<') > 0) {\n      var listMatches = /^(list|set)<(.+)>$/.exec(name);\n      if (listMatches) {\n        return { code: this[listMatches[1]], info: this.getByName(listMatches[2])};\n      }\n      var mapMatches = /^(map)< *(.+) *, *(.+)>$/.exec(name);\n      if (mapMatches) {\n        return { code: this[mapMatches[1]], info: [this.getByName(mapMatches[2]), this.getByName(mapMatches[3])]};\n      }\n      var udtMatches = /^(udt)<(.+)>$/.exec(name);\n      if (udtMatches) {\n        //udt name as raw string\n        return { code: this[udtMatches[1]], info: udtMatches[2]};\n      }\n      var tupleMatches = /^(tuple)<(.+)>$/.exec(name);\n      if (tupleMatches) {\n        //tuple info as an array of types\n        return { code: this[tupleMatches[1]], info: tupleMatches[2].split(',').map(function (x) {\n          return this.getByName(x.trim());\n        }, this)};\n      }\n    }\n    var typeInfo = { code: this[name], info: null};\n    if (typeof typeInfo.code !== 'number') {\n      throw new TypeError('Data type with name ' + name + ' not valid');\n    }\n    return typeInfo;\n  }\n};\n\n/**\n * Map of Data types by code\n * @internal\n * @private\n */\nvar _dataTypesByCode = (function () {\n  var result = {};\n  for (var key in dataTypes) {\n    if (!dataTypes.hasOwnProperty(key)) {\n      continue;\n    }\n    var val = dataTypes[key];\n    if (typeof val !== 'number') {\n      continue;\n    }\n    result[val] = key;\n  }\n  return result;\n})();\n\n/**\n * Represents the distance of Cassandra node as assigned by a LoadBalancingPolicy relatively to the driver instance.\n * @type {Object}\n * @property {Number} local A local node.\n * @property {Number} remote A remote node.\n * @property {Number} ignored A node that is meant to be ignored.\n */\nvar distance = {\n  local:    0,\n  remote:   1,\n  ignored:  2\n};\n\n/**\n * An integer byte that distinguish the actual message from and to Cassandra\n * @internal\n * @ignore\n */\nvar opcodes = {\n  error:          0x00,\n  startup:        0x01,\n  ready:          0x02,\n  authenticate:   0x03,\n  credentials:    0x04,\n  options:        0x05,\n  supported:      0x06,\n  query:          0x07,\n  result:         0x08,\n  prepare:        0x09,\n  execute:        0x0a,\n  register:       0x0b,\n  event:          0x0c,\n  batch:          0x0d,\n  authChallenge:  0x0e,\n  authResponse:   0x0f,\n  authSuccess:    0x10,\n\n  /**\n   * Determines if the code is a valid opcode\n   */\n  isInRange: function (code) {\n    return code > this.error && code > this.event;\n  }\n};\n\n/**\n * Event types from Cassandra\n * @type {{topologyChange: string, statusChange: string, schemaChange: string}}\n * @internal\n * @ignore\n */\nvar protocolEvents = {\n  topologyChange: 'TOPOLOGY_CHANGE',\n  statusChange: 'STATUS_CHANGE',\n  schemaChange: 'SCHEMA_CHANGE'\n};\n\n/**\n * Server error codes returned by Cassandra\n */\nvar responseErrorCodes = {\n  serverError:            0x0000,\n  protocolError:          0x000A,\n  badCredentials:         0x0100,\n  unavailableException:   0x1000,\n  overloaded:             0x1001,\n  isBootstrapping:        0x1002,\n  truncateError:          0x1003,\n  writeTimeout:           0x1100,\n  readTimeout:            0x1200,\n  readFailure:            0x1300,\n  functionFailure:        0x1400,\n  writeFailure:           0x1500,\n  syntaxError:            0x2000,\n  unauthorized:           0x2100,\n  invalid:                0x2200,\n  configError:            0x2300,\n  alreadyExists:          0x2400,\n  unprepared:             0x2500\n};\n\n/**\n * Type of result included in a response\n * @internal\n * @ignore\n */\nvar resultKind = {\n  voidResult:      0x0001,\n  rows:            0x0002,\n  setKeyspace:     0x0003,\n  prepared:        0x0004,\n  schemaChange:    0x0005\n};\n\n/**\n * Message frame flags\n * @internal\n * @ignore\n */\nvar frameFlags = {\n  compression:    0x01,\n  tracing:        0x02,\n  customPayload:  0x04,\n  warning:        0x08\n};\n\n/**\n * Unset representation.\n * <p>\n *   Use this field if you want to set a parameter to <code>unset</code>. Valid for Cassandra 2.2 and above.\n * </p>\n */\nvar unset = Object.freeze({'unset': true});\n\n/**\n * A long representing the value 1000\n * @const\n * @private\n */\nvar _longOneThousand = Long.fromInt(1000);\n\n/**\n * Counter used to generate up to 1000 different timestamp values with the same Date\n * @private\n */\nvar _timestampTicks = 0;\n\n/**\n * <p><strong>Backward compatibility only, use [TimeUuid]{@link module:types~TimeUuid} instead</strong>.</p>\n * Generates and returns a RFC4122 v1 (timestamp based) UUID in a string representation.\n * @param {{msecs, node, clockseq, nsecs}} [options]\n * @param {Buffer} [buffer]\n * @param {Number} [offset]\n * @deprecated Use [TimeUuid]{@link module:types~TimeUuid} instead\n */\nfunction timeuuid(options, buffer, offset) {\n  var date;\n  var ticks;\n  var nodeId;\n  var clockId;\n  if (options) {\n    if (typeof options.msecs === 'number') {\n      date = new Date(options.msecs);\n    }\n    if (options.msecs instanceof Date) {\n      date = options.msecs;\n    }\n    if (util.isArray(options.node)) {\n      nodeId = new Buffer(options.node);\n    }\n    if (typeof options.clockseq === 'number') {\n      clockId = new Buffer(2);\n      clockId.writeUInt16BE(options.clockseq, 0);\n    }\n    if (typeof options.nsecs === 'number') {\n      ticks = options.nsecs;\n    }\n  }\n  var uuid = new TimeUuid(date, ticks, nodeId, clockId);\n  if (buffer instanceof Buffer) {\n    //copy the values into the buffer\n    uuid.getBuffer().copy(buffer, offset || 0);\n    return buffer;\n  }\n  return uuid.toString();\n}\n\n/**\n * <p><strong>Backward compatibility only, use [Uuid]{@link module:types~Uuid} class instead</strong>.</p>\n * Generate and return a RFC4122 v4 UUID in a string representation.\n * @deprecated Use [Uuid]{@link module:types~Uuid} class instead\n */\nfunction uuid(options, buffer, offset) {\n  var uuid;\n  if (options) {\n    if (util.isArray(options.random)) {\n      uuid = new Uuid(new Buffer(options.random));\n    }\n  }\n  if (!uuid) {\n    uuid = Uuid.random();\n  }\n  if (buffer instanceof Buffer) {\n    //copy the values into the buffer\n    uuid.getBuffer().copy(buffer, offset || 0);\n    return buffer;\n  }\n  return uuid.toString();\n}\n\n/**\n * Gets the data type name for a given type definition\n * @internal\n * @ignore\n * @throws {ArgumentError}\n */\nfunction getDataTypeNameByCode(item) {\n  if (!item || typeof item.code !== 'number') {\n    throw new errors.ArgumentError('Invalid signature type definition');\n  }\n  var typeName = _dataTypesByCode[item.code];\n  if (!typeName) {\n    throw new errors.ArgumentError(util.format('Type with code %d not found', item.code));\n  }\n  if (!item.info) {\n    return typeName;\n  }\n  if (util.isArray(item.info)) {\n    return (typeName +\n      '<' +\n      item.info.map(function (t) {\n        return getDataTypeNameByCode(t);\n      }).join(', ') +\n      '>');\n  }\n  if (typeof item.info.code === 'number') {\n    return typeName + '<' + getDataTypeNameByCode(item.info) + '>';\n  }\n  return typeName;\n}\n\n//classes\n\n/**\n * Represents a frame header that could be used to read from a Buffer or to write to a Buffer\n * @ignore\n * @param {Number} version Protocol version\n * @param {Number} flags\n * @param {Number} streamId\n * @param {Number} opcode\n * @param {Number} bodyLength\n * @constructor\n */\nfunction FrameHeader(version, flags, streamId, opcode, bodyLength) {\n  this.version = version;\n  this.flags = flags;\n  this.streamId = streamId;\n  this.opcode = opcode;\n  this.bodyLength = bodyLength;\n}\n\n/**\n * The length of the header of the frame based on the protocol version\n * @returns {Number}\n */\nFrameHeader.size = function (version) {\n  if (version >= 3) {\n    return 9;\n  }\n  return 8;\n};\n\n/**\n * Gets the protocol version based on the first byte of the header\n * @param {Buffer} buffer\n * @returns {Number}\n */\nFrameHeader.getProtocolVersion = function (buffer) {\n  return buffer[0] & 0x7F;\n};\n\n/**\n * @param {Buffer} buf\n * @param {Number} [offset]\n * @returns {FrameHeader}\n */\nFrameHeader.fromBuffer = function (buf, offset) {\n  var streamId = 0;\n  if (!offset) {\n    offset = 0;\n  }\n  var version = buf[offset++] & 0x7F;\n  var flags = buf.readUInt8(offset++);\n  if (version < 3) {\n    streamId = buf.readInt8(offset++);\n  }\n  else {\n    streamId = buf.readInt16BE(offset);\n    offset += 2;\n  }\n  return new FrameHeader(version, flags, streamId, buf.readUInt8(offset++), buf.readUInt32BE(offset));\n};\n\n/** @returns {Buffer} */\nFrameHeader.prototype.toBuffer = function () {\n  var buf = new Buffer(FrameHeader.size(this.version));\n  buf.writeUInt8(this.version, 0);\n  buf.writeUInt8(this.flags, 1);\n  var offset = 3;\n  if (this.version < 3) {\n    buf.writeInt8(this.streamId, 2);\n  }\n  else {\n    buf.writeInt16BE(this.streamId, 2);\n    offset = 4;\n  }\n  buf.writeUInt8(this.opcode, offset++);\n  buf.writeUInt32BE(this.bodyLength, offset);\n  return buf;\n};\n/**\n * Returns a long representation.\n * Used internally for deserialization\n */\nLong.fromBuffer = function (value) {\n  if (!(value instanceof Buffer)) {\n    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));\n  }\n  return new Long(value.readInt32BE(4), value.readInt32BE(0));\n};\n\n/**\n * Returns a big-endian buffer representation of the Long instance\n * @param {Long} value\n */\nLong.toBuffer = function (value) {\n  if (!(value instanceof Long)) {\n    throw new TypeError('Expected Long, obtained ' + util.inspect(value));\n  }\n  var buffer = new Buffer(8);\n  buffer.writeUInt32BE(value.getHighBitsUnsigned(), 0);\n  buffer.writeUInt32BE(value.getLowBitsUnsigned(), 4);\n  return buffer;\n};\n\n//noinspection JSUnresolvedVariable\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nLong.prototype.inspect = function () {\n  return 'Long: ' + this.toString();\n};\n\n//noinspection JSUnresolvedVariable\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance\n */\nLong.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * Generates a value representing the timestamp for the query in microseconds based on the date and the microseconds provided\n * @param {Date} [date] The date to generate the value, if not provided it will use the current date.\n * @param {Number} [microseconds] A number from 0 to 999 used to build the microseconds part of the date.\n * @returns {Long}\n */\nfunction generateTimestamp(date, microseconds) {\n  if (!date) {\n    date = new Date();\n  }\n  //noinspection JSUnresolvedVariable\n  var longMicro = Long.ZERO;\n  if (typeof microseconds === 'number' && microseconds >= 0 && microseconds < 1000) {\n    longMicro = Long.fromInt(microseconds);\n  }\n  else {\n    if (_timestampTicks > 999) {\n      _timestampTicks = 0;\n    }\n    longMicro = Long.fromInt(_timestampTicks);\n    _timestampTicks++;\n  }\n  return Long\n    .fromNumber(date.getTime())\n    .multiply(_longOneThousand)\n    .add(longMicro);\n}\n\n//error classes\n\n/** @private */\nfunction QueryParserError(e) {\n  QueryParserError.super_.call(this, e.message, this.constructor);\n  this.internalError = e;\n}\nutil.inherits(QueryParserError, errors.DriverError);\n\n/** @private */\nfunction TimeoutError (message) {\n  TimeoutError.super_.call(this, message, this.constructor);\n  this.info = 'Represents an error that happens when the maximum amount of time for an operation passed.';\n}\nutil.inherits(TimeoutError, errors.DriverError);\n\nexports.opcodes = opcodes;\nexports.consistencies = consistencies;\nexports.dataTypes = dataTypes;\nexports.getDataTypeNameByCode = getDataTypeNameByCode;\nexports.distance = distance;\nexports.frameFlags = frameFlags;\nexports.protocolEvents = protocolEvents;\nexports.responseErrorCodes = responseErrorCodes;\nexports.resultKind = resultKind;\nexports.timeuuid = timeuuid;\nexports.uuid = uuid;\nexports.BigDecimal = require('./big-decimal');\nexports.FrameHeader = FrameHeader;\nexports.InetAddress = require('./inet-address');\nexports.Integer = require('./integer');\nexports.LocalDate = require('./local-date');\nexports.LocalTime = require('./local-time');\nexports.Long = Long;\nexports.ResultSet = require('./result-set');\nexports.ResultStream = require('./result-stream');\nexports.Row = require('./row');\n//export DriverError for backward-compatibility\nexports.DriverError = errors.DriverError;\nexports.TimeoutError = TimeoutError;\nexports.TimeUuid = TimeUuid;\nexports.Tuple = require('./tuple');\nexports.Uuid = Uuid;\nexports.unset = unset;\nexports.generateTimestamp = generateTimestamp;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/time-uuid.js":"'use strict';\nvar util = require('util');\nvar crypto = require('crypto');\nvar Long = require('long');\n\nvar Uuid = require('./uuid');\n/** @module types */\n/**\n * Oct 15, 1582 in milliseconds since unix epoch\n * @const\n * @private\n */\nvar _unixToGregorian = 12219292800000;\n/**\n * 10,000 ticks in a millisecond\n * @const\n * @private\n */\nvar _ticksInMs = 10000;\n/**\n * Counter used to generate up to 10000 different timeuuid values with the same Date\n * @private\n * @type {number}\n */\nvar _ticks = 0;\n/**\n * Counter used to generate ticks for the current time\n * @private\n * @type {number}\n */\nvar _ticksForCurrentTime = 0;\n/**\n * Remember the last time when a ticks for the current time so that it can be reset\n * @private\n * @type {number}\n */\nvar _lastTimestamp = 0;\n/**\n * Creates a new instance of Uuid based on the parameters provided according to rfc4122.\n * If any of the arguments is not provided, it will be randomly generated, except for the date that will use the current date.\n * @class\n * @classdesc Represents an immutable version 1 universally unique identifier (UUID). A UUID represents a 128-bit value.\n * <p>Usage: <code>TimeUuid.now()</code></p>\n * @extends module:types~Uuid\n * @param {Date} [value] The datetime for the instance, if not provided, it will use the current Date.\n * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,\n * as Ecmascript Dates have only milliseconds precision.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * @constructor\n */\nfunction TimeUuid(value, ticks, nodeId, clockId) {\n  var buffer;\n  if (value instanceof Buffer) {\n    if (value.length !== 16) {\n      throw new Error('Buffer for v1 uuid not valid');\n    }\n    buffer = value;\n  }\n  else {\n    buffer = generateBuffer(value, ticks, nodeId, clockId);\n  }\n  Uuid.call(this, buffer);\n}\n\nutil.inherits(TimeUuid, Uuid);\n\n/**\n * Generates a TimeUuid instance based on the Date provided using random node and clock values.\n * @param {Date} date Date to generate the v1 uuid.\n * @param {Number} [ticks] A number from 0 to 10000 representing the 100-nanoseconds units for this instance to fill in the information not available in the Date,\n * as Ecmascript Dates have only milliseconds precision.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * If not provided, a random nodeId will be generated.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * If not provided a random clockId will be generated.\n */\nTimeUuid.fromDate = function (date, ticks, nodeId, clockId) {\n  return new TimeUuid(date, ticks, nodeId, clockId);\n};\n\n/**\n * Parses a string representation of a TimeUuid\n * @param {String} value\n * @returns {TimeUuid}\n */\nTimeUuid.fromString = function (value) {\n  return new TimeUuid(Uuid.fromString(value).getBuffer());\n};\n\n/**\n * Returns the smaller possible type 1 uuid with the provided Date.\n */\nTimeUuid.min = function (date, ticks) {\n  return new TimeUuid(date, ticks, new Buffer('808080808080', 'hex'), new Buffer('8080', 'hex'));\n};\n\n/**\n * Returns the biggest possible type 1 uuid with the provided Date.\n */\nTimeUuid.max = function (date, ticks) {\n  return new TimeUuid(date, ticks, new Buffer('7f7f7f7f7f7f', 'hex'), new Buffer('7f7f', 'hex'));\n};\n\n/**\n * Generates a TimeUuid instance based on the current date using random node and clock values.\n * @param {String|Buffer} [nodeId] A 6-length Buffer or string of 6 ascii characters representing the node identifier, ie: 'host01'.\n * If not provided, a random nodeId will be generated.\n * @param {String|Buffer} [clockId] A 2-length Buffer or string of 6 ascii characters representing the clock identifier.\n * If not provided a random clockId will be generated.\n */\nTimeUuid.now = function (nodeId, clockId) {\n  return new TimeUuid(null, null, nodeId, clockId);\n};\n\n\n/**\n * Gets the Date and 100-nanoseconds units representation of this instance.\n * @returns {{date: Date, ticks: Number}}\n */\nTimeUuid.prototype.getDatePrecision = function () {\n  var timeLow = this.buffer.readUInt32BE(0);\n\n  var timeHigh = 0;\n  timeHigh |= ( this.buffer[4] & 0xff ) << 8;\n  timeHigh |= this.buffer[5] & 0xff;\n  timeHigh |= ( this.buffer[6] & 0x0f ) << 24;\n  timeHigh |= ( this.buffer[7] & 0xff ) << 16;\n\n  var val = Long.fromBits(timeLow, timeHigh);\n  var ticksInMsLong = Long.fromNumber(_ticksInMs);\n  var ticks = val.modulo(ticksInMsLong);\n  var time = val\n    .div(ticksInMsLong)\n    .subtract(Long.fromNumber(_unixToGregorian));\n  return { date: new Date(time.toNumber()), ticks: ticks.toNumber()};\n};\n\n/**\n * Gets the Date representation of this instance.\n * @returns {Date}\n */\nTimeUuid.prototype.getDate = function () {\n  return this.getDatePrecision().date;\n};\n\n/**\n * Returns the node id this instance\n * @returns {Buffer}\n */\nTimeUuid.prototype.getNodeId = function () {\n  return this.buffer.slice(10);\n};\n\n/**\n * Returns the node id this instance as an ascii string\n * @returns {String}\n */\nTimeUuid.prototype.getNodeIdString = function () {\n  return this.buffer.slice(10).toString('ascii');\n};\n\nfunction writeTime(buffer, time, ticks) {\n  //value time expressed in ticks precision\n  var val = Long\n    .fromNumber(time + _unixToGregorian)\n    .multiply(Long.fromNumber(10000))\n    .add(Long.fromNumber(ticks));\n  var timeHigh = val.getHighBitsUnsigned();\n  buffer.writeUInt32BE(val.getLowBitsUnsigned(), 0, true);\n  buffer.writeUInt16BE(timeHigh & 0xffff, 4, true);\n  buffer.writeUInt16BE(timeHigh >>> 16 & 0xffff, 6, true);\n}\n\n/**\n * Returns a buffer of length 2 representing the clock identifier\n * @param {String|Buffer} clockId\n * @returns {Buffer}\n * @private\n */\nfunction getClockId(clockId) {\n  var buffer = clockId;\n  if (typeof clockId === 'string') {\n    buffer = new Buffer(clockId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(2);\n  }\n  else if (buffer.length !== 2) {\n    throw new Error('Clock identifier must have 2 bytes');\n  }\n  return buffer;\n}\n\n/**\n * Returns a buffer of length 6 representing the clock identifier\n * @param {String|Buffer} nodeId\n * @returns {Buffer}\n * @private\n */\nfunction getNodeId(nodeId) {\n  var buffer = nodeId;\n  if (typeof nodeId === 'string') {\n    buffer = new Buffer(nodeId, 'ascii');\n  }\n  if (!(buffer instanceof Buffer)) {\n    //Generate\n    buffer = getRandomBytes(6);\n  }\n  else if (buffer.length !== 6) {\n    throw new Error('Node identifier must have 6 bytes');\n  }\n  return buffer;\n}\n\n/**\n * Returns the ticks portion of a timestamp.  If the ticks are not provided an internal counter is used that gets reset at 10000.\n * @private\n * @param {Number} [ticks] \n * @returns {Number} \n */\nfunction getTicks(ticks) {\n  if (typeof ticks !== 'number'|| ticks >= _ticksInMs) {\n    _ticks++;\n    if (_ticks >= _ticksInMs) {\n      _ticks = 0;\n    }\n    ticks = _ticks;\n  }\n  return ticks;\n}\n\n/**\n * Returns an object with the time representation of the date expressed in milliseconds since unix epoch \n * and a ticks property for the 100-nanoseconds precision.\n * @private\n * @returns {{time: Number, ticks: Number}} \n */\nfunction getTimeWithTicks(date, ticks) {\n  if (!(date instanceof Date) || isNaN(date.getTime())) {\n    // time with ticks for the current time\n    date = new Date();\n    var time = date.getTime();\n    _ticksForCurrentTime++;\n    if(_ticksForCurrentTime > _ticksInMs || time > _lastTimestamp) {\n      _ticksForCurrentTime = 0;\n      _lastTimestamp = time;\n    }\n    ticks = _ticksForCurrentTime;\n  }\n  return {\n    time: date.getTime(),\n    ticks: getTicks(ticks)\n  };\n}\n\nfunction getRandomBytes(length) {\n  return crypto.randomBytes(length);\n}\n\n/**\n * Generates a 16-length Buffer instance\n * @private\n * @param {Date} date\n * @param {Number} ticks\n * @param {String|Buffer} nodeId\n * @param {String|Buffer} clockId\n * @returns {Buffer}\n */\nfunction generateBuffer(date, ticks, nodeId, clockId) {\n  var timeWithTicks = getTimeWithTicks(date, ticks);\n  nodeId = getNodeId(nodeId);\n  clockId = getClockId(clockId);\n  var buffer = new Buffer(16);\n  //Positions 0-7 Timestamp\n  writeTime(buffer, timeWithTicks.time, timeWithTicks.ticks);\n  //Position 8-9 Clock\n  clockId.copy(buffer, 8, 0);\n  //Positions 10-15 Node\n  nodeId.copy(buffer, 10, 0);\n  //Version Byte: Time based\n  //0001xxxx\n  //turn off first 4 bits\n  buffer[6] = buffer[6] & 0x0f;\n  //turn on fifth bit\n  buffer[6] = buffer[6] | 0x10;\n\n  //IETF Variant Byte: 1.0.x\n  //10xxxxxx\n  //turn off first 2 bits\n  buffer[8] = buffer[8] & 0x3f;\n  //turn on first bit\n  buffer[8] = buffer[8] | 0x80;\n  return buffer;\n}\n\nmodule.exports = TimeUuid;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/uuid.js":"'use strict';\nvar crypto = require('crypto');\n\n/** @module types */\n\n/**\n * Creates a new instance of Uuid based on a Buffer\n * @class\n * @classdesc Represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.\n * @param {Buffer} buffer The 16-length buffer.\n * @constructor\n */\nfunction Uuid(buffer) {\n  if (!buffer || buffer.length !== 16) {\n    throw new Error('You must provide a buffer containing 16 bytes');\n  }\n  this.buffer = buffer;\n}\n\n/**\n * Parses a string representation of a Uuid\n * @param {String} value\n * @returns {Uuid}\n */\nUuid.fromString = function (value) {\n  //36 chars: 32 + 4 hyphens\n  if (typeof value !== 'string' || value.length !== 36) {\n    throw new Error('Invalid string representation of Uuid, it should be in the 00000000-0000-0000-0000-000000000000');\n  }\n  return new Uuid(new Buffer(value.replace(/-/g, ''), 'hex'));\n};\n\n/**\n * Creates a new random (version 4) Uuid.\n * @returns {Uuid}\n */\nUuid.random = function () {\n  var buffer = getRandomBytes();\n  //clear the version\n  buffer[6] &= 0x0f;\n  //set the version 4\n  buffer[6] |= 0x40;\n  //clear the variant\n  buffer[8] &= 0x3f;\n  //set the IETF variant\n  buffer[8] |= 0x80;\n  return new Uuid(buffer);\n};\n\n/**\n * Gets the bytes representation of a Uuid\n * @returns {Buffer}\n */\nUuid.prototype.getBuffer = function () {\n  return this.buffer;\n};\n/**\n * Compares this object to the specified object.\n * The result is true if and only if the argument is not null, is a UUID object, and contains the same value, bit for bit, as this UUID.\n * @param {Uuid} other The other value to test for equality.\n */\nUuid.prototype.equals = function (other) {\n  return !!(other instanceof Uuid && this.buffer.toString('hex') === other.buffer.toString('hex'));\n};\n\n/**\n * Returns a string representation of the value of this Uuid instance.\n * 32 hex separated by hyphens, in the form of 00000000-0000-0000-0000-000000000000.\n * @returns {String}\n */\nUuid.prototype.toString = function () {\n  //32 hex representation of the Buffer\n  var hexValue = getHex(this);\n  return (\n    hexValue.substr(0, 8) + '-' +\n    hexValue.substr(8, 4) + '-' +\n    hexValue.substr(12, 4) + '-' +\n    hexValue.substr(16, 4) + '-' +\n    hexValue.substr(20, 12));\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nUuid.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nUuid.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * @private\n * @returns {String} 32 hex representation of the instance, without separators\n */\nfunction getHex (uuid) {\n  return uuid.buffer.toString('hex');\n}\n\n/**\n * Gets a crypto generated 16 bytes\n * @private\n * @returns {Buffer}\n */\nfunction getRandomBytes() {\n  return crypto.randomBytes(16);\n}\n\nmodule.exports = Uuid;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/big-decimal.js":"'use strict';\nvar Integer = require('./integer');\nvar utils = require('../utils');\n\n/** @module types */\n/**\n * Constructs an immutable arbitrary-precision signed decimal number.\n * A <code>BigDecimal</code> consists of an [arbitrary precision integer]{@link module:types~Integer}\n * <i>unscaled value</i> and a 32-bit integer <i>scale</i>.  If zero\n * or positive, the scale is the number of digits to the right of the\n * decimal point.  If negative, the unscaled value of the number is\n * multiplied by ten to the power of the negation of the scale.  The\n * value of the number represented by the <code>BigDecimal</code> is\n * therefore <tt>(unscaledValue &times; 10<sup>-scale</sup>)</tt>.\n * @class\n * @classdesc The <code>BigDecimal</code> class provides operations for\n * arithmetic, scale manipulation, rounding, comparison and\n * format conversion.  The {@link #toString} method provides a\n * canonical representation of a <code>BigDecimal</code>.\n * @param {Integer|Number} unscaledValue The integer part of the decimal.\n * @param {Number} scale The scale of the decimal.\n * @constructor\n */\nfunction BigDecimal(unscaledValue, scale) {\n  if (typeof unscaledValue === 'number') {\n    unscaledValue = Integer.fromNumber(unscaledValue);\n  }\n  /**\n   * @type {Integer}\n   * @private\n   */\n  this._intVal = unscaledValue;\n  /**\n   * @type {Number}\n   * @private\n   */\n  this._scale = scale;\n}\n\n/**\n * Returns the BigDecimal representation of a buffer composed of the scale (int32BE) and the unsigned value (varint BE)\n * @param {Buffer} buf\n * @returns {BigDecimal}\n */\nBigDecimal.fromBuffer = function (buf) {\n  var scale = buf.readInt32BE(0);\n  var unscaledValue = Integer.fromBuffer(buf.slice(4));\n  return new BigDecimal(unscaledValue, scale);\n};\n\n/**\n * Returns a buffer representation composed of the scale as a BE int 32 and the unsigned value as a BE varint\n * @param {BigDecimal} value\n * @returns {Buffer}\n */\nBigDecimal.toBuffer = function (value) {\n  var unscaledValueBuffer = Integer.toBuffer(value._intVal);\n  var scaleBuffer = new Buffer(4);\n  scaleBuffer.writeInt32BE(value._scale, 0);\n  return Buffer.concat([scaleBuffer, unscaledValueBuffer], scaleBuffer.length + unscaledValueBuffer.length);\n};\n\n/**\n * Returns a BigDecimal representation of the string\n * @param {String} value\n * @returns {BigDecimal}\n */\nBigDecimal.fromString = function (value) {\n  if (!value) {\n    throw new TypeError('Invalid null or undefined value');\n  }\n  value = value.trim();\n  var scaleIndex = value.indexOf('.');\n  var scale = 0;\n  if (scaleIndex >= 0) {\n    scale = value.length - 1 - scaleIndex;\n    value = value.substr(0, scaleIndex) + value.substr(scaleIndex + 1);\n  }\n  return new BigDecimal(Integer.fromString(value), scale);\n};\n\n/**\n * Returns a BigDecimal representation of the Number\n * @param {Number} value\n * @returns {BigDecimal}\n */\nBigDecimal.fromNumber = function (value) {\n  if (isNaN(value)) {\n    return new BigDecimal(Integer.ZERO, 0);\n  }\n  var textValue = value.toString();\n  if (textValue.indexOf('e') >= 0) {\n    //get until scale 20\n    textValue = value.toFixed(20);\n  }\n  return BigDecimal.fromString(textValue);\n};\n\n/**\n * Returns true if the value of the BigDecimal instance and other are the same\n * @param {BigDecimal} other\n * @returns {Boolean}\n */\nBigDecimal.prototype.equals = function (other) {\n  return ((other instanceof BigDecimal) && this.compare(other) === 0);\n};\n\nBigDecimal.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * @param {BigDecimal} other\n * @returns {boolean}\n */\nBigDecimal.prototype.notEquals = function (other) {\n  return !this.equals(other);\n};\n\n/**\n * Compares this BigDecimal with the given one.\n * @param {BigDecimal} other Integer to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nBigDecimal.prototype.compare = function (other) {\n  var diff = this.subtract(other);\n  if (diff.isNegative()) {\n    return -1;\n  }\n  if (diff.isZero()) {\n    return 0;\n  }\n  return +1;\n};\n\n/**\n * Returns the difference of this and the given BigDecimal.\n * @param {BigDecimal} other The BigDecimal to subtract from this.\n * @return {!BigDecimal} The BigDecimal result.\n */\nBigDecimal.prototype.subtract = function (other) {\n  var first = this;\n  if (first._scale === other._scale) {\n    return new BigDecimal(first._intVal.subtract(other._intVal), first._scale);\n  }\n  var diffScale;\n  var unscaledValue;\n  if (first._scale < other._scale) {\n    //The scale of this is lower\n    diffScale = other._scale - first._scale;\n    //multiple this unScaledValue to compare in the same scale\n    unscaledValue = first._intVal\n      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))\n      .subtract(other._intVal);\n    return new BigDecimal(unscaledValue, other._scale);\n  }\n  //The scale of this is higher\n  diffScale = first._scale - other._scale;\n  //multiple this unScaledValue to compare in the same scale\n  unscaledValue = first._intVal\n    .subtract(\n      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));\n  return new BigDecimal(unscaledValue, first._scale);\n};\n\n/**\n * Returns the sum of this and the given <code>BigDecimal</code>.\n * @param {BigDecimal} other The BigDecimal to sum to this.\n * @return {!BigDecimal} The BigDecimal result.\n */\nBigDecimal.prototype.add = function (other) {\n  var first = this;\n  if (first._scale === other._scale) {\n    return new BigDecimal(first._intVal.add(other._intVal), first._scale);\n  }\n  var diffScale;\n  var unscaledValue;\n  if (first._scale < other._scale) {\n    //The scale of this is lower\n    diffScale = other._scale - first._scale;\n    //multiple this unScaledValue to compare in the same scale\n    unscaledValue = first._intVal\n      .multiply(Integer.fromNumber(Math.pow(10, diffScale)))\n      .add(other._intVal);\n    return new BigDecimal(unscaledValue, other._scale);\n  }\n  //The scale of this is higher\n  diffScale = first._scale - other._scale;\n  //multiple this unScaledValue to compare in the same scale\n  unscaledValue = first._intVal\n    .add(\n      other._intVal.multiply(Integer.fromNumber(Math.pow(10, diffScale))));\n  return new BigDecimal(unscaledValue, first._scale);\n};\n\n/**\n * Returns true if the current instance is greater than the other\n * @param {BigDecimal} other\n * @returns {boolean}\n */\nBigDecimal.prototype.greaterThan = function (other) {\n  return this.compare(other) === 1;\n};\n\n/** @return {boolean} Whether this value is negative. */\nBigDecimal.prototype.isNegative = function () {\n  return this._intVal.isNegative();\n};\n\n/** @return {boolean} Whether this value is zero. */\nBigDecimal.prototype.isZero = function () {\n  return this._intVal.isZero();\n};\n\n/**\n * Returns the string representation of this <code>BigDecimal</code>\n * @returns {string}\n */\nBigDecimal.prototype.toString = function () {\n  var intString = this._intVal.toString();\n  if (this._scale === 0) {\n    return intString;\n  }\n  var signSymbol = '';\n  if (intString.charAt(0) === '-') {\n    signSymbol = '-';\n    intString = intString.substr(1);\n  }\n  var separatorIndex = intString.length - this._scale;\n  if (separatorIndex <= 0) {\n    //add zeros at the beginning, plus an additional zero\n    intString = utils.stringRepeat('0', (-separatorIndex) + 1) + intString;\n    separatorIndex = intString.length - this._scale;\n  }\n  return signSymbol + intString.substr(0, separatorIndex) + '.' + intString.substr(separatorIndex);\n};\n\n/**\n * Returns a Number representation of this <code>BigDecimal</code>.\n * @returns {Number}\n */\nBigDecimal.prototype.toNumber = function () {\n  return parseFloat(this.toString());\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nBigDecimal.prototype.toJSON = function () {\n  return this.toString();\n};\n\n\nmodule.exports = BigDecimal;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/integer.js":"// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/** @module types */\n/**\n * Constructs a two's-complement integer an array containing bits of the\n * integer in 32-bit (signed) pieces, given in little-endian order (i.e.,\n * lowest-order bits in the first piece), and the sign of -1 or 0.\n *\n * See the from* functions below for other convenient ways of constructing\n * Integers.\n *\n * The internal representation of an integer is an array of 32-bit signed\n * pieces, along with a sign (0 or -1) that indicates the contents of all the\n * other 32-bit pieces out to infinity.  We use 32-bit pieces because these are\n * the size of integers on which Javascript performs bit-operations.  For\n * operations like addition and multiplication, we split each number into 16-bit\n * pieces, which can easily be multiplied within Javascript's floating-point\n * representation without overflow or change in sign.\n *\n * @constructor\n * @param {Array.<number>} bits Array containing the bits of the number.\n * @param {number} sign The sign of the number: -1 for negative and 0 positive.\n * @final\n */\nfunction Integer (bits, sign) {\n  /**\n   * @type {!Array.<number>}\n   * @private\n   */\n  this.bits_ = [];\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.sign_ = sign;\n\n  // Copy the 32-bit signed integer values passed in.  We prune out those at the\n  // top that equal the sign since they are redundant.\n  var top = true;\n  for (var i = bits.length - 1; i >= 0; i--) {\n    var val = bits[i] | 0;\n    if (!top || val != sign) {\n      this.bits_[i] = val;\n      top = false;\n    }\n  }\n}\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Integer representations of small integer values.\n * @type {!Object}\n * @private\n */\nInteger.IntCache_ = {};\n\n\n/**\n * Returns an Integer representing the given (32-bit) integer value.\n * @param {number} value A 32-bit integer value.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Integer.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Integer([value | 0], value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Integer.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Returns an Integer representing the given value, provided that it is a finite\n * number.  Otherwise, zero is returned.\n * @param {number} value The value in question.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromNumber = function(value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return Integer.ZERO;\n  } else if (value < 0) {\n    return Integer.fromNumber(-value).negate();\n  } else {\n    var bits = [];\n    var pow = 1;\n    for (var i = 0; value >= pow; i++) {\n      bits[i] = (value / pow) | 0;\n      pow *= Integer.TWO_PWR_32_DBL_;\n    }\n    return new Integer(bits, 0);\n  }\n};\n\n\n/**\n * Returns a Integer representing the value that comes by concatenating the\n * given entries, each is assumed to be 32 signed bits, given in little-endian\n * order (lowest order bits in the lowest index), and sign-extending the highest\n * order 32-bit value.\n * @param {Array.<number>} bits The bits of the number, in 32-bit signed pieces,\n *     in little-endian order.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromBits = function(bits) {\n  var high = bits[bits.length - 1];\n  //noinspection JSBitwiseOperatorUsage\n  return new Integer(bits, high & (1 << 31) ? -1 : 0);\n};\n\n\n/**\n * Returns an Integer representation of the given string, written using the\n * given radix.\n * @param {string} str The textual representation of the Integer.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Integer} The corresponding Integer value.\n */\nInteger.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw TypeError('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Integer.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw TypeError('number format error: interior \"-\" character');\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 8));\n\n  var result = Integer.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Integer.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Integer.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Integer.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n/**\n * Returns an Integer representation of a given big endian Buffer.\n * The internal representation of bits contains bytes in groups of 4\n * @param {Buffer} buf\n * @returns {Integer}\n */\nInteger.fromBuffer = function (buf) {\n  var bits = new Array(Math.ceil(buf.length / 4));\n  //noinspection JSBitwiseOperatorUsage\n  var sign = buf[0] & (1 << 7) ? -1 : 0;\n  for (var i = 0; i < bits.length; i++) {\n    var offset = buf.length - ((i + 1) * 4);\n    var value;\n    if (offset < 0) {\n      //The buffer length is not multiple of 4\n      offset = offset + 4;\n      value = 0;\n      for (var j = 0; j < offset; j++) {\n        var byte = buf[j];\n        if (sign === -1) {\n          //invert the bits\n          byte = ~byte & 0xff;\n        }\n        value = value | (byte << (offset - j - 1) * 8);\n      }\n      if (sign === -1) {\n        //invert all the bits\n        value = ~value;\n      }\n    }\n    else {\n      value = buf.readInt32BE(offset);\n    }\n    bits[i] = value;\n  }\n  return new Integer(bits, sign);\n};\n\n/**\n * Returns a big endian buffer representation of an Integer.\n * Internally the bits are represented using 4 bytes groups (numbers),\n * in the Buffer representation there might be the case where we need less than the 4 bytes.\n * For example: 0x00000001 -> '01', 0xFFFFFFFF -> 'FF', 0xFFFFFF01 -> 'FF01'\n * @param {Integer} value\n * @returns {Buffer}\n*/\nInteger.toBuffer = function (value) {\n  var sign = value.sign_;\n  var bits = value.bits_;\n  if (bits.length === 0) {\n    //[0] or [0xffffffff]\n    return new Buffer([value.sign_]);\n  }\n  //the high bits might need to be represented in less than 4 bytes\n  var highBits = bits[bits.length-1];\n  if (sign === -1) {\n    highBits = ~highBits;\n  }\n  var high = [];\n  if (highBits >>> 24 > 0) {\n    high.push((highBits >> 24) & 0xff);\n  }\n  if (highBits >>> 16 > 0) {\n    high.push((highBits >> 16) & 0xff);\n  }\n  if (highBits >>> 8 > 0) {\n    high.push((highBits >> 8) & 0xff);\n  }\n  high.push(highBits & 0xff);\n  if (sign === -1) {\n    //The byte containing the sign bit got removed\n    if (high[0] >> 7 !== 0) {\n      //it is going to be negated\n      high.unshift(0);\n    }\n  }\n  else if (high[0] >> 7 !== 0) {\n    //its positive but it lost the byte containing the sign bit\n    high.unshift(0);\n  }\n  var buf = new Buffer(high.length + ((bits.length-1) * 4));\n  for (var j = 0; j < high.length; j++) {\n    var b = high[j];\n    if (sign === -1) {\n      buf[j] = ~b;\n    }\n    else {\n      buf[j] = b;\n    }\n  }\n  for (var i = 0; i < bits.length - 1; i++) {\n    var group = bits[bits.length - 2 - i];\n    var offset = high.length + i * 4;\n    buf.writeInt32BE(group, offset);\n  }\n  return buf;\n};\n\n\n/**\n * A number used repeatedly in calculations.  This must appear before the first\n * call to the from* functions below.\n * @type {number}\n * @private\n */\nInteger.TWO_PWR_32_DBL_ = (1 << 16) * (1 << 16);\n\n\n/** @type {!Integer} */\nInteger.ZERO = Integer.fromInt(0);\n\n\n/** @type {!Integer} */\nInteger.ONE = Integer.fromInt(1);\n\n\n/**\n * @type {!Integer}\n * @private\n */\nInteger.TWO_PWR_24_ = Integer.fromInt(1 << 24);\n\n\n/**\n * Returns the value, assuming it is a 32-bit integer.\n * @return {number} The corresponding int value.\n */\nInteger.prototype.toInt = function() {\n  return this.bits_.length > 0 ? this.bits_[0] : this.sign_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nInteger.prototype.toNumber = function() {\n  if (this.isNegative()) {\n    return -this.negate().toNumber();\n  } else {\n    var val = 0;\n    var pow = 1;\n    for (var i = 0; i < this.bits_.length; i++) {\n      val += this.getBitsUnsigned(i) * pow;\n      pow *= Integer.TWO_PWR_32_DBL_;\n    }\n    return val;\n  }\n};\n\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nInteger.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  } else if (this.isNegative()) {\n    return '-' + this.negate().toString(radix);\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Integer.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.divide(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/**\n * Returns the index-th 32-bit (signed) piece of the Integer according to\n * little-endian order (i.e., index 0 contains the smallest bits).\n * @param {number} index The index in question.\n * @return {number} The requested 32-bits as a signed number.\n */\nInteger.prototype.getBits = function(index) {\n  if (index < 0) {\n    return 0;  // Allowing this simplifies bit shifting operations below...\n  } else if (index < this.bits_.length) {\n    return this.bits_[index];\n  } else {\n    return this.sign_;\n  }\n};\n\n\n/**\n * Returns the index-th 32-bit piece as an unsigned number.\n * @param {number} index The index in question.\n * @return {number} The requested 32-bits as an unsigned number.\n */\nInteger.prototype.getBitsUnsigned = function(index) {\n  var val = this.getBits(index);\n  return val >= 0 ? val : Integer.TWO_PWR_32_DBL_ + val;\n};\n\n\n/** @return {number} The sign bit of this number, -1 or 0. */\nInteger.prototype.getSign = function() {\n  return this.sign_;\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nInteger.prototype.isZero = function() {\n  if (this.sign_ != 0) {\n    return false;\n  }\n  for (var i = 0; i < this.bits_.length; i++) {\n    if (this.bits_[i] != 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nInteger.prototype.isNegative = function() {\n  return this.sign_ == -1;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nInteger.prototype.isOdd = function() {\n  return (this.bits_.length == 0) && (this.sign_ == -1) ||\n    (this.bits_.length > 0) && ((this.bits_[0] & 1) != 0);\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer equals the other.\n */\nInteger.prototype.equals = function(other) {\n  if (this.sign_ != other.sign_) {\n    return false;\n  }\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  for (var i = 0; i < len; i++) {\n    if (this.getBits(i) != other.getBits(i)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer does not equal the other.\n */\nInteger.prototype.notEquals = function(other) {\n  return !this.equals(other);\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is greater than the other.\n */\nInteger.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is greater than or equal to the other.\n */\nInteger.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is less than the other.\n */\nInteger.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Integer} other Integer to compare against.\n * @return {boolean} Whether this Integer is less than or equal to the other.\n */\nInteger.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * Compares this Integer with the given one.\n * @param {Integer} other Integer to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nInteger.prototype.compare = function(other) {\n  var diff = this.subtract(other);\n  if (diff.isNegative()) {\n    return -1;\n  } else if (diff.isZero()) {\n    return 0;\n  } else {\n    return +1;\n  }\n};\n\n\n/**\n * Returns an integer with only the first numBits bits of this value, sign\n * extended from the final bit.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} The shorted integer value.\n */\nInteger.prototype.shorten = function(numBits) {\n  var arr_index = (numBits - 1) >> 5;\n  var bit_index = (numBits - 1) % 32;\n  var bits = [];\n  for (var i = 0; i < arr_index; i++) {\n    bits[i] = this.getBits(i);\n  }\n  var sigBits = bit_index == 31 ? 0xFFFFFFFF : (1 << (bit_index + 1)) - 1;\n  var val = this.getBits(arr_index) & sigBits;\n  //noinspection JSBitwiseOperatorUsage\n  if (val & (1 << bit_index)) {\n    val |= 0xFFFFFFFF - sigBits;\n    bits[arr_index] = val;\n    return new Integer(bits, -1);\n  } else {\n    bits[arr_index] = val;\n    return new Integer(bits, 0);\n  }\n};\n\n\n/** @return {!Integer} The negation of this value. */\nInteger.prototype.negate = function() {\n  return this.not().add(Integer.ONE);\n};\n\n\n/**\n * Returns the sum of this and the given Integer.\n * @param {Integer} other The Integer to add to this.\n * @return {!Integer} The Integer result.\n */\nInteger.prototype.add = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  var carry = 0;\n\n  for (var i = 0; i <= len; i++) {\n    var a1 = this.getBits(i) >>> 16;\n    var a0 = this.getBits(i) & 0xFFFF;\n\n    var b1 = other.getBits(i) >>> 16;\n    var b0 = other.getBits(i) & 0xFFFF;\n\n    var c0 = carry + a0 + b0;\n    var c1 = (c0 >>> 16) + a1 + b1;\n    carry = c1 >>> 16;\n    c0 &= 0xFFFF;\n    c1 &= 0xFFFF;\n    arr[i] = (c1 << 16) | c0;\n  }\n  return Integer.fromBits(arr);\n};\n\n\n/**\n * Returns the difference of this and the given Integer.\n * @param {Integer} other The Integer to subtract from this.\n * @return {!Integer} The Integer result.\n */\nInteger.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given Integer.\n * @param {Integer} other The Integer to multiply against this.\n * @return {!Integer} The product of this and the other.\n */\nInteger.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Integer.ZERO;\n  } else if (other.isZero()) {\n    return Integer.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both numbers are small, use float multiplication\n  if (this.lessThan(Integer.TWO_PWR_24_) &&\n    other.lessThan(Integer.TWO_PWR_24_)) {\n    return Integer.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Fill in an array of 16-bit products.\n  var len = this.bits_.length + other.bits_.length;\n  var arr = [];\n  for (var i = 0; i < 2 * len; i++) {\n    arr[i] = 0;\n  }\n  for (var i = 0; i < this.bits_.length; i++) {\n    for (var j = 0; j < other.bits_.length; j++) {\n      var a1 = this.getBits(i) >>> 16;\n      var a0 = this.getBits(i) & 0xFFFF;\n\n      var b1 = other.getBits(j) >>> 16;\n      var b0 = other.getBits(j) & 0xFFFF;\n\n      arr[2 * i + 2 * j] += a0 * b0;\n      Integer.carry16_(arr, 2 * i + 2 * j);\n      arr[2 * i + 2 * j + 1] += a1 * b0;\n      Integer.carry16_(arr, 2 * i + 2 * j + 1);\n      arr[2 * i + 2 * j + 1] += a0 * b1;\n      Integer.carry16_(arr, 2 * i + 2 * j + 1);\n      arr[2 * i + 2 * j + 2] += a1 * b1;\n      Integer.carry16_(arr, 2 * i + 2 * j + 2);\n    }\n  }\n\n  // Combine the 16-bit values into 32-bit values.\n  for (var i = 0; i < len; i++) {\n    arr[i] = (arr[2 * i + 1] << 16) | arr[2 * i];\n  }\n  for (var i = len; i < 2 * len; i++) {\n    arr[i] = 0;\n  }\n  return new Integer(arr, 0);\n};\n\n\n/**\n * Carries any overflow from the given index into later entries.\n * @param {Array.<number>} bits Array of 16-bit values in little-endian order.\n * @param {number} index The index in question.\n * @private\n */\nInteger.carry16_ = function(bits, index) {\n  while ((bits[index] & 0xFFFF) != bits[index]) {\n    bits[index + 1] += bits[index] >>> 16;\n    bits[index] &= 0xFFFF;\n  }\n};\n\n\n/**\n * Returns this Integer divided by the given one.\n * @param {Integer} other Th Integer to divide this by.\n * @return {!Integer} This value divided by the given one.\n */\nInteger.prototype.divide = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Integer.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().divide(other.negate());\n    } else {\n      return this.negate().divide(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.divide(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Integer.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Integer.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Integer.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Integer.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Integer modulo the given one.\n * @param {Integer} other The Integer by which to mod.\n * @return {!Integer} This value modulo the given one.\n */\nInteger.prototype.modulo = function(other) {\n  return this.subtract(this.divide(other).multiply(other));\n};\n\n\n/** @return {!Integer} The bitwise-NOT of this value. */\nInteger.prototype.not = function() {\n  var len = this.bits_.length;\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = ~this.bits_[i];\n  }\n  return new Integer(arr, ~this.sign_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Integer and the given one.\n * @param {Integer} other The Integer to AND with this.\n * @return {!Integer} The bitwise-AND of this and the other.\n */\nInteger.prototype.and = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) & other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ & other.sign_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Integer and the given one.\n * @param {Integer} other The Integer to OR with this.\n * @return {!Integer} The bitwise-OR of this and the other.\n */\nInteger.prototype.or = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) | other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ | other.sign_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Integer and the given one.\n * @param {Integer} other The Integer to XOR with this.\n * @return {!Integer} The bitwise-XOR of this and the other.\n */\nInteger.prototype.xor = function(other) {\n  var len = Math.max(this.bits_.length, other.bits_.length);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    arr[i] = this.getBits(i) ^ other.getBits(i);\n  }\n  return new Integer(arr, this.sign_ ^ other.sign_);\n};\n\n\n/**\n * Returns this value with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} This shifted to the left by the given amount.\n */\nInteger.prototype.shiftLeft = function(numBits) {\n  var arr_delta = numBits >> 5;\n  var bit_delta = numBits % 32;\n  var len = this.bits_.length + arr_delta + (bit_delta > 0 ? 1 : 0);\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    if (bit_delta > 0) {\n      arr[i] = (this.getBits(i - arr_delta) << bit_delta) |\n      (this.getBits(i - arr_delta - 1) >>> (32 - bit_delta));\n    } else {\n      arr[i] = this.getBits(i - arr_delta);\n    }\n  }\n  return new Integer(arr, this.sign_);\n};\n\n\n/**\n * Returns this value with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Integer} This shifted to the right by the given amount.\n */\nInteger.prototype.shiftRight = function(numBits) {\n  var arr_delta = numBits >> 5;\n  var bit_delta = numBits % 32;\n  var len = this.bits_.length - arr_delta;\n  var arr = [];\n  for (var i = 0; i < len; i++) {\n    if (bit_delta > 0) {\n      arr[i] = (this.getBits(i + arr_delta) >>> bit_delta) |\n      (this.getBits(i + arr_delta + 1) << (32 - bit_delta));\n    } else {\n      arr[i] = this.getBits(i + arr_delta);\n    }\n  }\n  return new Integer(arr, this.sign_);\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nInteger.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns a Integer whose value is the absolute value of this\n * @returns {Integer}\n */\nInteger.prototype.abs = function () {\n  return this.sign_ === 0 ? this : this.negate();\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nInteger.prototype.toJSON = function () {\n  return this.toString();\n};\n\nmodule.exports = Integer;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/inet-address.js":"\"use strict\";\n\n/** @module types */\n/**\n * Creates a new instance of InetAddress\n * @class\n * @classdesc Represents an v4 or v6 Internet Protocol (IP) address.\n * @param {Buffer} buffer\n * @constructor\n */\nfunction InetAddress(buffer) {\n  if (!(buffer instanceof Buffer) || (buffer.length !== 4 && buffer.length !== 16)) {\n    throw new TypeError('The ip address must contain 4 or 16 bytes');\n  }\n  this.buffer = buffer;\n  /**\n   * Returns the length of the underlying buffer\n   * @name length\n   * @type Number\n   * @memberof module:types~InetAddress#\n   */\n  Object.defineProperty(this, 'length', {get: function () { return buffer.length; }, enumerable: true});\n  /**\n   * Returns the Ip version (4 or 6)\n   * @name version\n   * @type Number\n   * @memberof module:types~InetAddress#\n   */\n  Object.defineProperty(this, 'version', {get: function () { return buffer.length === 4 ? 4 : 6; }, enumerable: true});\n}\n\n/**\n * Parses the string representation and returns an Ip address\n * @param {String} value\n */\nInetAddress.fromString = function (value) {\n  if (!value) {\n    return new InetAddress(new Buffer([0, 0, 0, 0]));\n  }\n  var ipv4Pattern = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  var ipv6Pattern = /^[\\da-f:.]+$/i;\n  var parts;\n  if (ipv4Pattern.test(value)) {\n    parts = value.split('.');\n    return new InetAddress(new Buffer(parts));\n  }\n  if (!ipv6Pattern.test(value)) {\n    throw new TypeError('Value could not be parsed as InetAddress: ' + value);\n  }\n  parts = value.split(':');\n  if (parts.length < 3) {\n    throw new TypeError('Value could not be parsed as InetAddress: ' + value);\n  }\n  var buffer = new Buffer(16);\n  var filling = 8 - parts.length + 1;\n  var applied = false;\n  var offset = 0;\n  var embeddedIp4 = ipv4Pattern.test(parts[parts.length - 1]);\n  if (embeddedIp4) {\n    // Its IPv6 address with an embedded IPv4 address:\n    // subtract 1 from the potential empty filling as ip4 contains 4 bytes instead of 2 of a ipv6 section\n    filling -= 1;\n  }\n  function writeItem(uIntValue) {\n    buffer.writeUInt8(+uIntValue, offset++);\n  }\n  for (var i = 0; i < parts.length; i++) {\n    var item = parts[i];\n    if (item) {\n      if (embeddedIp4 && i === parts.length - 1) {\n        item.split('.').forEach(writeItem);\n        break;\n      }\n      buffer.writeUInt16BE(parseInt(item, 16), offset);\n      offset = offset + 2;\n      continue;\n    }\n    //its an empty string\n    if (applied) {\n      //there could be 2 occurrences of empty string\n      filling = 1;\n    }\n    applied = true;\n    for (var j = 0; j < filling; j++) {\n      buffer[offset++] = 0;\n      buffer[offset++] = 0;\n    }\n  }\n  if (embeddedIp4 && !isValidIPv4Mapped(buffer)) {\n    throw new TypeError('Only IPv4-Mapped IPv6 addresses are allowed as IPv6 address with embedded IPv4 address');\n  }\n  return new InetAddress(buffer);\n};\n\n/**\n * Compares 2 addresses and returns true if the underlying bytes are the same\n * @param {InetAddress} other\n * @returns {Boolean}\n */\nInetAddress.prototype.equals = function (other) {\n  if (!(other instanceof InetAddress)) {\n    return false;\n  }\n  return (this.buffer.length === other.buffer.length &&\n    this.buffer.toString('hex') === other.buffer.toString('hex'));\n};\n\n/**\n * Returns the underlying buffer\n * @returns {Buffer}\n */\nInetAddress.prototype.getBuffer = function () {\n  return this.buffer;\n};\n\n/**\n * Provide the name of the constructor and the string representation\n * @returns {string}\n */\nInetAddress.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns the string representation of the IP address.\n * <p>For v4 IP addresses, a string in the form of d.d.d.d is returned.</p>\n * <p>\n *   For v6 IP addresses, a string in the form of x:x:x:x:x:x:x:x is returned, where the 'x's are the hexadecimal\n *   values of the eight 16-bit pieces of the address, according to rfc5952.\n *   In cases where there is more than one field of only zeros, it can be shortened. For example, 2001:0db8:0:0:0:1:0:1\n *   will be expressed as 2001:0db8::1:0:1.\n * </p>\n * @param {String} [encoding]\n * @returns {String}\n */\nInetAddress.prototype.toString = function (encoding) {\n  if (encoding === 'hex') {\n    //backward compatibility: behave in the same way as the buffer\n    return this.buffer.toString('hex');\n  }\n  if (this.buffer.length === 4) {\n    return (\n      this.buffer[0] + '.' +\n      this.buffer[1] + '.' +\n      this.buffer[2] + '.' +\n      this.buffer[3]\n    );\n  }\n  var start = -1;\n  var longest = { length: 0, start: -1};\n  function checkLongest (i) {\n    if (start >= 0) {\n      //close the group\n      var length = i - start;\n      if (length > longest.length) {\n        longest.length = length;\n        longest.start = start;\n        start = -1;\n      }\n    }\n  }\n  //get the longest 16-bit group of zeros\n  for (var i = 0; i < this.buffer.length; i = i + 2) {\n    if (this.buffer[i] === 0 && this.buffer[i + 1] === 0) {\n      //its a group of zeros\n      if (start < 0) {\n        start = i;\n      }\n\n      // at the end of the buffer, make a final call to checkLongest.\n      if(i === this.buffer.length - 2) {\n        checkLongest(i+2);\n      }\n      continue;\n    }\n    //its a group of non-zeros\n    checkLongest(i);\n  }\n\n  var address = '';\n  for (var h = 0; h < this.buffer.length; h = h + 2) {\n    if (h === longest.start) {\n      address += ':';\n      continue;\n    }\n    if (h < (longest.start + longest.length) && h > longest.start) {\n      //its a group of zeros\n      continue;\n    }\n    if (address.length > 0) {\n      address += ':';\n    }\n    address += ((this.buffer[h] << 8) | this.buffer[h+1]).toString(16);\n  }\n  if (address.charAt(address.length-1) === ':') {\n    address += ':';\n  }\n  return address;\n};\n\n/**\n * Returns the string representation.\n * Method used by the native JSON.stringify() to serialize this instance.\n */\nInetAddress.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * Validates for a IPv4-Mapped IPv6 according to https://tools.ietf.org/html/rfc4291#section-2.5.5\n * @private\n * @param {Buffer} buffer\n */\nfunction isValidIPv4Mapped(buffer) {\n  // check the form\n  // |      80 bits   | 16 |   32 bits\n  // +----------------+----+-------------\n  // |0000........0000|FFFF| IPv4 address\n\n  for (var i = 0; i < buffer.length - 6; i++) {\n    if (buffer[i] !== 0) {\n      return false;\n    }\n  }\n  return !(buffer[10] !== 255 || buffer[11] !== 255);\n}\n\nmodule.exports = InetAddress;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/local-date.js":"\"use strict\";\nvar util = require('util');\n\nvar utils = require('../utils');\n/** @module types */\n\n/**\n * @private\n * @const\n */\nvar millisecondsPerDay = 86400000;\n/**\n * @private\n */\nvar dateCenter = Math.pow(2,31);\n/**\n *\n * Creates a new instance of LocalDate.\n * @class\n * @classdesc A date without a time-zone in the ISO-8601 calendar system, such as 2010-08-05.\n * <p>\n *   LocalDate is an immutable object that represents a date, often viewed as year-month-day. For example, the value \"1st October 2014\" can be stored in a LocalDate.\n * </p>\n * <p>\n *   This class does not store or represent a time or time-zone. Instead, it is a description of the date, as used for birthdays. It cannot represent an instant on the time-line without additional information such as an offset or time-zone.\n * </p>\n * <p>\n *   Note that this type can represent dates in the range [-5877641-06-23; 5881580-07-17] while the ES5 date type can only represent values in the range of [-271821-04-20; 275760-09-13].\n *   In the event that year, month, day parameters do not fall within the ES5 date range an Error will be thrown.  If you wish to represent a date outside of this range, pass a single\n *   parameter indicating the days since epoch.  For example, -1 represents 1969-12-31.\n * </p>\n * @param {Number} year The year or days since epoch.  If days since epoch, month and day should not be provided.\n * @param {Number} month Between 1 and 12 inclusive.\n * @param {Number} day Between 1 and the number of days in the given month of the given year.\n *\n * @property {Date} date The date representation if falls within a range of an ES5 data type, otherwise an invalid date.\n *\n * @constructor\n */\nfunction LocalDate(year, month, day) {\n  //implementation detail: internally uses a UTC based date\n  if (typeof year === 'number' && typeof month === 'number' && typeof day === 'number') {\n    //Use setUTCFullYear as if there is a 2 digit year, Date.UTC() assumes\n    //that is the 20th century.  Thanks ECMAScript!\n    //noinspection JSValidateTypes\n    this.date = new Date();\n    this.date.setUTCHours(0, 0, 0, 0);\n    this.date.setUTCFullYear(year, month-1, day);\n    if(isNaN(this.date.getTime())) {\n      throw new Error(util.format('%d-%d-%d does not form a valid ES5 date!',\n        year, month, day));\n    }\n  }\n  else if (typeof month === 'undefined' && typeof day === 'undefined') {\n    if (typeof year === 'number') {\n      //in days since epoch.\n      if(year < -2147483648 || year > 2147483647) {\n        throw new Error('You must provide a valid value for days since epoch (-2147483648 <= value <= 2147483647).');\n      }\n      //noinspection JSValidateTypes\n      this.date = new Date(year * millisecondsPerDay);\n    }\n  }\n\n  if (typeof this.date === 'undefined') {\n    throw new Error('You must provide a valid year, month and day');\n  }\n\n  //If date cannot be represented yet given a valid days since epoch, track\n  //it internally.\n  var value = isNaN(this.date.getTime()) ? year : null;\n  Object.defineProperty(this, '_value', { enumerable: false, value: value });\n\n  var self = this;\n\n  /**\n   * A number representing the year.  May return NaN if cannot be represented as\n   * a Date.\n   * @name year\n   * @type Number\n   * @memberof module:types~LocalDate#\n   */\n  /**\n   * A number between 1 and 12 inclusive representing the month.  May return\n   * NaN if cannot be represented as a Date.\n   * @name month\n   * @type Number\n   * @memberof module:types~LocalDate#\n   */\n  /**\n   * A number between 1 and the number of days in the given month of the given year (28, 29, 30, 31).\n   * May return NaN if cannot be represented as a Date.\n   * @name day\n   * @type Number\n   * @memberof module:types~LocalDate#\n   */\n  Object.defineProperties(this, {\n    'year': { enumerable: true, get: function () {\n      return self.date.getUTCFullYear();\n    }},\n    'month': { enumerable: true, get: function () {\n      return self.date.getUTCMonth() + 1;\n    }},\n    'day': { enumerable: true, get: function () {\n      return self.date.getUTCDate();\n    }}\n  });\n}\n\n/**\n * Creates a new instance of LocalDate using the current year, month and day from the system clock in the default time-zone.\n */\nLocalDate.now = function () {\n  //noinspection JSCheckFunctionSignatures\n  return LocalDate.fromDate(new Date());\n};\n\n/**\n * Creates a new instance of LocalDate using the current date from the system clock at UTC.\n */\nLocalDate.utcNow = function () {\n  //noinspection JSCheckFunctionSignatures\n  return new LocalDate(Date.now());\n};\n\n\n/**\n * Creates a new instance of LocalDate using the year, month and day from the provided local date time.\n * @param {Date} date\n */\nLocalDate.fromDate = function (date) {\n  if (isNaN(date.getTime())) {\n    throw new TypeError('Invalid date: ' + date);\n  }\n  return new LocalDate(date.getFullYear(), date.getMonth() + 1, date.getDate());\n};\n\n/**\n * Creates a new instance of LocalDate using the year, month and day provided in the form: yyyy-mm-dd or\n * days since epoch (i.e. -1 for Dec 31, 1969).\n * @param {String} value\n */\nLocalDate.fromString = function (value) {\n  var dashCount = (value.match(/-/g) || []).length;\n  if(dashCount >= 2) {\n    var multiplier = 1;\n    if (value[0] === '-') {\n      value = value.substring(1);\n      multiplier = -1;\n    }\n    var parts = value.split('-');\n    return new LocalDate(multiplier * parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));\n  }\n  if(value.match(/^-?\\d+$/)) {\n    // Parse as days since epoch.\n    return new LocalDate(parseInt(value, 10));\n  }\n  throw new Error(\"Invalid input '\" + value + \"'.\");\n};\n\n/**\n * Creates a new instance of LocalDate using the bytes representation.\n * @param {Buffer} buffer\n */\nLocalDate.fromBuffer = function (buffer) {\n  //move to unix epoch: 0.\n  //noinspection JSCheckFunctionSignatures\n  return new LocalDate((buffer.readUInt32BE(0) - dateCenter));\n};\n\n/**\n * Compares this LocalDate with the given one.\n * @param {LocalDate} other date to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n * if the given one is greater.\n */\nLocalDate.prototype.compare = function (other) {\n  var thisValue = isNaN(this.date.getTime()) ? this._value * millisecondsPerDay : this.date.getTime();\n  var otherValue = isNaN(other.date.getTime()) ? other._value * millisecondsPerDay : other.date.getTime();\n  var diff = thisValue - otherValue;\n  if (diff < 0) {\n    return -1;\n  }\n  if (diff > 0) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Returns true if the value of the LocalDate instance and other are the same\n * @param {LocalDate} other\n * @returns {Boolean}\n */\nLocalDate.prototype.equals = function (other) {\n  return ((other instanceof LocalDate)) && this.compare(other) === 0;\n};\n\nLocalDate.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Gets the bytes representation of the instance.\n * @returns {Buffer}\n */\nLocalDate.prototype.toBuffer = function () {\n  //days since unix epoch\n  var daysSinceEpoch = isNaN(this.date.getTime()) ? this._value : Math.floor(this.date.getTime() / millisecondsPerDay);\n  var value = daysSinceEpoch + dateCenter;\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(value, 0);\n  return buf;\n};\n\n/**\n * Gets the string representation of the instance in the form: yyyy-mm-dd if\n * the value can be parsed as a Date, otherwise days since epoch.\n * @returns {String}\n */\nLocalDate.prototype.toString = function () {\n  var result;\n  //if cannot be parsed as date, return days since epoch representation.\n  if (isNaN(this.date.getTime())) {\n    return this._value.toString();\n  }\n  var year = this.date.getUTCFullYear();\n  var month = this.date.getUTCMonth() + 1;\n  var day = this.date.getUTCDate();\n  if (year < 0) {\n    result = '-' + fillZeros((year * -1).toString(), 4);\n  }\n  else {\n    result = fillZeros(year.toString(), 4);\n  }\n  result += '-' + fillZeros(month.toString(), 2) + '-' + fillZeros(day.toString(), 2);\n  return result;\n};\n\n/**\n * Gets the string representation of the instance in the form: yyyy-mm-dd, valid for JSON.\n * @returns {String}\n */\nLocalDate.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * @param {String} value\n * @param {Number} amount\n * @private\n */\nfunction fillZeros(value, amount) {\n  if (value.length >= amount) {\n    return value;\n  }\n  return utils.stringRepeat('0', amount - value.length) + value;\n}\n\nmodule.exports = LocalDate;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/local-time.js":"\"use strict\";\nvar Long = require('long');\nvar util = require('util');\nvar utils = require('../utils');\n/** @module types */\n\n/**\n * @const\n * @private\n * */\nvar maxNanos = Long.fromString('86399999999999');\n/**\n * Nanoseconds in a second\n * @const\n * @private\n * */\nvar nanoSecInSec = Long.fromNumber(1000000000);\n/**\n * Nanoseconds in a millisecond\n * @const\n * @private\n * */\nvar nanoSecInMillis = Long.fromNumber(1000000);\n/**\n * Milliseconds in day\n * @const\n * @private\n * */\nvar millisInDay = 86400000;\n/**\n *\n * Creates a new instance of LocalTime.\n * @class\n * @classdesc A time without a time-zone in the ISO-8601 calendar system, such as 10:30:05.\n * <p>\n *   LocalTime is an immutable date-time object that represents a time, often viewed as hour-minute-second. Time is represented to nanosecond precision. For example, the value \"13:45.30.123456789\" can be stored in a LocalTime.\n * </p>\n * @param {Long} totalNanoseconds Total nanoseconds since midnight.\n * @constructor\n */\nfunction LocalTime(totalNanoseconds) {\n  if (!(totalNanoseconds instanceof Long)) {\n    throw new Error('You must specify a Long value as totalNanoseconds');\n  }\n  if (totalNanoseconds.lessThan(Long.ZERO) || totalNanoseconds.greaterThan(maxNanos)) {\n    throw new Error('Total nanoseconds out of range');\n  }\n  this.value = totalNanoseconds;\n  var self = this;\n  /**\n   * Gets the hour component of the time represented by the current instance, a number from 0 to 23.\n   * @name hour\n   * @type Number\n   * @memberof module:types~LocalTime#\n   */\n  /**\n   * Gets the minute component of the time represented by the current instance, a number from 0 to 59.\n   * @name minute\n   * @type Number\n   * @memberof module:types~LocalTime#\n   */\n  /**\n   * Gets the second component of the time represented by the current instance, a number from 0 to 59.\n   * @name day\n   * @type Number\n   * @memberof module:types~LocalTime#\n   */\n  /**\n   * Gets the nanoseconds component of the time represented by the current instance, a number from 0 to 999999999.\n   * @name nanosecond\n   * @type Number\n   * @memberof module:types~LocalTime#\n   */\n  Object.defineProperties(this, {\n    'hour': { enumerable: true, get: function () {\n      return self._getParts()[0];\n    }},\n    'minute': { enumerable: true, get: function () {\n      return self._getParts()[1];\n    }},\n    'second': { enumerable: true, get: function () {\n      return self._getParts()[2];\n    }},\n    'nanosecond': { enumerable: true, get: function () {\n      return self._getParts()[3];\n    }}\n  });\n}\n\n/**\n * Parses an string representation and returns a new LocalDate.\n * @param {String} value\n * @returns {LocalTime}\n */\nLocalTime.fromString = function (value) {\n  if (typeof value !== 'string') {\n    throw new Error('Argument type invalid: ' + util.inspect(value));\n  }\n  var parts = value.split(':');\n  var millis = parseInt(parts[0], 10) * 3600000 + parseInt(parts[1], 10) * 60000;\n  var nanos;\n  if (parts.length === 3) {\n    var secParts = parts[2].split('.');\n    millis += parseInt(secParts[0], 10) * 1000;\n    if (secParts.length === 2) {\n      nanos = secParts[1];\n      //add zeros at the end\n      nanos = nanos + utils.stringRepeat('0', 9 - nanos.length);\n    }\n  }\n  return LocalTime.fromMilliseconds(millis, parseInt(nanos, 10) || 0);\n};\n\n/**\n * Uses the current local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.\n * @returns {LocalTime}\n */\nLocalTime.now = function (nanoseconds) {\n  return LocalTime.fromDate(new Date(), nanoseconds);\n};\n\n/**\n * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Date} date Local date portion to extract the time passed since midnight.\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the nanosecond time portion.\n * @returns {LocalTime}\n */\nLocalTime.fromDate = function (date, nanoseconds) {\n  if (!util.isDate(date)) {\n    throw new Error('Not a valid date');\n  }\n  //Use the local representation\n  var millis = date.getTime() + date.getTimezoneOffset() * -60000;\n  //Only the milliseconds part\n  millis = millis % millisInDay;\n  return LocalTime.fromMilliseconds(millis, nanoseconds);\n};\n\n/**\n * Uses the provided local time (in milliseconds) and the nanoseconds to create a new instance of LocalTime\n * @param {Number} milliseconds A Number from 0 to 86,399,999.\n * @param {Number} [nanoseconds] A Number from 0 to 999,999, representing the time nanosecond portion.\n * @returns {LocalTime}\n */\nLocalTime.fromMilliseconds = function (milliseconds, nanoseconds) {\n  if (typeof nanoseconds !== 'number') {\n    nanoseconds = 0;\n  }\n  return new LocalTime(Long\n    .fromNumber(milliseconds)\n    .multiply(nanoSecInMillis)\n    .add(Long.fromNumber(nanoseconds)));\n};\n\n/**\n * Creates a new instance of LocalTime from the bytes representation.\n * @param {Buffer} value\n * @returns {LocalTime}\n */\nLocalTime.fromBuffer = function (value) {\n  if (!(value instanceof Buffer)) {\n    throw new TypeError('Expected Buffer, obtained ' + util.inspect(value));\n  }\n  return new LocalTime(new Long(value.readInt32BE(4), value.readInt32BE(0)));\n};\n\n/**\n * Compares this LocalTime with the given one.\n * @param {LocalTime} other time to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n * if the given one is greater.\n */\nLocalTime.prototype.compare = function (other) {\n  return this.value.compare(other.value);\n};\n\n/**\n * Returns true if the value of the LocalTime instance and other are the same\n * @param {LocalTime} other\n * @returns {Boolean}\n */\nLocalTime.prototype.equals = function (other) {\n  return ((other instanceof LocalTime)) && this.compare(other) === 0;\n};\n\n/**\n * Gets the total amount of nanoseconds since midnight for this instance.\n * @returns {Long}\n */\nLocalTime.prototype.getTotalNanoseconds = function () {\n  return this.value;\n};\n\nLocalTime.prototype.inspect = function () {\n  return this.constructor.name + ': ' + this.toString();\n};\n\n/**\n * Returns a big-endian bytes representation of the instance\n * @returns {Buffer}\n */\nLocalTime.prototype.toBuffer = function () {\n  var buffer = new Buffer(8);\n  buffer.writeUInt32BE(this.value.getHighBitsUnsigned(), 0);\n  buffer.writeUInt32BE(this.value.getLowBitsUnsigned(), 4);\n  return buffer;\n};\n\n/**\n * Returns the string representation of the instance in the form of hh:MM:ss.ns\n * @returns {String}\n */\nLocalTime.prototype.toString = function () {\n  return formatTime(this._getParts());\n};\n\n/**\n * Gets the string representation of the instance in the form: hh:MM:ss.ns\n * @returns {String}\n */\nLocalTime.prototype.toJSON = function () {\n  return this.toString();\n};\n\n/**\n * @returns {Array.<Number>}\n * @ignore\n */\nLocalTime.prototype._getParts = function () {\n  if (!this._partsCache) {\n    //hours, minutes, seconds and nanos\n    var parts = [0, 0, 0, 0];\n    var secs = this.value.div(nanoSecInSec);\n    //faster modulo\n    //total nanos\n    parts[3] = this.value.subtract(secs.multiply(nanoSecInSec)).toNumber();\n    //seconds\n    parts[2] = secs.toNumber();\n    if (parts[2] >= 60) {\n      //minutes\n      parts[1] = Math.floor(parts[2] / 60);\n      parts[2] = parts[2] % 60;\n    }\n    if (parts[1] >= 60) {\n      //hours\n      parts[0] = Math.floor(parts[1] / 60);\n      parts[1] = parts[1] % 60;\n    }\n    this._partsCache = parts;\n  }\n  return this._partsCache;\n};\n\n/**\n * @param {Array.<Number>} values\n * @private\n */\nfunction formatTime(values) {\n  var result;\n  if (values[0] < 10) {\n    result = '0' + values[0] + ':';\n  }\n  else {\n    result = values[0] + ':';\n  }\n  if (values[1] < 10) {\n    result += '0' + values[1] + ':';\n  }\n  else {\n    result += values[1] + ':';\n  }\n  if (values[2] < 10) {\n    result += '0' + values[2];\n  }\n  else {\n    result += values[2];\n  }\n  if (values[3] > 0) {\n    var nanos = values[3].toString();\n    //nine digits\n    if (nanos.length < 9) {\n      nanos = utils.stringRepeat('0', 9 - nanos.length) + nanos;\n    }\n    var lastPosition;\n    for (var i = nanos.length - 1; i > 0; i--) {\n      if (nanos[i] !== '0') {\n        break;\n      }\n      lastPosition = i;\n    }\n    if (lastPosition) {\n      nanos = nanos.substring(0, lastPosition);\n    }\n    result += '.' + nanos;\n  }\n  return result;\n}\n\nmodule.exports = LocalTime;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/result-set.js":"\"use strict\";\nvar utils = require('../utils');\n\n/** @module types */\n\n/**\n * Creates a new instance of ResultSet.\n * @class\n * @classdesc Represents the result of a query.\n * @param {Object} response\n * @param {String} host\n * @param {Object} triedHosts\n * @param {Number} consistency\n * @constructor\n */\nfunction ResultSet(response, host, triedHosts, consistency) {\n  /**\n   * Information on the execution of a successful query:\n   * @member {Object}\n   * @property {Number} achievedConsistency The consistency level that has been actually achieved by the query.\n   * @property {String} queriedHost The Cassandra host that coordinated this query.\n   * @property {Object} triedHosts Gets the associative array of host that were queried before getting a valid response,\n   * being the last host the one that replied correctly.\n   * @property {Uuid} traceId Identifier of the trace session.\n   * @property {Array.<string>} warnings Warning messages generated by the server when executing the query.\n   */\n  this.info = {\n    queriedHost: host,\n    triedHosts: triedHosts,\n    achievedConsistency: consistency,\n    traceId: null,\n    warnings: null,\n    customPayload: null\n  };\n  if (response.flags) {\n    this.info.traceId = response.flags.traceId;\n    this.info.warnings = response.flags.warnings;\n    this.info.customPayload = response.flags.customPayload;\n  }\n  /**\n   * Gets an array rows returned by the query, in case the result was buffered.\n   * @type {Array.<Row>}\n   */\n  this.rows = response.rows;\n  /**\n   * Gets the row length of the result, regardless if the result has been buffered or not\n   * @type {Number}\n   */\n  this.rowLength = this.rows ? this.rows.length : response.rowLength;\n  /**\n   * Gets the columns returned in this ResultSet.\n   * @type {Array.<{name, type}>}\n   * @default null\n   */\n  this.columns = null;\n  /**\n   * A string token representing the current page state of query. It can be used in the following executions to\n   * continue paging and retrieve the remained of the result for the query.\n   * @type String\n   * @default null\n   */\n  this.pageState = null;\n  /**\n   * Method used to manually fetch the next page of results.\n   * This method is only exposed when using the {@link Client#eachRow} method and there are more rows available in\n   * following pages.\n   * @type Function\n   */\n  this.nextPage = undefined;\n\n  var meta = response.meta;\n  if (meta) {\n    this.columns = meta.columns;\n    if (meta.pageState) {\n      this.pageState = meta.pageState.toString('hex');\n    }\n  }\n  if (response.id) {\n    // internal properties for prepared responses\n    Object.defineProperty(this, 'id', { value: response.id, enumerable: false});\n    Object.defineProperty(this, 'meta', { value: response.meta, enumerable: false});\n  }\n  else if (this.pageState !== null) {\n    // page state was exposed in version 1 via result.meta.pageState as a Buffer.\n    // it was not specified in the upgrade guide to v2, we must wait for a next major to remove it\n    Object.defineProperty(this, 'meta', { value: response.meta, enumerable: false});\n  }\n}\n\n/**\n * Returns the first row or null if the result rows are empty.\n */\nResultSet.prototype.first = function () {\n  if (this.rows && this.rows.length) {\n    return this.rows[0];\n  }\n  return null;\n};\n\nResultSet.prototype.getPageState = function () {\n  // backward-compatibility\n  return this.pageState;\n};\n\nResultSet.prototype.getColumns = function () {\n  // backward-compatibility\n  return this.columns;\n};\n\nif (typeof Symbol !== 'undefined' && typeof Symbol.iterator === 'symbol') {\n  /**\n   * Gets the iterator function.\n   * <p>\n   *   Retrieves the iterator of the underlying fetched rows and will not cause the driver to fetch the following\n   *   result pages. For more information on result paging,\n   *   [visit the documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.\n   * </p>\n   * @alias module:types~ResultSet#@@iterator\n   * @example <caption>Using for...of statement</caption>\n   * const query = 'SELECT name, email, address FROM users WHERE id = ?';\n   * const result = await client.execute(query, [ id ], { prepare: true });\n   * for (let row of result) {\n   *   console.log(row['email']);\n   * }\n   * @returns {Iterator.<Row>}\n   */\n  ResultSet.prototype[Symbol.iterator] = function getIterator() {\n    if (!this.rows) {\n      return utils.emptyArray[Symbol.iterator]();\n    }\n    return this.rows[Symbol.iterator]();\n  };\n}\n\nmodule.exports = ResultSet;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/result-stream.js":"'use strict';\nvar util = require('util');\nvar stream = require('stream');\n\n/** @module types */\n/**\n * Readable stream using to yield data from a result or a field\n * @constructor\n */\nfunction ResultStream(opt) {\n  stream.Readable.call(this, opt);\n  this.buffer = [];\n  this.paused = true;\n}\n\nutil.inherits(ResultStream, stream.Readable);\n\nResultStream.prototype._read = function() {\n  this.paused = false;\n  if (this.buffer.length === 0) {\n    this._readableState.reading = false;\n  }\n  while (!this.paused && this.buffer.length > 0) {\n    this.paused = !this.push(this.buffer.shift());\n  }\n  if ( !this.paused && !this.buffer.length && this._readNext ) {\n    this._readNext();\n    this._readNext = null;\n  }\n};\n\n/**\n * Allows for throttling, helping nodejs keep the internal buffers reasonably sized.\n * @param {function} readNext function that triggers reading the next result chunk\n */\nResultStream.prototype._valve = function( readNext ) {\n  this._readNext = null;\n  if ( !readNext ) {\n    return;\n  }\n  if ( this.paused || this.buffer.length ) {\n    this._readNext = readNext;\n  }\n  else {\n    readNext();\n  }\n};\n\nResultStream.prototype.add = function (chunk) {\n  this.buffer.push(chunk);\n  this.read(0);\n};\n\nmodule.exports = ResultStream;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/row.js":"\"use strict\";\n/** @module types */\n/**\n * Represents a result row\n * @param {Array} columns\n * @constructor\n */\nfunction Row(columns) {\n  if (!columns) {\n    throw new Error('Columns not defined');\n  }\n  //Private non-enumerable properties, with double underscore to avoid interfering with column names\n  Object.defineProperty(this, '__columns', { value: columns, enumerable: false, writable: false});\n}\n\n/**\n * Returns the cell value.\n * @param {String|Number} columnName Name or index of the column\n */\nRow.prototype.get = function (columnName) {\n  if (typeof columnName === 'number') {\n    //its an index\n    return this[this.__columns[columnName].name];\n  }\n  return this[columnName];\n};\n\n/**\n * Returns an array of the values of the row\n * @returns {Array}\n */\nRow.prototype.values = function () {\n  var valuesArray = [];\n  this.forEach(function (val) {\n    valuesArray.push(val);\n  });\n  return valuesArray;\n};\n\n/**\n * Returns an array of the column names of the row\n * @returns {Array}\n */\nRow.prototype.keys = function () {\n  var keysArray = [];\n  this.forEach(function (val, key) {\n    keysArray.push(key);\n  });\n  return keysArray;\n};\n\n/**\n * Executes the callback for each field in the row, containing the value as first parameter followed by the columnName\n * @param {Function} callback\n */\nRow.prototype.forEach = function (callback) {\n  for (var columnName in this) {\n    if (!this.hasOwnProperty(columnName)) {\n      continue;\n    }\n    callback(this[columnName], columnName);\n  }\n};\n\nmodule.exports = Row;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/types/tuple.js":"\"use strict\";\nvar util = require('util');\n/** @module types */\n/**\n * Creates a new sequence of immutable objects with the parameters provided.\n * @class\n * @classdesc A tuple is a sequence of immutable objects.\n * Tuples are sequences, just like [Arrays]{@link Array}. The only difference is that tuples can't be changed.\n * <p>\n *   As tuples can be used as a Map keys, the {@link Tuple#toString toString()} method calls toString of each element,\n *   to try to get a unique string key.\n * </p>\n * @param [arguments] The sequence elements as arguments.\n * @constructor\n */\nfunction Tuple() {\n  var elements = Array.prototype.slice.call(arguments);\n  if (elements.length === 0) {\n    throw new TypeError('Tuple must contain at least one value');\n  }\n  if (elements.length === 1 && util.isArray(elements)) {\n    //The first argument is an array of the elements, use a copy of the array\n    elements = elements[0];\n  }\n  Object.defineProperty(this, 'elements', { value: elements, enumerable: false, writable: false });\n  /**\n   * Returns the number of the elements.\n   * @name length\n   * @type Number\n   * @memberof module:types~Tuple#\n   */\n  Object.defineProperty(this, 'length', { value: elements.length, enumerable: false, writable: false });\n}\n\n/**\n * Creates a new instance of a tuple based on the Array\n * @param {Array} elements\n * @returns {Tuple}\n */\nTuple.fromArray = function (elements) {\n  //Use a copy of an array\n  return new Tuple(elements.slice(0));\n};\n\n/**\n * Returns the value located at the index.\n * @param {Number} index Element index\n */\nTuple.prototype.get = function (index) {\n  return this.elements[index || 0];\n};\n\n/**\n * Returns the string representation of the sequence surrounded by parenthesis, ie: (1, 2).\n * <p>\n *   The returned value attempts to be a unique string representation of its values.\n * </p>\n * @returns {string}\n */\nTuple.prototype.toString = function () {\n  return ('(' +\n    this.elements.reduce(function (prev, x, i) {\n      return prev + (i > 0 ? ',' : '') + x.toString();\n    }, '') +\n    ')');\n};\n\n/**\n * Returns the Array representation of the sequence.\n * @returns {Array}\n */\nTuple.prototype.toJSON = function () {\n  return this.elements;\n};\n\n/**\n * Gets the elements as an array\n * @returns {Array}\n */\nTuple.prototype.values = function () {\n  return this.elements.slice(0);\n};\n\nmodule.exports = Tuple;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/reconnection.js":"'use strict';\nvar util = require('util');\n\n/** @module policies/reconnection */\n/**\n * Base class for Reconnection Policies\n * @constructor\n */\nfunction ReconnectionPolicy() {\n\n}\n\n/**\n * A new reconnection schedule.\n * @returns {{next: function}} An infinite iterator\n */\nReconnectionPolicy.prototype.newSchedule = function () {\n  throw new Error('You must implement a new schedule for the Reconnection class');\n};\n\n/**\n * A reconnection policy that waits a constant time between each reconnection attempt.\n * @param {Number} delay Delay in ms\n * @constructor\n */\nfunction ConstantReconnectionPolicy(delay) {\n  this.delay = delay;\n}\n\nutil.inherits(ConstantReconnectionPolicy, ReconnectionPolicy);\n\n/**\n * A new reconnection schedule that returns the same next delay value\n * @returns {{next: next}} An infinite iterator\n */\nConstantReconnectionPolicy.prototype.newSchedule = function () {\n  var self = this;\n  return {\n    next: function () {\n      return {value: self.delay, done: false};\n    }\n  };\n};\n\n/**\n * A reconnection policy that waits exponentially longer between each\n * reconnection attempt (but keeps a constant delay once a maximum delay is reached).\n * @param {Number} baseDelay Delay in ms that\n * @param {Number} maxDelay the maximum delay in ms to wait between two reconnection attempt\n * @param {Boolean} startWithNoDelay Determines if the first attempt should be zero delay\n * @constructor\n */\nfunction ExponentialReconnectionPolicy(baseDelay, maxDelay, startWithNoDelay) {\n  this.baseDelay = baseDelay;\n  this.maxDelay = maxDelay;\n  this.startWithNoDelay = startWithNoDelay;\n}\n\nutil.inherits(ExponentialReconnectionPolicy, ReconnectionPolicy);\n\n/**\n * A new schedule that uses an exponentially growing delay between reconnection attempts.\n * @returns {{next: next}} An infinite iterator\n */\nExponentialReconnectionPolicy.prototype.newSchedule = function () {\n  var self = this;\n  var index = this.startWithNoDelay ? -1 : 0;\n  return {\n    next: function () {\n      index++;\n      var delay = 0;\n      if (index > 64) {\n        delay = self.maxDelay;\n      }\n      else if (index !== 0) {\n        delay = Math.min(Math.pow(2, index) * self.baseDelay, self.maxDelay);\n      }\n      return { value: delay, done: false };\n    }\n  };\n};\n\nexports.ReconnectionPolicy = ReconnectionPolicy;\nexports.ConstantReconnectionPolicy = ConstantReconnectionPolicy;\nexports.ExponentialReconnectionPolicy = ExponentialReconnectionPolicy;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/retry.js":"\"use strict\";\nvar util = require('util');\n\nvar errors = require('../errors');\n\n/** @module policies/retry */\n/**\n * Base and default RetryPolicy.\n * Determines what to do when the drivers runs into an specific Cassandra exception\n * @constructor\n */\nfunction RetryPolicy() {\n\n}\n\n//noinspection JSUnusedLocalSymbols\n/**\n * Determines what to do when the driver gets an UnavailableException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} required The number of replicas whose response is required to achieve the\n * required [consistency]{@link module:types~consistencies}.\n * @param {Number} alive The number of replicas that were known to be alive when the request had been processed\n * (since an unavailable exception has been triggered, there will be alive &lt; required)\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  return this.retryResult(undefined, false);\n};\n\n/**\n * Determines what to do when the driver gets a ReadTimeoutException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} received The number of nodes having answered the request.\n * @param {Number} blockFor The number of replicas whose response is required to achieve the\n * required [consistency]{@link module:types~consistencies}.\n * @param {Boolean} isDataPresent When <code>false</code>, it means the replica that was asked for data has not responded.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  return ((received >= blockFor && !isDataPresent) ?\n    this.retryResult() :\n    this.rethrowResult());\n};\n\n/**\n * Determines what to do when the driver gets a WriteTimeoutException response from a Cassandra node.\n * @param {OperationInfo} info\n * @param {Number} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Number} received The number of nodes having acknowledged the request.\n * @param {Number} blockFor The number of replicas whose acknowledgement is required to achieve the required\n * [consistency]{@link module:types~consistencies}.\n * @param {String} writeType A <code>string</code> that describes the type of the write that timed out (\"SIMPLE\"\n * / \"BATCH\" / \"BATCH_LOG\" / \"UNLOGGED_BATCH\" / \"COUNTER\").\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {\n  if (info.nbRetry > 0) {\n    return this.rethrowResult();\n  }\n  // If the batch log write failed, retry the operation as this might just be we were unlucky at picking candidates\n  return writeType === \"BATCH_LOG\" ? this.retryResult() : this.rethrowResult();\n};\n\n/**\n * Defines whether to retry and at which consistency level on an unexpected error.\n * <p>\n * This method might be invoked in the following situations:\n * </p>\n * <ol>\n * <li>On a client timeout, while waiting for the server response\n * (see [socketOptions.readTimeout]{@link ClientOptions}), being the error an instance of\n * [OperationTimedOutError]{@link module:errors~OperationTimedOutError}.</li>\n * <li>On a connection error (socket closed, etc.).</li>\n * <li>When the contacted host replies with an error, such as <code>overloaded</code>, <code>isBootstrapping</code>,\n * </code>serverError, etc. In this case, the error is instance of [ResponseError]{@link module:errors~ResponseError}.\n * </li>\n * </ol>\n * <p>\n * Note that when this method is invoked, <em>the driver cannot guarantee that the mutation has been effectively\n * applied server-side</em>; a retry should only be attempted if the request is known to be idempotent.\n * </p>\n * @param {OperationInfo} info\n * @param {Number|undefined} consistency The [consistency]{@link module:types~consistencies} level of the query that triggered\n * the exception.\n * @param {Error} err The error that caused this request to fail.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.onRequestError = function (info, consistency, err) {\n  if (err instanceof errors.OperationTimedOutError && !info.options.retryOnTimeout) {\n    return this.rethrowResult();\n  }\n  // The default implementation triggers a retry on the next host in the query plan with the same consistency level,\n  // regardless of the statement's idempotence, for historical reasons.\n  return this.retryResult(undefined, false);\n};\n\n/**\n * Returns a {@link DecisionInfo} to retry the request with the given [consistency]{@link module:types~consistencies}.\n * @param {Number|undefined} [consistency] When specified, it retries the request with the given consistency.\n * @param {Boolean} [useCurrentHost] When specified, determines if the retry should be made using the same coordinator.\n * Default: true.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.retryResult = function (consistency, useCurrentHost) {\n  return {\n    decision: RetryPolicy.retryDecision.retry,\n    consistency: consistency,\n    useCurrentHost: useCurrentHost !== false\n  };\n};\n\n/**\n * Returns a {@link DecisionInfo} to callback in error when a err is obtained for a given request.\n * @returns {DecisionInfo}\n */\nRetryPolicy.prototype.rethrowResult = function () {\n  return { decision: RetryPolicy.retryDecision.rethrow };\n};\n\n/**\n * Determines the retry decision for the retry policies.\n * @type {Object}\n * @property {Number} rethrow\n * @property {Number} retry\n * @property {Number} ignore\n * @static\n */\nRetryPolicy.retryDecision = {\n  rethrow:  0,\n  retry:    1,\n  ignore:   2\n};\n\n/**\n * Creates a new instance of <code>IdempotenceAwareRetryPolicy</code>.\n * @classdesc\n * A retry policy that avoids retrying non-idempotent statements.\n * <p>\n * In case of write timeouts or unexpected errors, this policy will always return\n * [rethrowResult()]{@link module:policies/retry~RetryPolicy#rethrowResult} if the statement is deemed non-idempotent\n * (see [QueryOptions.isIdempotent]{@link QueryOptions}).\n * <p/>\n * For all other cases, this policy delegates the decision to the child policy.\n * @param {RetryPolicy} [childPolicy] The child retry policy to wrap. When not defined, it will use an instance of\n * [RetryPolicy]{@link module:policies/retry~RetryPolicy} as child policy.\n * @extends module:policies/retry~RetryPolicy\n * @constructor\n */\nfunction IdempotenceAwareRetryPolicy(childPolicy) {\n  this._childPolicy = childPolicy || new RetryPolicy();\n}\n\nutil.inherits(IdempotenceAwareRetryPolicy, RetryPolicy);\n\nIdempotenceAwareRetryPolicy.prototype.onReadTimeout = function (info, consistency, received, blockFor, isDataPresent) {\n  return this._childPolicy.onReadTimeout(info, consistency, received, blockFor, isDataPresent);\n};\n\n/**\n * If the query is not idempotent, it returns a rethrow decision. Otherwise, it relies on the child policy to decide.\n */\nIdempotenceAwareRetryPolicy.prototype.onRequestError = function (info, consistency, err) {\n  if (info.options.isIdempotent) {\n    return this._childPolicy.onRequestError(info, consistency, err);\n  }\n  return this.rethrowResult();\n};\n\nIdempotenceAwareRetryPolicy.prototype.onUnavailable = function (info, consistency, required, alive) {\n  return this._childPolicy.onUnavailable(info, consistency, required, alive);\n};\n\n/**\n * If the query is not idempotent, it return a rethrow decision. Otherwise, it relies on the child policy to decide.\n */\nIdempotenceAwareRetryPolicy.prototype.onWriteTimeout = function (info, consistency, received, blockFor, writeType) {\n  if (info.options.isIdempotent) {\n    return this._childPolicy.onWriteTimeout(info, consistency, received, blockFor, writeType);\n  }\n  return this.rethrowResult();\n};\n\n/**\n * Decision information\n * @typedef {Object} DecisionInfo\n * @property {Number} decision The decision as specified in\n * [retryDecision]{@link module:policies/retry~RetryPolicy.retryDecision}.\n * @property {Number} [consistency] The [consistency level]{@link module:types~consistencies}.\n * @property {useCurrentHost} [useCurrentHost] Determines if it should use the same host to retry the request.\n */\n\n/**\n * Request information.\n * @typedef {Object} OperationInfo\n * @property {String} query The query that was executed.\n * @property {QueryOptions} options The options for the query that was executed.\n * @property {Number} nbRetry The number of retries already performed for this operation.\n * @property {Object} handler DEPRECATED: it will be removed in the next major version. The request handler.\n * @property {Object} request DEPRECATED: it will be removed in the next major version. Represents the request that\n * was executed.\n * @property {Boolean} retryOnTimeout. DEPRECATED: it will be removed in the next major version. The value as\n * specified in the {@link QueryOptions} for this operation. Use <code>OperationInfo.options</code> value instead.\n */\n\nexports.RetryPolicy = RetryPolicy;\nexports.IdempotenceAwareRetryPolicy = IdempotenceAwareRetryPolicy;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/policies/timestamp-generation.js":"'use strict';\n\nvar util = require('util');\nvar Long = require('../types').Long;\nvar errors = require('../errors');\n\n/** @module policies/timestampGeneration */\n\n/**\n * Defines the maximum date in milliseconds that can be represented in microseconds using Number ((2 ^ 53) / 1000)\n * @const\n * @private\n */\nvar _maxSafeNumberDate = 9007199254740;\n\n/**\n * A long representing the value 1000\n * @const\n * @private\n */\nvar _longOneThousand = Long.fromInt(1000);\n\n/**\n * Creates a new instance of {@link TimestampGenerator}.\n * @classdesc\n * Generates client-side, microsecond-precision query timestamps.\n * <p>\n *   Given that Cassandra uses those timestamps to resolve conflicts, implementations should generate\n *   monotonically increasing timestamps for successive invocations of {@link TimestampGenerator.next()}.\n * </p>\n * @constructor\n */\nfunction TimestampGenerator() {\n\n}\n\n/**\n * Returns the next timestamp.\n * <p>\n *   Implementors should enforce increasing monotonicity of timestamps, that is,\n *   a timestamp returned should always be strictly greater that any previously returned\n *   timestamp.\n * <p/>\n * <p>\n *   Implementors should strive to achieve microsecond precision in the best possible way,\n *   which is usually largely dependent on the underlying operating system's capabilities.\n * </p>\n * @param {Client} client The {@link Client} instance to generate timestamps to.\n * @returns {Long|Number|null} the next timestamp (in microseconds). If it's equals to <code>null</code>, it won't be\n * sent by the driver, letting the server to generate the timestamp.\n * @abstract\n */\nTimestampGenerator.prototype.next = function (client) {\n  throw new Error('next() must be implemented');\n};\n\n/**\n * A timestamp generator that guarantees monotonically increasing timestamps and logs warnings when timestamps\n * drift in the future.\n * <p>\n *   {@link Date} has millisecond precision and client timestamps require microsecond precision. This generator\n *   keeps track of the last generated timestamp, and if the current time is within the same millisecond as the last,\n *   it fills the microsecond portion of the new timestamp with the value of an incrementing counter.\n * </p>\n * @param {Number} [warningThreshold] Determines how far in the future timestamps are allowed to drift before a\n * warning is logged, expressed in milliseconds. Default: <code>1000</code>.\n * @param {Number} [minLogInterval] In case of multiple log events, it determines the time separation between log\n * events, expressed in milliseconds. Use 0 to disable. Default: <code>1000</code>.\n * @extends {TimestampGenerator}\n * @constructor\n */\nfunction MonotonicTimestampGenerator(warningThreshold, minLogInterval) {\n  if (warningThreshold < 0) {\n    throw new errors.ArgumentError('warningThreshold can not be lower than 0');\n  }\n  this._warningThreshold = warningThreshold || 1000;\n  this._minLogInterval = 1000;\n  if (typeof minLogInterval === 'number') {\n    // A value under 1 will disable logging\n    this._minLogInterval = minLogInterval;\n  }\n  this._micros = -1;\n  this._lastDate = 0;\n  this._lastLogDate = 0;\n}\n\nutil.inherits(MonotonicTimestampGenerator, TimestampGenerator);\n\n/**\n * Returns the current time in milliseconds since UNIX epoch\n * @returns {Number}\n */\nMonotonicTimestampGenerator.prototype.getDate = function () {\n  return Date.now();\n};\n\nMonotonicTimestampGenerator.prototype.next = function (client) {\n  var date = this.getDate();\n  var drifted = 0;\n  if (date > this._lastDate) {\n    this._micros = 0;\n    this._lastDate = date;\n    return this._generateMicroseconds();\n  }\n\n  if (date < this._lastDate) {\n    drifted = this._lastDate - date;\n    date = this._lastDate;\n  }\n  if (++this._micros === 1000) {\n    this._micros = 0;\n    if (date === this._lastDate) {\n      // Move date 1 millisecond into the future\n      date++;\n      drifted++;\n    }\n  }\n  var lastDate = this._lastDate;\n  this._lastDate = date;\n  var result = this._generateMicroseconds();\n  if (drifted >= this._warningThreshold) {\n    // Avoid logging an unbounded amount of times within a clock-skew event or during an interval when more than 1\n    // query is being issued by microsecond\n    var currentLogDate = Date.now();\n    if (this._minLogInterval > 0 && this._lastLogDate + this._minLogInterval <= currentLogDate){\n      var message = util.format(\n        'Timestamp generated using current date was %d milliseconds behind the last generated timestamp (which ' +\n        'millisecond portion was %d), the returned value (%s) is being artificially incremented to guarantee ' +\n        'monotonicity.',\n        drifted, lastDate, result);\n      this._lastLogDate = currentLogDate;\n      client.log('warning', message);\n    }\n  }\n  return result;\n};\n\n/**\n * @private\n * @returns {Number|Long}\n */\nMonotonicTimestampGenerator.prototype._generateMicroseconds = function () {\n  if (this._lastDate < _maxSafeNumberDate) {\n    // We are safe until Jun 06 2255, its faster to perform this operations on Number than on Long\n    // We hope to have native int64 by then :)\n    return this._lastDate * 1000 + this._micros;\n  }\n  return Long\n    .fromNumber(this._lastDate)\n    .multiply(_longOneThousand)\n    .add(Long.fromInt(this._micros));\n};\n\nexports.TimestampGenerator = TimestampGenerator;\nexports.MonotonicTimestampGenerator = MonotonicTimestampGenerator;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/client.js":"\"use strict\";\nvar events = require('events');\nvar util = require('util');\n\nvar utils = require('./utils.js');\nvar errors = require('./errors.js');\nvar types = require('./types');\nvar ControlConnection = require('./control-connection');\nvar ProfileManager = require('./execution-profile').ProfileManager;\nvar RequestHandler = require('./request-handler');\nvar requests = require('./requests');\nvar clientOptions = require('./client-options');\n/**\n * Max amount of pools being warmup in parallel, when warmup is enabled\n * @const {Number}\n * @private\n */\nvar warmupLimit = 32;\n\n/**\n * Client options\n * @typedef {Object} ClientOptions\n * @property {Array.<string>} contactPoints\n * Array of addresses or host names of the nodes to add as contact points.\n * <p>\n *  Contact points are addresses of Cassandra nodes that the driver uses to discover the cluster topology.\n * </p>\n * <p>\n *  Only one contact point is required (the driver will retrieve the address of the other nodes automatically),\n *  but it is usually a good idea to provide more than one contact point, because if that single contact point is\n *  unavailable, the driver will not be able to initialize correctly.\n * </p>\n * @property {String} keyspace The logged keyspace for all the connections created within the {@link Client} instance.\n * @property {Number} refreshSchemaDelay The default window size in milliseconds used to debounce node list and schema\n * refresh metadata requests. Default: 1000.\n * @property {Boolean} isMetadataSyncEnabled Determines whether client-side schema metadata retrieval and update is\n * enabled.\n * <p>Setting this value to <code>false</code> will cause keyspace information not to be automatically loaded, affecting\n * replica calculation per token in the different keyspaces. When disabling metadata synchronization, use\n * [Metadata.refreshKeyspaces()]{@link module:metadata~Metadata#refreshKeyspaces} to keep keyspace information up to\n * date or token-awareness will not work correctly.</p>\n * Default: <code>true</code>.\n * @property {Object} policies\n * @property {LoadBalancingPolicy} policies.loadBalancing The load balancing policy instance to be used to determine\n * the coordinator per query.\n * @property {RetryPolicy} policies.retry The retry policy.\n * @property {ReconnectionPolicy} policies.reconnection The reconnection policy to be used.\n * @property {AddressTranslator} policies.addressResolution The address resolution policy.\n * @property {TimestampGenerator} policies.timestampGeneration The client-side\n * [query timestamp generator]{@link module:policies/timestampGeneration~TimestampGenerator}.\n * <p>\n *   Default: <code>[MonotonicTimestampGenerator]{@link module:policies/timestampGeneration~MonotonicTimestampGenerator}\n *   </code>\n * </p>\n * <p>Use <code>null</code> to disable client-side timestamp generation.</p>\n * @property {QueryOptions} queryOptions Default options for all queries.\n * @property {Object} pooling Pooling options.\n * @property {Number} pooling.heartBeatInterval The amount of idle time in milliseconds that has to pass before the\n * driver issues a request on an active connection to avoid idle time disconnections. Default: 30000.\n * @property {Object} pooling.coreConnectionsPerHost Associative array containing amount of connections per host\n * distance.\n * @property {Boolean} pooling.warmup Determines if all connections to hosts in the local datacenter must be opened on\n * connect. Default: false.\n * @property {Object} protocolOptions\n * @property {Number} protocolOptions.port The port to use to connect to the Cassandra host. If not set through this\n * method, the default port (9042) will be used instead.\n * @property {Number} protocolOptions.maxSchemaAgreementWaitSeconds The maximum time in seconds to wait for schema\n * agreement between nodes before returning from a DDL query. Default: 10.\n * @property {Number} protocolOptions.maxVersion When set, it limits the maximum protocol version used to connect to\n * the nodes.\n * Useful for using the driver against a cluster that contains nodes with different major/minor versions of Cassandra.\n * @property {Object} socketOptions\n * @property {Number} socketOptions.connectTimeout Connection timeout in milliseconds. Default: 5000.\n * @property {Number} socketOptions.defunctReadTimeoutThreshold Determines the amount of requests that simultaneously\n * have to timeout before closing the connection. Default: 64.\n * @property {Boolean} socketOptions.keepAlive Whether to enable TCP keep-alive on the socket. Default: true.\n * @property {Number} socketOptions.keepAliveDelay TCP keep-alive delay in milliseconds. Default: 0.\n * @property {Number} socketOptions.readTimeout Per-host read timeout in milliseconds.\n * <p>\n *   Please note that this is not the maximum time a call to {@link Client#execute} may have to wait;\n *   this is the maximum time that call will wait for one particular Cassandra host, but other hosts will be tried if\n *   one of them timeout. In other words, a {@link Client#execute} call may theoretically wait up to\n *   <code>readTimeout * number_of_cassandra_hosts</code> (though the total number of hosts tried for a given query also\n *   depends on the LoadBalancingPolicy in use).\n * <p>When setting this value, keep in mind the following:</p>\n * <ul>\n *   <li>the timeout settings used on the Cassandra side (*_request_timeout_in_ms in cassandra.yaml) should be taken\n *   into account when picking a value for this read timeout. You should pick a value a couple of seconds greater than\n *   the Cassandra timeout settings.\n *   </li>\n *   <li>\n *     the read timeout is only approximate and only control the timeout to one Cassandra host, not the full query.\n *   </li>\n * </ul>\n * Setting a value of 0 disables read timeouts. Default: 0.\n * @property {Boolean} socketOptions.tcpNoDelay When set to true, it disables the Nagle algorithm. Default: true.\n * @property {Number} socketOptions.coalescingThreshold Buffer length in bytes use by the write queue before flushing\n * the frames. Default: 8000.\n * @property {AuthProvider} authProvider Provider to be used to authenticate to an auth-enabled cluster.\n * @property {Object} sslOptions Client-to-node ssl options, when set the driver will use the secure layer.\n * You can specify cert, ca, ... options named after the Node.js tls.connect options.\n * @property {Object} encoding\n * @property {Function} encoding.map Map constructor to use for Cassandra map<k,v> type encoding and decoding.\n * If not set, it will default to Javascript Object with map keys as property names.\n * @property {Function} encoding.set Set constructor to use for Cassandra set<k> type encoding and decoding.\n * If not set, it will default to Javascript Array.\n * @property {Boolean} encoding.copyBuffer Determines if the network buffer should be copied for buffer based data\n * types (blob, uuid, timeuuid and inet).\n * <p>\n *   Setting it to true will cause that the network buffer is copied for each row value of those types,\n *   causing additional allocations but freeing the network buffer to be reused.\n *   Setting it to true is a good choice for cases where the Row and ResultSet returned by the queries are long-lived\n *   objects.\n * </p>\n * <p>\n *  Setting it to false will cause less overhead and the reference of the network buffer to be maintained until the row\n *  / result set are de-referenced.\n *  Default: true.\n * </p>\n * @property {Boolean} encoding.useUndefinedAsUnset Valid for Cassandra 2.2 and above. Determines that, if a parameter\n * is set to\n * <code>undefined</code> it should be encoded as <code>unset</code>.\n * <p>\n *  By default, ECMAScript <code>undefined</code> is encoded as <code>null</code> in the driver. Cassandra 2.2\n *  introduced the concept of unset.\n *  At driver level, you can set a parameter to unset using the field <code>types.unset</code>. Setting this flag to\n *  true allows you to use ECMAScript undefined as Cassandra <code>unset</code>.\n * </p>\n * <p>\n *   Default: true.\n * </p>\n * @property {Array.<ExecutionProfile>} profiles The array of [execution profiles]{@link ExecutionProfile}.\n * @property {Function} promiseFactory Function to be used to create a <code>Promise</code> from a\n * callback-style function.\n * <p>\n *   Promise libraries often provide different methods to create a promise. For example, you can use Bluebird's\n *   <code>Promise.fromCallback()</code> method.\n * </p>\n * <p>\n *   By default, the driver will use the\n *   [Promise constructor]{@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise}.\n * </p>\n */\n\n/**\n * Query options\n * @typedef {Object} QueryOptions\n * @property {Boolean} [autoPage] Determines if the driver must retrieve the following result pages automatically.\n * <p>\n *   This setting is only considered by the [Client#eachRow()]{@link Client#eachRow} method. For more information,\n *   check the\n *   [paging results documentation]{@link http://docs.datastax.com/en/developer/nodejs-driver/latest/features/paging/}.\n * </p>\n * @property {Boolean} [captureStackTrace] Determines if the stack trace before the query execution should be\n * maintained.\n * <p>\n *   Useful for debugging purposes, it should be set to <code>false</code> under production environment as it adds an\n *   unnecessary overhead to each execution.\n * </p>\n * Default: false.\n * @property {Number} [consistency] [Consistency level]{@link module:types~consistencies}. Default: localOne.\n * @property {Object} [customPayload] Key-value payload to be passed to the server. On the Cassandra side, \n * implementations of QueryHandler can use this data.\n * @property {String|ExecutionProfile} [executionProfile] Name or instance of the [profile]{@link ExecutionProfile} to\n * be used for this execution. If not set, it will the use \"default\" execution profile.\n * @property {Number} [fetchSize] Amount of rows to retrieve per page.\n * @property {Array|Array<Array>} [hints] Type hints for parameters given in the query, ordered as for the parameters.\n * <p>For batch queries, an array of such arrays, ordered as with the queries in the batch.</p>\n * @property {Boolean} [isIdempotent] Defines whether the query can be applied multiple times without changing the result\n * beyond the initial application.\n * <p>\n *   The query execution idempotence can be used at [RetryPolicy]{@link module:policies/retry~RetryPolicy} level to\n *   determine if an statement can be retried in case of request error or write timeout.\n * </p>\n * <p>Default: <code>false</code>.</p>\n * @property {Boolean} [logged] Determines if the batch should be written to the batchlog. Only valid for\n * [Client#batch()]{@link Client#batch}, it will be ignored by other methods. Default: true.\n * @property {Buffer|String} [pageState] Buffer or string token representing the paging state.\n * <p>Useful for manual paging, if provided, the query will be executed starting from a given paging state.</p>\n * @property {Boolean} [prepare] Determines if the query must be executed as a prepared statement.\n * @property {Number} [readTimeout] When defined, it overrides the default read timeout\n * (<code>socketOptions.readTimeout</code>) in milliseconds for this execution per coordinator.\n * <p>\n *   Suitable for statements for which the coordinator may allow a longer server-side timeout, for example aggregation\n *   queries.\n * </p>\n * <p>\n *   A value of <code>0</code> disables client side read timeout for the execution. Default: <code>undefined</code>.\n * </p>\n * @property {RetryPolicy} [retry] Retry policy for the query.\n * <p>\n *   This property can be used to specify a different [retry policy]{@link module:policies/retry} to the one specified\n *   in the {@link ClientOptions}.policies.\n * </p>\n * @property {Boolean} [retryOnTimeout] Determines if the client should retry when it didn't hear back from a host\n * within <code>socketOptions.readTimeout</code>. Default: true.\n * @property {Array} [routingIndexes] Index of the parameters that are part of the partition key to determine\n * the routing.\n * @property {Buffer|Array} [routingKey] Partition key(s) to determine which coordinator should be used for the query.\n * @property {Array} [routingNames] Array of the parameters names that are part of the partition key to determine the\n * routing.\n * @property {Number} [serialConsistency] Serial consistency is the consistency level for the serial phase of\n * conditional updates.\n * This option will be ignored for anything else that a conditional update/insert.\n * @property {Number|Long} [timestamp] The default timestamp for the query in microseconds from the unix epoch\n * (00:00:00, January 1st, 1970).\n * <p>If provided, this will replace the server side assigned timestamp as default timestamp.</p>\n * <p>Use [generateTimestamp()]{@link module:types~generateTimestamp} utility method to generate a valid timestamp\n * based on a Date and microseconds parts.</p>\n * @property {Boolean} [traceQuery] Enable query tracing for the execution. Use query tracing to diagnose performance\n * problems related to query executions. Default: false.\n * <p>To retrieve trace, you can call [Metadata.getTrace()]{@link module:metadata~Metadata#getTrace} method.</p>\n */\n\n/**\n * Creates a new instance of {@link Client}.\n * @classdesc\n * A Client holds connections to a Cassandra cluster, allowing it to be queried.\n * Each Client instance maintains multiple connections to the cluster nodes,\n * provides [policies]{@link module:policies} to choose which node to use for each query,\n * and handles [retries]{@link module:policies/retry} for failed query (when it makes sense), etc...\n * <p>\n * Client instances are designed to be long-lived and usually a single instance is enough\n * per application. As a given Client can only be \"logged\" into one keyspace at\n * a time (where the \"logged\" keyspace is the one used by query if the query doesn't\n * explicitly use a fully qualified table name), it can make sense to create one\n * client per keyspace used. This is however not necessary to query multiple keyspaces\n * since it is always possible to use a single session with fully qualified table name\n * in queries.\n * </p>\n * @extends EventEmitter\n * @param {ClientOptions} options The options for this instance.\n * @example <caption>Creating a new client instance</caption>\n * const client = new Client({ contactPoints: ['192.168.1.100'] });\n * client.connect(function (err) {\n *   if (err) return console.error(err);\n *   console.log('Connected to cluster with %d host(s): %j', client.hosts.length, client.hosts.keys());\n * });\n * @example <caption>Executing a query</caption>\n * // calling #execute() can be made without previously calling #connect(), as internally\n * // it will ensure it's connected before attempting to execute the query\n * client.execute('SELECT key FROM system.local', function (err, result) {\n *   if (err) return console.error(err);\n *   const row = result.first();\n *   console.log(row['key']);\n * });\n * @example <caption>Executing a query with promise-based API</caption>\n * const result = await client.execute('SELECT key FROM system.local');\n * const row = result.first();\n * console.log(row['key']);\n * @constructor\n */\nfunction Client(options) {\n  events.EventEmitter.call(this);\n  this.options = clientOptions.extend({ logEmitter: this.emit.bind(this) }, options);\n  Object.defineProperty(this, 'profileManager', { value: new ProfileManager(this.options) });\n  Object.defineProperty(this, 'controlConnection', {\n    value: new ControlConnection(this.options, this.profileManager), writable: true }\n  );\n  //Unlimited amount of listeners for internal event queues by default\n  this.setMaxListeners(0);\n  this.connected = false;\n  this.isShuttingDown = false;\n  /**\n   * Gets the name of the active keyspace.\n   * @type {String}\n   */\n  this.keyspace = options.keyspace;\n  /**\n   * Gets the schema and cluster metadata information.\n   * @type {Metadata}\n   */\n  this.metadata = this.controlConnection.metadata;\n  /**\n   * Gets an associative array of cluster hosts.\n   * @type {HostMap}\n   */\n  this.hosts = null;\n}\n\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Emitted when a new host is added to the cluster.\n * <ul>\n *   <li>{@link Host} The host being added.</li>\n * </ul>\n * @event Client#hostAdd\n */\n/**\n * Emitted when a host is removed from the cluster\n * <ul>\n *   <li>{@link Host} The host being removed.</li>\n * </ul>\n * @event Client#hostRemove\n */\n/**\n * Emitted when a host in the cluster changed status from down to up.\n * <ul>\n *   <li>{@link Host host} The host that changed the status.</li>\n * </ul>\n * @event Client#hostUp\n */\n/**\n * Emitted when a host in the cluster changed status from up to down.\n * <ul>\n *   <li>{@link Host host} The host that changed the status.</li>\n * </ul>\n * @event Client#hostDown\n */\n\n/**\n * Tries to connect to one of the [contactPoints]{@link ClientOptions} and discovers the rest the nodes of the cluster.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the client is connected. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * <p>\n *   If the {@link Client} is already connected, it invokes callback immediately (when provided) or the promise is\n *   fulfilled .\n * </p>\n * @example <caption>Callback-based execution</caption>\n * client.connect(function (err) {\n *   if (err) return console.error(err);\n *   console.log('Connected to cluster with %d host(s): %j', client.hosts.length, client.hosts.keys());\n * });\n * @example <caption>Promise-based execution</caption>\n * await client.connect();\n * @param {function} [callback] The callback is invoked when the pool is connected it failed to connect.\n */\nClient.prototype.connect = function (callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, this._connectCb);\n};\n\n/**\n * @param {Function} callback\n * @private\n */\nClient.prototype._connectCb = function (callback) {\n  if (this.connected) {\n    return callback();\n  }\n  if (this.isShuttingDown) {\n    //it is being shutdown, don't allow further calls to connect()\n    return callback(new errors.NoHostAvailableError(null, 'Connecting after shutdown is not supported'));\n  }\n  this.once('connected', callback);\n  if (this.connecting) {\n    //the listener to connect was added, move on\n    return;\n  }\n  this.connecting = true;\n  var self = this;\n  utils.series([\n    function initControlConnection(next) {\n      self.controlConnection.init(next);\n    },\n    function initLoadBalancingPolicy(next) {\n      self.hosts = self.controlConnection.hosts;\n      self._setHostListeners();\n      self.profileManager.init(self, self.hosts, next);\n    },\n    function setKeyspace(next) {\n      if (!self.keyspace) {\n        return next();\n      }\n      self._setKeyspace(next);\n    },\n    function setPoolOptionsAndWarmup(next) {\n      //Set the pooling options depending on the protocol version\n      var coreConnectionsPerHost = clientOptions.coreConnectionsPerHostV3;\n      if (self.controlConnection.protocolVersion < 3) {\n        coreConnectionsPerHost = clientOptions.coreConnectionsPerHostV2;\n      }\n      self.options.pooling = utils.deepExtend({}, { coreConnectionsPerHost: coreConnectionsPerHost }, self.options.pooling);\n      if (!self.options.pooling.warmup) {\n        return next();\n      }\n      self._warmup(next);\n    }\n  ], function connectFinished(err) {\n    self.connected = !err;\n    self.connecting = false;\n    self.emit('connected', err);\n    if (self.connected) {\n      // Set the distance of the control connection host relatively to this instance\n      self.profileManager.getDistance(self.controlConnection.host);\n    }\n  });\n};\n\n/**\n * Executes a query on an available connection.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the execution completes. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * <p>The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag.</p>\n * <p>\n *   Some executions failures can be handled transparently by the driver, according to the\n *   [RetryPolicy]{@link module:policies/retry~RetryPolicy} defined at {@link ClientOptions} or {@link QueryOptions}\n *   level.\n * </p>\n * @param {String} query The query to execute.\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value.\n * @param {QueryOptions} [options] The query options for the execution.\n * @param {ResultCallback} [callback] Executes callback(err, result) when execution completed. When not defined, the\n * method will return a promise.\n * @example <caption>Callback-based API</caption>\n * const query = 'SELECT name, email FROM users WHERE id = ?';\n * client.execute(query, [ id ], { prepare: true }, function (err, result) {\n *   assert.ifError(err);\n *   const row = result.first();\n *   console.log('%s: %s', row.name, row.email);\n * });\n * @example <caption>Promise-based API, using async/await</caption>\n * const query = 'SELECT name, email FROM users WHERE id = ?';\n * const result = await client.execute(query, [ id ], { prepare: true });\n * const row = result.first();\n * console.log('%s: %s', row.name, row.email);\n * @see {@link ExecutionProfile} to reuse a set of options across different query executions.\n */\nClient.prototype.execute = function (query, params, options, callback) {\n  // set default argument values for optional parameters\n  callback = callback || (options ? options : params);\n  if (typeof callback === 'function') {\n    params = typeof params !== 'function' ? params : null;\n  }\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    options = clientOptions.createQueryOptions(this, options);\n    this._innerExecute(query, params, options, cb);\n  });\n};\n\n/**\n * Executes the query and calls rowCallback for each row as soon as they are received. Calls final callback after all\n * rows have been sent, or when there is an error.\n * <p>\n *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple\n *   hosts if needed.\n * </p>\n * @param {String} query The query to execute\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value.\n * @param {QueryOptions} [options]\n * @param {function} rowCallback Executes <code>rowCallback(n, row)</code> per each row received, where n is the row\n * index and row is the current Row.\n * @param {function} [callback] Executes <code>callback(err, result)</code> after all rows have been received.\n * <p>\n *   When dealing with paged results, [ResultSet#nextPage()]{@link module:types~ResultSet#nextPage} method can be used\n *   to retrieve the following page. In that case, <code>rowCallback()</code> will be again called for each row and\n *   the final callback will be invoked when all rows in the following page has been retrieved.\n * </p>\n * @example <caption>Using per-row callback and arrow functions</caption>\n * client.eachRow(query, params, { prepare: true }, (n, row) => console.log(n, row), err => console.error(err));\n * @example <caption>Overloads</caption>\n * client.eachRow(query, rowCallback);\n * client.eachRow(query, params, rowCallback);\n * client.eachRow(query, params, options, rowCallback);\n * client.eachRow(query, params, rowCallback, callback);\n * client.eachRow(query, params, options, rowCallback, callback);\n */\nClient.prototype.eachRow = function (query, params, options, rowCallback, callback) {\n  if (!callback && rowCallback && typeof options === 'function') {\n    callback = utils.bindDomain(rowCallback);\n    rowCallback = utils.bindDomain(options);\n  }\n  else {\n    callback = utils.bindDomain(callback || utils.noop);\n    rowCallback = utils.bindDomain(rowCallback || options || params);\n  }\n  params = typeof params !== 'function' ? params : null;\n  options = clientOptions.createQueryOptions(this, options, rowCallback);\n  var self = this;\n  var rowLength = 0;\n  function nextPage() {\n    self._innerExecute(query, params, options, pageCallback);\n  }\n  function pageCallback (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    // Next requests in case paging (auto or explicit) is used\n    rowLength += result.rowLength;\n    if (result.meta && result.meta.pageState) {\n      // Use new page state as next request page state\n      options.pageState = result.meta.pageState;\n      if (options.autoPage) {\n        // Issue next request for the next page\n        return nextPage();\n      }\n      // Allows for explicit (manual) paging, in case the caller needs it\n      result.nextPage = nextPage;\n    }\n    // Finished auto-paging\n    result.rowLength = rowLength;\n    callback(null, result);\n  }\n  this._innerExecute(query, params, options, pageCallback);\n};\n\n/**\n * Executes the query and pushes the rows to the result stream\n *  as soon as they received.\n * Calls callback after all rows have been sent, or when there is an error.\n * <p>\n * The stream is a [Readable Streams2]{@link http://nodejs.org/api/stream.html#stream_class_stream_readable} object\n *  that contains the raw bytes of the field value.\n *  It can be piped downstream and provides automatic pause/resume logic (it buffers when not read).\n * </p>\n * <p>\n *   The query can be prepared (recommended) or not depending on {@link QueryOptions}.prepare flag. Retries on multiple\n *   hosts if needed.\n * </p>\n * @param {String} query The query to prepare and execute\n * @param {Array|Object} [params] Array of parameter values or an associative array (object) containing parameter names\n * as keys and its value\n * @param {QueryOptions} [options]\n * @param {function} [callback], executes callback(err) after all rows have been received or if there is an error\n * @returns {types.ResultStream}\n */\nClient.prototype.stream = function (query, params, options, callback) {\n  callback = utils.bindDomain(callback || utils.noop);\n  // NOTE: the nodejs stream maintains yet another internal buffer \n  // we rely on the default stream implementation to keep memory \n  // usage reasonable.\n  var resultStream = new types.ResultStream({ objectMode: 1 });\n  function onFinish(err, result) {\n    if (err) {\n      resultStream.emit('error', err);\n    }\n    if (result && result.nextPage ) {\n      // allows for throttling as per the\n      // default nodejs stream implementation\n      resultStream._valve(function pageValve() {\n        try {\n          result.nextPage();\n        }\n        catch( ex ) {\n          resultStream.emit('error', ex );\n        }\n      });\n      return;\n    }\n    // Explicitly dropping the valve (closure)\n    resultStream._valve(null);\n    resultStream.add(null);\n    callback(err);\n  }\n  var sync = true;\n  this.eachRow(query, params, options, function rowCallback(n, row) {\n    resultStream.add(row);\n  }, function eachRowFinished(err, result) {\n    if (sync) {\n      // Prevent sync callback\n      return setImmediate(function eachRowFinishedImmediate() {\n        onFinish(err, result);\n      });\n    }\n    onFinish(err, result);\n  });\n  sync = false;\n  return resultStream;\n};\n\n/**\n * Executes batch of queries on an available connection to a host.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the execution completes. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * @param {Array.<string>|Array.<{query, params}>} queries The queries to execute as an Array of strings or as an array\n * of object containing the query and params\n * @param {QueryOptions} [options]\n * @param {ResultCallback} [callback] Executes callback(err, result) when the batch was executed\n */\nClient.prototype.batch = function (queries, options, callback) {\n  callback = callback || options;\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._batchCb(queries, options, cb);\n  });\n};\n\n/**\n * @param {Array.<string>|Array.<{query, params}>}queries\n * @param {QueryOptions} options\n * @param {ResultCallback} callback\n * @private\n */\nClient.prototype._batchCb = function (queries, options, callback) {\n  var self = this;\n  queries = validateBatchQueries(queries);\n  options = clientOptions.createQueryOptions(this, options, null, true);\n  if (options.message && options instanceof Error) {\n    return callback(options);\n  }\n  this.connect(function afterConnect(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (options.prepare) {\n      //Batch of prepared statements\n      return self._batchPrepared(queries, options, callback);\n    }\n    //Batch of simple statements\n    self._sendBatch(queries, options, callback);\n  });\n};\n\n/**\n * Gets the host list representing the replicas that contain such partition.\n * @param {String} keyspace\n * @param {Buffer} token\n * @returns {Array}\n */\nClient.prototype.getReplicas = function (keyspace, token) {\n  return this.metadata.getReplicas(keyspace, token);\n};\n\nClient.prototype.log = utils.log;\n\n/**\n * Closes all connections to all hosts.\n * <p>\n *   If a <code>callback</code> is provided, it will invoke the callback when the client is disconnected. Otherwise,\n *   it will return a <code>Promise</code>.\n * </p>\n * @param {Function} [callback] Optional callback to be invoked when finished closing all connections.\n */\nClient.prototype.shutdown = function (callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, true, this._shutdownCb);\n};\n\n/**\n * @param {Function} callback\n * @private\n */\nClient.prototype._shutdownCb = function (callback) {\n  var self = this;\n  function doShutdown() {\n    self.connected = false;\n    self.isShuttingDown = true;\n    var hosts = self.hosts.values();\n    self.controlConnection.shutdown();\n    // go through all the host and shut down their pools\n    utils.each(hosts, function (h, next) {\n      h.shutdown(false, next);\n    }, callback);\n  }\n  this.log('info', 'Shutting down');\n  callback = callback || utils.noop;\n  if (!this.hosts || !this.connected) {\n    // not initialized\n    this.connected = false;\n    return callback();\n  }\n  if (this.connecting) {\n    this.log('warning', 'Shutting down while connecting');\n    // wait until finish connecting for easier troubleshooting\n    return this.once('connected', doShutdown);\n  }\n  doShutdown();\n};\n\n/**\n * Waits until that the schema version in all nodes is the same or the waiting time passed.\n * @param {Connection} connection\n * @param {Function} callback\n * @ignore\n */\nClient.prototype._waitForSchemaAgreement = function (connection, callback) {\n  if (this.hosts.length === 1) {\n    return setImmediate(callback);\n  }\n  var self = this;\n  var start = new Date();\n  var maxWaitTime = this.options.protocolOptions.maxSchemaAgreementWaitSeconds * 1000;\n  this.log('info', 'Waiting for schema agreement');\n  var versionsMatch;\n  var peerVersions;\n  utils.whilst(function condition() {\n    return !versionsMatch && (new Date() - start) < maxWaitTime;\n  }, function fn(next) {\n    utils.series([\n      function (next) {\n        self.metadata.getPeersSchemaVersions(connection, function (err, result) {\n          peerVersions = result;\n          next(err);\n        });\n      },\n      function (next) {\n        self.metadata.getLocalSchemaVersion(connection, next);\n      }\n    ], function seriesEnded(err, localVersion) {\n      if (err) {\n        return next(err);\n      }\n      //check the different versions\n      versionsMatch = true;\n      localVersion = localVersion.toString();\n      for (var i = 0; i < peerVersions.length; i++) {\n        if (peerVersions[i].toString() !== localVersion) {\n          versionsMatch = false;\n          break;\n        }\n      }\n      if (versionsMatch) {\n        self.log('info', 'Schema versions match');\n      }\n      //let some time pass before the next check\n      setTimeout(next, 500);\n    });\n  }, callback);\n};\n\n/**\n * Waits for schema agreements and schedules schema metadata refresh.\n * @param {Connection} connection\n * @param event\n * @param {Function} callback\n * @ignore\n * @internal\n */\nClient.prototype.handleSchemaAgreementAndRefresh = function (connection, event, callback) {\n  var self = this;\n  this._waitForSchemaAgreement(connection, function agreementCb(err) {\n    if (err) {\n      //we issue a warning but we continue with the normal flow\n      self.log('warning', 'There was an error while waiting for the schema agreement between nodes', err);\n    }\n    if (!self.options.isMetadataSyncEnabled) {\n      return callback();\n    }\n    // schedule metadata refresh immediately and the callback will be invoked once it was refreshed\n    self.controlConnection.handleSchemaChange(event, true, callback);\n  });\n};\n\n/**\n * Connects and handles the execution of prepared and simple statements. All parameters are mandatory.\n * @param {string} query\n * @param {Array} params\n * @param {Object} options Options, contained already all the required QueryOptions.\n * @param {Function} callback\n * @private\n */\nClient.prototype._innerExecute = function (query, params, options, callback) {\n  // Use Error#message property because is faster than checking prototypes\n  if (options.message && options instanceof Error) {\n    return callback(options);\n  }\n  if (options.prepare) {\n    return this._executeAsPrepared(query, params, options, callback);\n  }\n  var self = this;\n  utils.series([\n    function connecting(next) {\n      self.connect(next);\n    },\n    function settingOptions(next) {\n      self._setQueryOptions(options, params, null, function setOptionsCallback(err, p) {\n        params = p;\n        next(err);\n      });\n    },\n    function sendingQuery(next) {\n      var request = new requests.QueryRequest(\n        query,\n        params,\n        options);\n      var handler = new RequestHandler(self, options.executionProfile.loadBalancing, options.retry);\n      handler.send(request, options, next);\n    }\n  ], callback);\n};\n\n/**\n * Prepares (the first time) and executes the prepared query, retrying on multiple hosts if needed.\n * @param {String} query The query to prepare and execute\n * @param {Array|Object} params Array of params or params object with the name as keys\n * @param {Object} options\n * @param {ResultCallback} callback Executes callback(err, result) when finished\n * @private\n */\nClient.prototype._executeAsPrepared = function (query, params, options, callback) {\n  var queryId;\n  var meta;\n  var self = this;\n  utils.series([\n    function connecting(next) {\n      self.connect(next);\n    },\n    function preparing(next) {\n      self._getPrepared(query, options, function (err, id, m) {\n        queryId = id;\n        meta = m;\n        next(err);\n      });\n    },\n    function settingOptions(next) {\n      self._setQueryOptions(options, params, meta, function (err, p) {\n        params = p;\n        next(err);\n      });\n    },\n    function sendingExecute(next) {\n      var request = new requests.ExecuteRequest(\n        query,\n        queryId,\n        params,\n        options);\n      request.query = query;\n      var handler = new RequestHandler(self, options.executionProfile.loadBalancing, options.retry);\n      handler.send(request, options, next);\n    }\n  ], callback);\n};\n\n/**\n * Prepares the queries and then executes the batch.\n * @param {Array.<{query, params}>} queries Array of object instances containing query and params properties.\n * @param {Object} options\n * @param {ResultCallback} callback Executes callback(err, result) when the batch was executed\n * @private\n */\nClient.prototype._batchPrepared = function (queries, options, callback) {\n  var self = this;\n  queries = queries.map(function batchQueryMap(item) {\n    return { info: self.metadata.getPreparedInfo(self.keyspace, item.query), query: item.query, params: item.params};\n  });\n  //Identify the query that are being prepared and wait for it\n  this._waitForPendingPrepares(queries, function afterWait(err, toPrepare) {\n    if (err) {\n      return callback(err);\n    }\n    var queriesToPrepare = Object.keys(toPrepare);\n    if (queriesToPrepare.length === 0) {\n      //The ones that were being prepared are now prepared\n      return self._sendBatch(queries, options, callback);\n    }\n    //Prepare the pending\n    var callbacksArray = new Array(queriesToPrepare.length);\n    queriesToPrepare.forEach(function (query, i) {\n      var info = toPrepare[query];\n      info.preparing = true;\n      callbacksArray[i] = function prepareCallback(err, response) {\n        info.preparing = false;\n        if (err) {\n          return info.emit('prepared', err);\n        }\n        info.queryId = response.id;\n        info.meta = response.meta;\n        info.emit('prepared', null, info.queryId, info.meta);\n      };\n    });\n    var handler = new RequestHandler(self, options.executionProfile.loadBalancing, options.retry);\n    //Prepare the queries that are not already prepared on a single host\n    handler.prepareMultiple(queriesToPrepare, callbacksArray, options, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      return self._sendBatch(queries, options, callback);\n    });\n  });\n};\n\n/** @private */\nClient.prototype._sendBatch = function (queries, options, callback) {\n  var request = new requests.BatchRequest(queries, options);\n  var handler = new RequestHandler(this, options.executionProfile.loadBalancing, options.retry);\n  handler.send(request, options, callback);\n};\n\n/**\n * Waits for all pending prepared queries to be prepared and callbacks with the queries to prepare\n * @param {Array} queries\n * @param {Function} callback\n * @private\n */\nClient.prototype._waitForPendingPrepares = function (queries, callback) {\n  function doWait(queriesMap) {\n    var toPrepare = {};\n    var pendingIO = false;\n    utils.each(Object.keys(queriesMap), function waitIterator(query, next) {\n      var info = queriesMap[query];\n      if (info.queryId) {\n        //Its already prepared\n        return next();\n      }\n      if (info.preparing) {\n        //it is already being prepared\n        pendingIO = true;\n        return info.once('prepared', next);\n      }\n      toPrepare[query] = info;\n      next();\n    }, function waitFinished(err) {\n      if (err) {\n        //There was an error with the queries being prepared\n        return callback(err);\n      }\n      if (pendingIO) {\n        //There was IO between the last call\n        //it is possible that queries marked to prepare are being prepared\n        //iterate again until we have the filtered list of items to prepare\n        return setImmediate(function pendingIOCallback() {\n          doWait(toPrepare);\n        });\n      }\n      callback(null, toPrepare);\n    });\n  }\n  var queriesMap = {};\n  queries.forEach(function (item) {\n    queriesMap[item.query] = item.info;\n  });\n  doWait(queriesMap);\n};\n\n/**\n * Parses and validates the arguments received by executeBatch\n * @private\n */\nfunction validateBatchQueries(queries) {\n  if (!util.isArray(queries)) {\n    throw new errors.ArgumentError('The first argument must be an Array of queries.');\n  }\n  if (queries.length === 0) {\n    throw new errors.ArgumentError('The Array of queries to batch execute can not be empty');\n  }\n  var parsedQueries = new Array(queries.length);\n  for (var i = 0; i < queries.length; i++) {\n    var item = queries[i];\n    if (!item) {\n      throw new errors.ArgumentError(util.format('Invalid query at index %d', i));\n    }\n    var query = item.query;\n    if (typeof item === 'string') {\n      query = item;\n    }\n    if (!query) {\n      throw new errors.ArgumentError(util.format('Invalid query at index %d', i));\n    }\n    parsedQueries[i] = { query: query, params: item.params};\n  }\n  return parsedQueries;\n}\n\n/**\n * It returns the id of the prepared query.\n * If its not prepared, it prepares the query.\n * If its being prepared, it queues the callback\n * @param {String} query Query to prepare with ? or :param_name as parameter placeholders\n * @param {Object} options Execution query options\n * @param {function} callback Executes callback(err, queryId) when there is a prepared statement on a connection or\n * there is an error.\n * @private\n */\nClient.prototype._getPrepared = function (query, options, callback) {\n  var info = this.metadata.getPreparedInfo(this.keyspace, query);\n  if (info.queryId) {\n    return callback(null, info.queryId, info.meta);\n  }\n  info.once('prepared', callback);\n  if (info.preparing) {\n    //it is already being prepared\n    return;\n  }\n  info.preparing = true;\n  var request = new requests.PrepareRequest(query);\n  var handler = new RequestHandler(this, options.executionProfile.loadBalancing, options.retry);\n  handler.send(request, null, function (err, result) {\n    info.preparing = false;\n    if (err) {\n      err.query = query;\n      return info.emit('prepared', err);\n    }\n    info.queryId = result.id;\n    info.meta = result.meta;\n    info.emit('prepared', null, info.queryId, info.meta);\n  });\n};\n\n/**\n * Sets the keyspace in a connection that is already opened.\n * @param {Function} callback\n * @private\n */\nClient.prototype._setKeyspace = function (callback) {\n  var handler = new RequestHandler(this, this.options.policies.loadBalancing, this.options.policies.retry);\n  handler.setKeyspace(callback);\n};\n\n/**\n * Sets the listeners for the nodes.\n * @private\n */\nClient.prototype._setHostListeners = function () {\n  var self = this;\n  function getHostUpListener(emitter, h) {\n    return (function hostUpListener() {\n      emitter.emit('hostUp', h);\n    });\n  }\n  function getHostDownListener(emitter, h) {\n    return (function hostDownListener() {\n      emitter.emit('hostDown', h);\n    });\n  }\n  //Add status listeners when new nodes are added and emit hostAdd\n  this.hosts.on('add', function hostAddedListener(h) {\n    h.on('up', getHostUpListener(self, h));\n    h.on('down', getHostDownListener(self, h));\n    self.emit('hostAdd', h);\n  });\n  //Remove all listeners and emit hostRemove\n  this.hosts.on('remove', function hostRemovedListener(h) {\n    h.removeAllListeners();\n    self.emit('hostRemove', h);\n  });\n  //Add status listeners for existing hosts\n  this.hosts.forEach(function (h) {\n    h.on('up', getHostUpListener(self, h));\n    h.on('down', getHostDownListener(self, h));\n  });\n};\n\nClient.prototype._warmup = function (callback) {\n  var self = this;\n  var hosts = this.hosts.values();\n  utils.timesLimit(hosts.length, warmupLimit, function warmupEachCallback(i, next) {\n    var h = hosts[i];\n    var distance = self.profileManager.getDistance(h);\n    if (distance !== types.distance.local) {\n      //do not warmup pool for remote or ignored hosts\n      return next();\n    }\n    h.warmupPool(function (err) {\n      if (err) {\n        //An error while trying to create a connection\n        //To 1 host is not an issue, warn the user and move on\n        self.log('warning', util.format('Connection pool to host %s could not be created: %s', h.address, err));\n      }\n      next();\n    });\n  }, callback);\n};\n\n/**\n * @returns {Encoder}\n * @private\n */\nClient.prototype._getEncoder = function () {\n  var encoder;\n  encoder = this.controlConnection.getEncoder();\n  if (!encoder) {\n    throw new errors.DriverInternalError('Encoder is not defined');\n  }\n  return encoder;\n};\n\n/**\n * Validates the values and sets the default values for the {@link QueryOptions} to be used in the query.\n * @param {QueryOptions} options Options specified by the user\n * @param params\n * @param [meta] Prepared statement metadata\n * @param {Function} callback\n * @private\n */\nClient.prototype._setQueryOptions = function (options, params, meta, callback) {\n  var protocolVersion = this.controlConnection.protocolVersion;\n  if (!options.prepare && params && !util.isArray(params) && protocolVersion < 3) {\n    //Only Cassandra 2.1 and above supports named parameters\n    return callback(new errors.ArgumentError('Named parameters for simple statements are not supported, use prepare flag'));\n  }\n  var paramsInfo;\n  var self = this;\n  utils.series([\n    function fillRoutingKeys(next) {\n      if (options.routingKey || options.routingIndexes || options.routingNames || !meta) {\n        //it is filled by the user\n        //or it is not prepared\n        return next();\n      }\n      if (util.isArray(meta.partitionKeys)) {\n        //the partition keys are provided as part of the metadata\n        options.routingIndexes = meta.partitionKeys;\n        return next();\n      }\n      self.metadata.getTable(meta.keyspace, meta.table, function (err, tableInfo) {\n        if (err) {\n          self.log('warning', util.format('Table %s.%s metadata could not be retrieved', meta.keyspace, meta.table));\n          //execute without a routing key\n          return next();\n        }\n        if (!tableInfo) {\n          //The data is not there, maybe it is being recreated\n          return next();\n        }\n        options.routingIndexes = tableInfo.partitionKeys.map(function (c) {\n          return meta.columnsByName[c.name];\n        });\n        //Skip parsing metadata next time\n        meta.partitionKeys = options.routingIndexes;\n        next();\n      });\n    },\n    function adaptParameterNames(next) {\n      try {\n        if (options.prepare) {\n          paramsInfo = utils.adaptNamedParamsPrepared(params, meta.columns);\n          //Add the type information provided by the prepared metadata\n          options.hints = meta.columns.map(function (c) {\n            return c.type;\n          });\n        }\n        else {\n          paramsInfo = utils.adaptNamedParamsWithHints(params, options);\n        }\n      }\n      catch (err) {\n        return next(err);\n      }\n      next();\n    },\n    function adaptParameterTypes(next) {\n      if (options.prepare || !util.isArray(options.hints)) {\n        return next();\n      }\n      //Only not prepared with hints\n      //Adapting user hints is an async op\n      self.metadata.adaptUserHints(self.keyspace, options.hints, next);\n    }\n  ], function finishSettingOptions(err) {\n    if (err) {\n      //There was an error setting the query options\n      return callback(err);\n    }\n    try {\n      if (typeof options.pageState === 'string') {\n        //pageState can be a hex string\n        options.pageState = new Buffer(options.pageState, 'hex');\n      }\n      //noinspection JSAccessibilityCheck\n      self._getEncoder().setRoutingKey(paramsInfo.params, options, paramsInfo.keys);\n    }\n    catch (err) {\n      return callback(err);\n    }\n    callback(null, paramsInfo.params);\n  });\n};\n\n/**\n * Callback used by execution methods.\n * @callback ResultCallback\n * @param {Error} err Error occurred in the execution of the query.\n * @param {ResultSet} [result] Result of the execution of the query.\n */\n\nmodule.exports = Client;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/control-connection.js":"\"use strict\";\nvar events = require('events');\nvar util = require('util');\nvar dns = require('dns');\nvar net = require('net');\n\nvar errors = require('./errors');\nvar Host = require('./host').Host;\nvar HostMap = require('./host').HostMap;\nvar Metadata = require('./metadata');\nvar EventDebouncer = require('./metadata/event-debouncer');\nvar requests = require('./requests');\nvar utils = require('./utils');\nvar types = require('./types');\n\nvar selectPeers = \"SELECT peer,data_center,rack,tokens,rpc_address,release_version FROM system.peers\";\nvar selectLocal = \"SELECT * FROM system.local WHERE key='local'\";\nvar newNodeDelay = 1000;\nvar metadataQueryAbortTimeout = 2000;\nvar schemaChangeTypes = {\n  created: 'CREATED',\n  updated: 'UPDATED',\n  dropped: 'DROPPED'\n};\n/**\n * Represents a connection used by the driver to receive events and to check the status of the cluster\n * @param {Object} options\n * @param {ProfileManager} profileManager\n * @extends EventEmitter\n * @constructor\n */\nfunction ControlConnection(options, profileManager) {\n  this.protocolVersion = null;\n  this.hosts = new HostMap();\n  //noinspection JSUnresolvedFunction\n  this.setMaxListeners(0);\n  Object.defineProperty(this, \"options\", { value: options, enumerable: false, writable: false});\n  /**\n   * Cluster metadata that is going to be shared between the Client and ControlConnection\n   */\n  this.metadata = new Metadata(this.options, this);\n  this.addressTranslator = this.options.policies.addressResolution;\n  this.loadBalancingPolicy = this.options.policies.loadBalancing;\n  this.initialized = false;\n  /**\n   * Host used by the control connection\n   * @type {Host|null}\n   */\n  this.host = null;\n  /**\n   * Connection used to retrieve metadata and subscribed to events\n   * @type {Connection|null}\n   */\n  this.connection = null;\n  /**\n   * Reference to the encoder of the last valid connection\n   * @type {Encoder|null}\n   */\n  this.encoder = null;\n  this.debouncer = new EventDebouncer(options.refreshSchemaDelay, this.log.bind(this));\n  this.profileManager = profileManager;\n  /** Timeout used for delayed handling of topology changes */\n  this.topologyChangeTimeout = null;\n  /** Timeout used for delayed handling of node status changes */\n  this.nodeStatusChangeTimeout = null;\n}\n\nutil.inherits(ControlConnection, events.EventEmitter);\n\n/**\n * Tries to determine a suitable protocol version to be used.\n * Tries to retrieve the hosts in the Cluster.\n * @param {Function} callback\n */\nControlConnection.prototype.init = function (callback) {\n  if (this.initialized) {\n    //prevent multiple serial initializations\n    return callback();\n  }\n  var self = this;\n  function addHost(address, port, cb) {\n    var endPoint = address + ':' + (port || self.options.protocolOptions.port);\n    var h = new Host(endPoint, self.protocolVersion, self.options);\n    self.hosts.set(endPoint, h);\n    self.log('info', 'Adding host ' + endPoint);\n    if (cb) {\n      cb();\n    }\n  }\n  utils.series([\n    function resolveNames(next) {\n      utils.each(self.options.contactPoints, function eachResolve(name, eachNext) {\n        if (name.indexOf('[') === 0 && name.indexOf(']:') > 1) {\n          // IPv6 host notation [ip]:port (RFC 3986 section 3.2.2)\n          var portSeparatorIndex = name.lastIndexOf(']:');\n          return addHost(name.substr(1, portSeparatorIndex - 1), name.substr(portSeparatorIndex + 2), eachNext);\n        }\n        if (name.indexOf('.') > 0 && name.indexOf(':') > 0) {\n          // IPv4 with port notation\n          var parts = name.split(':');\n          return addHost(parts[0], parts[1], eachNext);\n        }\n        if (net.isIP(name)) {\n          return addHost(name, null, eachNext);\n        }\n        resolveAll(name, function (err, addresses) {\n          if (err) {\n            self.log('error', 'Host with name ' + name + ' could not be resolved', err);\n            return eachNext();\n          }\n          addresses.forEach(function (address) {\n            addHost(address, null);\n          });\n          eachNext();\n        });\n      }, function (err) {\n        if (!err && self.hosts.length === 0) {\n          err = new errors.NoHostAvailableError(null, 'No host could be resolved');\n        }\n        next(err);\n      });\n    },\n    this.getConnection.bind(this),\n    function tryInitOnConnection(next) {\n      self.refreshOnConnection(true, next);\n    }\n  ], function seriesFinished(err) {\n    self.initialized = !err;\n    if (err) {\n      // Reset the internal state of the ControlConnection for future initialization attempts\n      var currentHosts = self.hosts;\n      currentHosts.forEach(function forEachHost(h) {\n        h.shutdown();\n      });\n      self.hosts = new HostMap();\n    }\n    callback(err);\n  });\n};\n\n/**\n * Gets a connection to any Host in the pool.\n * If its the first time, it will try to create a connection to a host present in the contactPoints in order.\n * @param {Function} callback\n * @emits ControlConnection#newConnection When a new connection is acquired\n */\nControlConnection.prototype.getConnection = function (callback) {\n  var self = this;\n  function done(err, c, host) {\n    if (!err) {\n      if (c) {\n        self.connection = c;\n        self.encoder = c.encoder;\n        self.host = host;\n      }\n      else {\n        // Make sure that an error is being thrown\n        err = new errors.DriverInternalError('No connection could be acquired but no error was found');\n      }\n    }\n    callback(err);\n    self.emit('newConnection', err, c, host);\n  }\n  if (!this.initialized) {\n    //it is the first time\n    this.log('info', 'Getting first connection');\n    return this.getFirstConnection(function (err, c, host) {\n      if (!err && c) {\n        self.protocolVersion = c.protocolVersion;\n        self.log('info', 'Control connection using protocol version ' + self.protocolVersion);\n      }\n      done(err, c, host);\n    });\n  }\n  this.log('info', 'Trying to acquire a connection to a new host');\n  this.getConnectionToNewHost(done);\n};\n\n/**\n * Gets an open connection to using the provided hosts Array, without using the load balancing policy.\n * Invoked before the Client can access topology of the cluster.\n * @param {Function} callback\n */\nControlConnection.prototype.getFirstConnection = function (callback) {\n  var connection = null;\n  var index = -1;\n  var openingErrors = {};\n  var hosts = this.hosts.values();\n  var host = null;\n  utils.whilst(function condition () {\n    return !connection && (++index < hosts.length);\n  }, function iterator(next) {\n    host = hosts[index];\n    host.borrowConnection(function (err, c) {\n      if (err) {\n        openingErrors[host.address] = err;\n      }\n      else {\n        connection = c;\n      }\n      next();\n    });\n  }, function done(err) {\n    if (!connection) {\n      err = new errors.NoHostAvailableError(openingErrors);\n    }\n    callback(err, connection, host);\n  });\n};\n\n/**\n * Acquires a connection to a host according to the load balancing policy.\n * If its not possible to connect, it subscribes to the hosts UP event.\n * @param {Function} callback\n */\nControlConnection.prototype.getConnectionToNewHost = function (callback) {\n  var self = this;\n  var host;\n  var connection = null;\n  this.profileManager.getDefaultLoadBalancing().newQueryPlan(null, null, function (err, iterator) {\n    if (err) {\n      var message = 'Control connection could not retrieve a query plan to determine which hosts to use, ' +\n        'using current hosts map';\n      self.log('error', message, err);\n      iterator = utils.arrayIterator(self.hosts.values());\n    }\n    //use iterator\n    utils.whilst(\n      function condition() {\n        //while there isn't a valid connection\n        if (connection) {\n          return false;\n        }\n        var item = iterator.next();\n        host = item.value;\n        return (!item.done);\n      },\n      function whileIterator(next) {\n        var distance = self.profileManager.getDistance(host);\n        if (!host.isUp()) {\n          return next();\n        }\n        if (distance === types.distance.ignored) {\n          return next();\n        }\n        host.borrowConnection(function (err, c) {\n          //move next if there was an error\n          connection = c;\n          next();\n        });\n      },\n      function whilstEnded() {\n        if (!connection) {\n          self.listenHostsForUp();\n          // Callback in error as no connection could be acquired\n          return callback(new errors.NoHostAvailableError(null));\n        }\n        callback(null, connection, host);\n      });\n  });\n};\n\n/**\n * Subscribe to the UP event of all current hosts to reconnect when one\n * of them are back up.\n */\nControlConnection.prototype.listenHostsForUp = function () {\n  var self = this;\n  var hostArray = this.hosts.values();\n  function onUp() {\n    //unsubscribe from all host\n    hostArray.forEach(function (host) {\n      host.removeListener('up', onUp);\n    });\n    self.refresh();\n  }\n  //All hosts are DOWN, we should subscribe to the UP event\n  //of each host as the HostConnectionPool is attempting to reconnect\n  hostArray.forEach(function (host) {\n    host.on('up', onUp);\n  });\n};\n\n/**\n * Gets info and subscribe to events on an specific connection\n * @param {Boolean} firstTime Determines if the cc is being initialized and\n * it's the first time that trying to retrieve host information\n * @param {Function} callback\n */\nControlConnection.prototype.refreshOnConnection = function (firstTime, callback) {\n  var c = this.connection;\n  var self = this;\n  self.log('info', 'Connection acquired to ' + self.host.address + ', refreshing nodes list');\n  utils.series([\n    function getLocalAndPeersInfo(next) {\n      var host = self.host;\n      function downOrIgnoredHandler() {\n        host.removeListener('down', downOrIgnoredHandler);\n        host.removeListener('ignore', downOrIgnoredHandler);\n        self.hostDownHandler();\n      }\n      host.once('down', downOrIgnoredHandler);\n      host.once('ignore', downOrIgnoredHandler);\n      self.refreshHosts(firstTime, next);\n    },\n    function subscribeConnectionEvents(next) {\n      c.on('nodeTopologyChange', self.nodeTopologyChangeHandler.bind(self));\n      c.on('nodeStatusChange', self.nodeStatusChangeHandler.bind(self));\n      c.on('nodeSchemaChange', self.nodeSchemaChangeHandler.bind(self));\n      var request = new requests.RegisterRequest(['TOPOLOGY_CHANGE', 'STATUS_CHANGE', 'SCHEMA_CHANGE']);\n      c.sendStream(request, null, next);\n    }],\n    function initDone(err) {\n      if (err) {\n        // An error occurred, the ControlConnection will still reconnect as it's listening to host 'down' event\n        self.log('error', 'ControlConnection could not be initialized', err);\n      }\n      else {\n        self.log('info', 'ControlConnection connected to ' + self.host.address + ' and is up to date');\n      }\n      callback(err);\n    });\n};\n\n/**\n * Gets the info from local and peer metadata, reloads the keyspaces metadata and rebuilds tokens.\n * @param {Boolean} newNodesUp\n * @param {Function} [callback]\n */\nControlConnection.prototype.refreshHosts = function (newNodesUp, callback) {\n  if (!callback) {\n    callback = function () {};\n  }\n  // it's possible that this was called as a result of a topology change, but the connection was lost\n  // between scheduling time and now.\n  if (!this.connection) {\n    callback();\n    // this will be called again when there is a new connection.\n    return;\n  }\n  var self = this;\n  if (!this.host.protocolVersion) {\n    this.hosts.forEach(function (h) {\n      h.setProtocolVersion(self.protocolVersion);\n    });\n  }\n  this.log('info', 'Refreshing local and peers info');\n  var c = this.connection;\n  var host = this.host;\n  utils.series([\n    function getLocalInfo(next) {\n      var request = new requests.QueryRequest(selectLocal, null, null);\n      c.sendStream(request, null, function (err, result) {\n        self.setLocalInfo(c.endpoint, result);\n        next(err);\n      });\n    },\n    function getPeersInfo(next) {\n      var request = new requests.QueryRequest(selectPeers, null, null);\n      c.sendStream(request, null, function (err, result) {\n        self.setPeersInfo(newNodesUp, result, next);\n      });\n    },\n    function getKeyspaces(next) {\n      // to acquire metadata we need to specify the cassandra version\n      self.metadata.setCassandraVersion(host.getCassandraVersion());\n      self.metadata.buildTokens(self.hosts);\n      if (!self.options.isMetadataSyncEnabled) {\n        return next();\n      }\n      self.metadata.refreshKeyspaces(false, next);\n    }\n  ], callback);\n};\n\nControlConnection.prototype.hostDownHandler = function () {\n  this.log('warning', 'Host ' + this.host.address + ' used by the ControlConnection DOWN');\n  this.host = null;\n  this.connection = null;\n  this.refresh();\n};\n\n/**\n * Acquires a connection and refreshes topology metadata.\n * @param {Function} [callback]\n */\nControlConnection.prototype.refresh = function (callback) {\n  var self = this;\n  utils.series([\n    this.getConnection.bind(this),\n    function (next) {\n      if (!self.connection) {\n        return next();\n      }\n      self.refreshOnConnection(false, next);\n    }], function doneRefreshing(err) {\n\n    if (err || !self.connection) {\n      self.log('error', 'ControlConnection was not able to reconnect');\n    }\n    if (callback) {\n      callback(err);\n    }\n  });\n};\n\n/**\n * @param {String} type\n * @param {String} info\n * @param [furtherInfo]\n */\nControlConnection.prototype.log = utils.log;\n\n/**\n * Handles a TOPOLOGY_CHANGE event\n */\nControlConnection.prototype.nodeTopologyChangeHandler = function (event) {\n  this.log('info', 'Received topology change', event);\n  // all hosts information needs to be refreshed as tokens might have changed\n  var self = this;\n  clearTimeout(this.topologyChangeTimeout);\n  // Use an additional timer to make sure that the refresh hosts is executed only AFTER the delay\n  // In this case, the event debouncer doesn't help because it could not honor the sliding delay (ie: processNow)\n  this.topologyChangeTimeout = setTimeout(function nodeTopologyDelayedHandler() {\n    self.scheduleRefreshHosts();\n  }, newNodeDelay);\n};\n\n/**\n * Handles a STATUS_CHANGE event\n */\nControlConnection.prototype.nodeStatusChangeHandler = function (event) {\n  var self = this;\n  var addressToTranslate = event.inet.address.toString();\n  var port = this.options.protocolOptions.port;\n  this.addressTranslator.translate(addressToTranslate, port, function translateCallback(endPoint) {\n    var host = self.hosts.get(endPoint);\n    if (!host) {\n      self.log('warning', 'Received status change event but host was not found: ' + addressToTranslate);\n      return;\n    }\n    var distance = self.profileManager.getDistance(host);\n    if (event.up) {\n      if (distance === types.distance.ignored) {\n        return host.setUp(true);\n      }\n      clearTimeout(self.nodeStatusChangeTimeout);\n      // Waits a couple of seconds before marking it as UP\n      self.nodeStatusChangeTimeout = setTimeout(function delayCheckIsUp() {\n        host.checkIsUp();\n      }, newNodeDelay);\n      return;\n    }\n    // marked as down\n    if (distance === types.distance.ignored) {\n      return host.setDown();\n    }\n    self.log('warning', 'Received status change to DOWN for host ' + host.address);\n  });\n};\n\n/**\n * Handles a SCHEMA_CHANGE event\n */\nControlConnection.prototype.nodeSchemaChangeHandler = function (event) {\n  this.log('info', 'Schema change', event);\n  if (!this.options.isMetadataSyncEnabled) {\n    return;\n  }\n  this.handleSchemaChange(event, false);\n};\n\n/**\n * @param {{keyspace: string, isKeyspace: boolean, schemaChangeType, table, udt, functionName, aggregate}} event\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.handleSchemaChange = function (event, processNow, callback) {\n  var self = this;\n  var handler, cqlObject;\n  if (event.isKeyspace) {\n    if (event.schemaChangeType === schemaChangeTypes.dropped) {\n      handler = function removeKeyspace() {\n        // if on the same event queue there is a creation, this handler is not going to be executed\n        // it is safe to remove the keyspace metadata\n        delete self.metadata.keyspaces[event.keyspace];\n      };\n      return this.scheduleObjectRefresh(handler, event.keyspace, null, processNow, callback);\n    }\n    return this.scheduleKeyspaceRefresh(event.keyspace, processNow, callback);\n  }\n  var ksInfo = this.metadata.keyspaces[event.keyspace];\n  if (!ksInfo) {\n    // it hasn't been loaded and it is not part of the metadata, don't mind\n    return;\n  }\n  if (event.table) {\n    cqlObject = event.table;\n    handler = function clearTableState() {\n      delete ksInfo.tables[event.table];\n      delete ksInfo.views[event.table];\n    };\n  }\n  else if (event.udt) {\n    cqlObject = event.udt;\n    handler = function clearUdtState() {\n      delete ksInfo.udts[event.udt];\n    };\n  }\n  else if (event.functionName) {\n    cqlObject = event.functionName;\n    handler = function clearFunctionState() {\n      delete ksInfo.functions[event.functionName];\n    };\n  }\n  else if (event.aggregate) {\n    cqlObject = event.aggregate;\n    handler = function clearKeyspaceState() {\n      delete ksInfo.aggregates[event.aggregate];\n    };\n  }\n  if (handler) {\n    // is a cql object change clean the internal cache\n    this.scheduleObjectRefresh(handler, event.keyspace, cqlObject, processNow, callback);\n  }\n};\n\n/**\n * @param {Function} handler\n * @param {String} keyspaceName\n * @param {String} cqlObject\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleObjectRefresh = function (handler, keyspaceName, cqlObject, processNow, callback) {\n  this.debouncer.eventReceived(\n    { handler: handler, keyspace: keyspaceName, cqlObject: cqlObject, callback: callback },\n    processNow\n  );\n};\n\n/**\n * @param {String} keyspaceName\n * @param {Boolean} processNow\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleKeyspaceRefresh = function (keyspaceName, processNow, callback) {\n  var self = this;\n  var handler = function keyspaceRefreshHandler(cb) {\n    self.metadata.refreshKeyspace(keyspaceName, cb);\n  };\n  this.debouncer.eventReceived({ handler: handler, keyspace: keyspaceName, callback: callback}, processNow);\n};\n\n/**\n * @param {Function} [callback]\n */\nControlConnection.prototype.scheduleRefreshHosts = function (callback) {\n  var self = this;\n  var handler = function hostsRefreshHandler(cb) {\n    self.refreshHosts(false, cb);\n  };\n  this.debouncer.eventReceived({ handler: handler, all: true, callback: callback }, false);\n};\n\nControlConnection.prototype.setLocalInfo = function (endPoint, result) {\n  if (!result || !result.rows || !result.rows.length) {\n    this.log('warning', 'No local info provided');\n    return;\n  }\n  var row = result.rows[0];\n  var localHost = this.hosts.get(endPoint);\n  if (!localHost) {\n    this.log('error', 'Localhost could not be found');\n    return;\n  }\n  localHost.datacenter = row['data_center'];\n  localHost.rack = row['rack'];\n  localHost.tokens = row['tokens'];\n  localHost.cassandraVersion = row['release_version'];\n  this.metadata.setPartitioner(row['partitioner']);\n  this.log('info', 'Local info retrieved');\n};\n\n/**\n * @param {Boolean} newNodesUp\n * @param {ResultSet} result\n * @param {Function} callback\n */\nControlConnection.prototype.setPeersInfo = function (newNodesUp, result, callback) {\n  if (!result || !result.rows) {\n    return callback();\n  }\n  var self = this;\n  //A map of peers, could useful for in case there are discrepancies\n  var peers = {};\n  var port = this.options.protocolOptions.port;\n  utils.eachSeries(result.rows, function eachPeer(row, next) {\n    self.getAddressForPeerHost(row, port, function getAddressForPeerCallback(endPoint) {\n      if (!endPoint) {\n        return next();\n      }\n      peers[endPoint] = true;\n      var host = self.hosts.get(endPoint);\n      if (!host) {\n        host = new Host(endPoint, self.protocolVersion, self.options);\n        if (!newNodesUp) {\n          host.setDown();\n        }\n        self.log('info', 'Adding host ' + endPoint);\n        self.hosts.set(endPoint, host);\n      }\n      host.datacenter = row['data_center'];\n      host.rack = row['rack'];\n      host.tokens = row['tokens'];\n      host.cassandraVersion = row['release_version'];\n      next();\n    });\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    //Is there a difference in number between peers + local != hosts\n    if (self.hosts.length > result.rows.length + 1) {\n      //There are hosts in the current state that don't belong (nodes removed or wrong contactPoints)\n      self.log('info', 'Removing nodes from the pool');\n      var toRemove = [];\n      self.hosts.forEach(function (h) {\n        //It is not a peer and it is not local host\n        if (!peers[h.address] && h !== self.host) {\n          self.log('info', 'Removing host ' + h.address);\n          toRemove.push(h.address);\n          h.shutdown(true);\n        }\n      });\n      self.hosts.removeMultiple(toRemove);\n    }\n    self.log('info', 'Peers info retrieved');\n    callback();\n  });\n};\n\n/**\n * @param {Object|Row} row\n * @param {Number} defaultPort\n * @param {Function} callback The callback to invoke with the string representation of the host endpoint,\n *  containing the ip address and port.\n */\nControlConnection.prototype.getAddressForPeerHost = function (row, defaultPort, callback) {\n  var address = row['rpc_address'];\n  var peer = row['peer'];\n  var bindAllAddress = '0.0.0.0';\n  if (!address) {\n    this.log('error', util.format('No rpc_address found for host %s in %s\\'s peers system table. %s will be ignored.', peer, this.host.address, peer));\n    return callback(null);\n  }\n  if (address.toString() === bindAllAddress) {\n    this.log('warning', util.format('Found host with 0.0.0.0 as rpc_address, using listen_address (%s) to contact it instead. If this is incorrect you should avoid the use of 0.0.0.0 server side.', peer));\n    address = peer;\n  }\n  this.addressTranslator.translate(address.toString(), defaultPort, callback);\n};\n\n/**\n * Waits for a connection to be available. If timeout expires before getting a connection it callbacks in error.\n * @param {Function} callback\n */\nControlConnection.prototype.waitForReconnection = function (callback) {\n  var timeout;\n  var self = this;\n  function newConnectionListener(err) {\n    clearTimeout(timeout);\n    callback(err);\n  }\n  this.once('newConnection', newConnectionListener);\n  timeout = setTimeout(function waitTimeout() {\n    self.removeListener('newConnection', newConnectionListener);\n    callback(new errors.OperationTimedOutError('A connection could not be acquired before timeout.'));\n  }, metadataQueryAbortTimeout);\n};\n\n/**\n * Executes a query using the active connection\n * @param {String} cqlQuery\n * @param {Boolean} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not\n * connected at the moment. Default: true.\n * @param {Function} callback\n */\nControlConnection.prototype.query = function (cqlQuery, waitReconnect, callback) {\n  var self = this;\n  if (typeof waitReconnect === 'function') {\n    callback = waitReconnect;\n    waitReconnect = true;\n  }\n  function queryOnConnection() {\n    var request = new requests.QueryRequest(cqlQuery, null, null);\n    self.connection.sendStream(request, null, callback);\n  }\n  if (!this.connection) {\n    if (!waitReconnect) {\n      return callback(new errors.NoHostAvailableError(null));\n    }\n    // Wait until its reconnected (or timer elapses)\n    return this.waitForReconnection(function waitCallback(err) {\n      if (err) {\n        //it was not able to reconnect in time\n        return callback(err);\n      }\n      queryOnConnection();\n    });\n  }\n  queryOnConnection();\n};\n\n/** @returns {Encoder} The encoder used by the current connection */\nControlConnection.prototype.getEncoder = function () {\n  if (!this.encoder) {\n    throw new errors.DriverInternalError('Encoder is not defined');\n  }\n  return this.encoder;\n};\n\nControlConnection.prototype.shutdown = function () {\n  // no need for callback as it all sync\n  this.debouncer.shutdown();\n  // Emit a \"newConnection\" event with Error, as it may clear timeouts that were waiting new connections\n  this.emit('newConnection', new errors.DriverError('ControlConnection is being shutdown'));\n  // Cancel other timers\n  clearTimeout(this.topologyChangeTimeout);\n  clearTimeout(this.nodeStatusChangeTimeout);\n};\n\n/**\n * Uses the DNS protocol to resolve a IPv4 and IPv6 addresses (A and AAAA records) for the hostname\n * @param name\n * @param callback\n */\nfunction resolveAll(name, callback) {\n  var addresses = [];\n  utils.parallel([\n    function resolve4(next) {\n      dns.resolve4(name, function resolve4Callback(err, arr) {\n        if (arr) {\n          addresses.push.apply(addresses, arr);\n        }\n        // Ignore error\n        next();\n      });\n    },\n    function resolve6(next) {\n      dns.resolve6(name, function resolve6Callback(err, arr) {\n        if (arr) {\n          addresses.push.apply(addresses, arr);\n        }\n        // Ignore error\n        next();\n      });\n    }\n  ], function resolveAllCallback() {\n    if (addresses.length === 0) {\n      // In case dns.resolve*() methods don't yield a valid address for the host name\n      // Use system call getaddrinfo() that might resolve according to host system definitions\n      return dns.lookup(name, function (err, addr) {\n        if (err) {\n          return callback(err);\n        }\n        addresses.push(addr);\n        callback(null, addresses);\n      });\n    }\n    callback(null, addresses);\n  });\n}\n\nmodule.exports = ControlConnection;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/host.js":"\"use strict\";\nvar util = require('util');\nvar events = require('events');\n\nvar utils = require('./utils');\nvar types = require('./types');\nvar HostConnectionPool = require('./host-connection-pool');\n/**\n * Creates a new Host instance.\n * @classdesc\n * Represents a Cassandra node.\n * @extends EventEmitter\n * @constructor\n */\nfunction Host(address, protocolVersion, options) {\n  events.EventEmitter.call(this);\n  /**\n   * Gets ip address and port number of the node separated by `:`.\n   * @type {String}\n   */\n  this.address = address;\n  this.setDownAt = 0;\n  Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false});\n  /**\n   * @type {HostConnectionPool}\n   */\n  Object.defineProperty(this, 'pool', { value: new HostConnectionPool(this, protocolVersion), enumerable: false});\n  var self = this;\n  this.pool.on('open', this._onNewConnectionOpen.bind(this));\n  this.pool.on('remove', function onConnectionRemovedFromPool() {\n    self._checkPoolState();\n  });\n  /**\n   * Gets string containing the Cassandra version.\n   * @type {String}\n   */\n  this.cassandraVersion = null;\n  /**\n   * Gets data center name of the node.\n   * @type {String}\n   */\n  this.datacenter = null;\n  /**\n   * Gets rack name of the node.\n   * @type {String}\n   */\n  this.rack = null;\n  /**\n   * Gets the tokens assigned to the node.\n   * @type {Array}\n   */\n  this.tokens = null;\n  // the distance as last set using the load balancing policy\n  this._distance = types.distance.ignored;\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n}\n\nutil.inherits(Host, events.EventEmitter);\n\n/**\n * Marks this host as not available for query coordination.\n * @internal\n * @ignore\n */\nHost.prototype.setDown = function() {\n  // multiple events signaling that a host is failing could cause multiple calls to this method\n  if (this.setDownAt !== 0) {\n    // the host is already marked as Down\n    return;\n  }\n  if (this.pool.isClosing()) {\n    // the pool is being closed/shutdown, don't mind\n    return;\n  }\n  this.setDownAt = Date.now();\n  if (this._distance !== types.distance.ignored) {\n    this.log('warning',\n      util.format('Host %s considered as DOWN. Reconnection delay %dms.', this.address, this.reconnectionDelay));\n  }\n  else {\n    this.log('info', util.format('Host %s considered as DOWN.', this.address));\n  }\n  this.emit('down');\n  this._checkPoolState();\n};\n\n/**\n * Marks this host as available for querying.\n * @param {Boolean} [clearReconnection]\n * @internal\n * @ignore\n */\nHost.prototype.setUp = function (clearReconnection) {\n  if (!this.setDownAt) {\n    //The host is already marked as UP\n    return;\n  }\n  this.log('info', util.format('Setting host %s as UP', this.address));\n  this.setDownAt = 0;\n  //if it was unhealthy and now it is not, lets reset the reconnection schedule.\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n  if (clearReconnection) {\n    this.pool.clearNewConnectionAttempt();\n  }\n  this.emit('up');\n};\n\n/**\n * Resets the reconnectionSchedule and tries to issue a reconnection immediately.\n * @internal\n * @ignore\n */\nHost.prototype.checkIsUp = function () {\n  if (this.isUp()) {\n    return;\n  }\n  this.reconnectionSchedule = this.options.policies.reconnection.newSchedule();\n  this.reconnectionDelay = 0;\n  this.pool.attemptNewConnectionImmediate();\n};\n\n/**\n * @param {Boolean} waitForPending When true, it waits for in-flight operations to be finish before closing the\n * connections.\n * @param {Function} [callback]\n * @internal\n * @ignore\n */\nHost.prototype.shutdown = function (waitForPending, callback) {\n  callback = callback || utils.noop;\n  if (waitForPending) {\n    this.pool.drainAndShutdown();\n    // Gracefully draining and shutting down the pool is being done in the background, it's not required\n    // for the shutting down to be over to callback\n    return callback();\n  }\n  this.pool.shutdown(callback);\n};\n\n/**\n * Determines if the node is UP now (seen as UP by the driver).\n * @returns {boolean}\n */\nHost.prototype.isUp = function () {\n  return !this.setDownAt;\n};\n\n/**\n * Determines if the host can be considered as UP\n * @returns {boolean}\n */\nHost.prototype.canBeConsideredAsUp = function () {\n  var self = this;\n  function hasTimePassed() {\n    return new Date().getTime() - self.setDownAt >= self.reconnectionDelay;\n  }\n  return !this.setDownAt || hasTimePassed();\n};\n\n/**\n * Sets the distance of the host relative to the client using the load balancing policy.\n * @param {Number} distance\n * @internal\n * @ignore\n */\nHost.prototype.setDistance = function (distance) {\n  var previousDistance = this._distance;\n  this._distance = distance || types.distance.local;\n  if (this.options.pooling.coreConnectionsPerHost) {\n    this.pool.coreConnectionsLength = this.options.pooling.coreConnectionsPerHost[this._distance] || 0;\n  }\n  else {\n    this.pool.coreConnectionsLength = 1;\n  }\n  if (this._distance === previousDistance) {\n    return this._distance;\n  }\n  if (this._distance === types.distance.ignored) {\n    // this host was local/remote and now must be ignored\n    this.emit('ignore');\n    this.pool.drainAndShutdown();\n  }\n  else if (!this.isUp()) {\n    this.checkIsUp();\n  }\n  return this._distance;\n};\n\n/**\n * Changes the protocol version of a given host\n * @param {Number} value\n * @internal\n * @ignore\n */\nHost.prototype.setProtocolVersion = function (value) {\n  this.pool.protocolVersion = value;\n};\n\n/**\n * It gets an open connection to the host.\n * If there isn't an available connections, it will open a new one according to the pooling options.\n * @param {Function} callback\n * @internal\n * @ignore\n */\nHost.prototype.borrowConnection = function (callback) {\n  this.pool.borrowConnection(callback);\n};\n\n/**\n * Creates all the connection in the pool.\n * @param {Function} callback\n * @internal\n * @ignore\n */\nHost.prototype.warmupPool = function (callback) {\n  this.pool.create(true, callback);\n};\n\n/**\n * Gets any connection that is already opened or null if not found.\n * @returns {Connection}\n * @internal\n * @ignore\n */\nHost.prototype.getActiveConnection = function () {\n  if (!this.isUp() || !this.pool.connections.length) {\n    return null;\n  }\n  return this.pool.connections[0];\n};\n\n/**\n * Checks the health of a connection in the pool\n * @param {Connection} connection\n * @internal\n * @ignore\n */\nHost.prototype.checkHealth = function (connection) {\n  if (connection.timedOutHandlers <= this.options.socketOptions.defunctReadTimeoutThreshold) {\n    return;\n  }\n  this.removeFromPool(connection);\n};\n\n/**\n * @param {Connection} connection\n * @internal\n * @ignore\n */\nHost.prototype.removeFromPool = function (connection) {\n  this.pool.remove(connection);\n  this._checkPoolState();\n};\n\n/**\n * Validates that the internal state of the connection pool.\n * If the pool size is smaller than expected, schedule a new connection attempt.\n * If the amount of connections is 0 for not ignored hosts, the host must be down.\n * @private\n */\nHost.prototype._checkPoolState = function () {\n  if (this.pool.isClosing()) {\n    return;\n  }\n  if (this.pool.connections.length < this.pool.coreConnectionsLength) {\n    // the pool still needs to grow\n    if (!this.pool.hasScheduledNewConnection()) {\n      this.reconnectionDelay = this.reconnectionSchedule.next().value;\n      this.pool.scheduleNewConnectionAttempt(this.reconnectionDelay);\n    }\n  }\n  if (this._distance !== types.distance.ignored &&\n      this.pool.connections.length === 0 &&\n      this.pool.coreConnectionsLength > 0) {\n    this.setDown();\n  }\n};\n\n/**\n * Executed after an scheduled new connection attempt finished\n * @private\n */\nHost.prototype._onNewConnectionOpen = function (err) {\n  if (err) {\n    this._checkPoolState();\n    return;\n  }\n  this.setUp();\n  this.pool.increaseSize();\n};\n\n/**\n * Returns an array containing the Cassandra Version as an Array of Numbers having the major version in the first\n * position.\n * @returns {Array.<Number>}\n */\nHost.prototype.getCassandraVersion = function () {\n  if (!this.cassandraVersion) {\n    return utils.emptyArray;\n  }\n  return this.cassandraVersion.split('-')[0].split('.').map(function eachMap(x) {\n    return parseInt(x, 10);\n  });\n};\n\nHost.prototype.log = utils.log;\n\n/**\n * Represents an associative-array of {@link Host hosts} that can be iterated.\n * It creates an internal copy when adding or removing, making it safe to iterate using the values() method within async operations.\n * @extends events.EventEmitter\n * @constructor\n */\nfunction HostMap() {\n  events.EventEmitter.call(this);\n  this._items = {};\n  this._values = null;\n  Object.defineProperty(this, 'length', { get: function () { return this.values().length; }, enumerable: true });\n}\n\nutil.inherits(HostMap, events.EventEmitter);\n\n/**\n * Emitted when a host is added to the map\n * @event HostMap#add\n */\n/**\n * Emitted when a host is removed from the map\n * @event HostMap#remove\n */\n\n/**\n * Executes a provided function once per map element.\n * @param callback\n */\nHostMap.prototype.forEach = function (callback) {\n  //Use a new reference, allowing the map to be modified.\n  var items = this._items;\n  for (var key in items) {\n    if (!items.hasOwnProperty(key)) {\n      continue;\n    }\n    callback(items[key], key);\n  }\n};\n\n/**\n * Gets a {@link Host host} by key or undefined if not found.\n * @param {String} key\n * @returns {Host}\n */\nHostMap.prototype.get = function (key) {\n  return this._items[key];\n};\n\n/**\n * Returns an array of host addresses.\n * @returns {Array.<String>}\n */\nHostMap.prototype.keys = function () {\n  return Object.keys(this._items);\n};\n\n/**\n * Removes an item from the map.\n * @param {String} key The key of the host\n * @fires HostMap#remove\n */\nHostMap.prototype.remove = function (key) {\n  if (!this._items.hasOwnProperty(key)) {\n    //it's not part of it, do nothing\n    return;\n  }\n  //clear cache\n  this._values = null;\n  //copy the values\n  var copy = utils.extend({}, this._items);\n  var h = copy[key];\n  delete copy[key];\n  this._items = copy;\n  this.emit('remove', h);\n};\n\n/**\n * Removes multiple hosts from the map.\n * @param {Array.<String>} keys\n * @fires HostMap#remove\n */\nHostMap.prototype.removeMultiple = function (keys) {\n  //clear value cache\n  this._values = null;\n  //copy the values\n  var copy = utils.extend({}, this._items);\n  var removedHosts = [];\n  for (var i = 0; i < keys.length; i++) {\n    var h = copy[keys[i]];\n    if (!h) {\n      continue;\n    }\n    removedHosts.push(h);\n    delete copy[keys[i]];\n  }\n  this._items = copy;\n  removedHosts.forEach(function (h) {\n    this.emit('remove', h);\n  }, this);\n};\n\n/**\n * Adds a new item to the map.\n * @param {String} key The key of the host\n * @param {Host} value The host to be added\n * @fires HostMap#remove\n * @fires HostMap#add\n */\nHostMap.prototype.set = function (key, value) {\n  //clear values cache\n  this._values = null;\n  var originalValue = this._items[key];\n  if (originalValue) {\n    //The internal structure does not change\n    this._items[key] = value;\n    //emit a remove followed by a add\n    this.emit('remove', originalValue);\n    this.emit('add', value);\n    return;\n  }\n  //copy the values\n  var copy = utils.extend({}, this._items);\n  copy[key] = value;\n  this._items = copy;\n  this.emit('add', value);\n  return value;\n};\n\n/**\n * Returns a shallow copy of a portion of the items into a new array object.\n * Backward-compatibility.\n * @param {Number} [begin]\n * @param {Number} [end]\n * @returns {Array}\n * @ignore\n */\nHostMap.prototype.slice = function (begin, end) {\n  if (!begin && !end) {\n    //avoid making a copy of the copy\n    return this.values();\n  }\n  begin = begin || 0;\n  return this.values().slice(begin, end);\n};\n//Backward-compatibility\nHostMap.prototype.push = HostMap.prototype.set;\n\n/**\n * Returns a shallow copy of the values of the map.\n * @returns {Array.<Host>}\n */\nHostMap.prototype.values = function () {\n  if (!this._values) {\n    //cache the values\n    var values = [];\n    for (var key in this._items) {\n      if (!this._items.hasOwnProperty(key)) {\n        continue;\n      }\n      values.push(this._items[key]);\n    }\n    this._values = Object.freeze(values);\n  }\n  return this._values;\n};\n\nHostMap.prototype.inspect = function() {\n  return this._items;\n};\n\nHostMap.prototype.toJSON = function() {\n  return this._items;\n};\n\nexports.Host = Host;\nexports.HostMap = HostMap;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/host-connection-pool.js":"\"use strict\";\nvar util = require('util');\nvar events = require('events');\n\nvar Connection = require('./connection');\nvar utils = require('./utils');\nvar defaultOptions = require('./client-options').defaultOptions();\n\n// Used to get the index of the connection with less in-flight requests\nvar connectionIndex = 0;\nvar connectionIndexOverflow = Math.pow(2, 15);\n\n/**\n * Represents the possible states of the pool.\n * Possible state transitions:\n *  - From initial to closing: The pool must be closed because the host is ignored.\n *  - From initial to shuttingDown: The pool is being shutdown as a result of a client shutdown.\n *  - From closing to initial state: The pool finished closing connections (is now ignored) and it resets to\n *    initial state in case the host is marked as local/remote in the future.\n *  - From closing to shuttingDown (rare): It was marked as ignored, now the client is being shutdown.\n *  - From shuttingDown to shutdown: Finished shutting down, the pool should not be reused.\n * @private\n */\nvar state = {\n  // Initial state: open / opening / ready to be opened\n  initial: 0,\n  // When the pool is being closed as part of a distance change\n  closing: 1,\n  // When the pool is being shutdown for good\n  shuttingDown: 2,\n  // When the pool has being shutdown\n  shutDown: 4\n};\n\n/**\n * Represents a pool of connections to a host\n * @param {Host} host\n * @param {Number} protocolVersion Initial protocol version\n * @extends EventEmitter\n * @constructor\n */\nfunction HostConnectionPool(host, protocolVersion) {\n  events.EventEmitter.call(this);\n  this._address = host.address;\n  this._newConnectionTimeout = null;\n  this._creating = false;\n  this._state = state.initial;\n  this.options = host.options;\n  this.protocolVersion = protocolVersion;\n  this.coreConnectionsLength = 1;\n  /**\n   * An immutable array of connections\n   * @type {Array.<Connection>}\n   */\n  this.connections = utils.emptyArray;\n  this.setMaxListeners(0);\n}\n\nutil.inherits(HostConnectionPool, events.EventEmitter);\n\n/**\n * @param {Function} callback\n */\nHostConnectionPool.prototype.borrowConnection = function (callback) {\n  var self = this;\n  this.create(false, function afterCreating(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (self.connections.length === 0) {\n      // Normally an error should be thrown in this case, but better to handle this possibility\n      return callback(new Error('No connection available'));\n    }\n    var c = HostConnectionPool.minInFlight(self.connections);\n    callback(null, c);\n  });\n};\n\n/**\n * Gets the connection with the minimum number of in-flight requests.\n * Only checks for index + 1 and index, to avoid a loop through all the connections.\n * @param {Array.<Connection>} connections\n * @returns {Connection}\n */\nHostConnectionPool.minInFlight = function(connections) {\n  var length = connections.length;\n  if (length === 1) {\n    return connections[0];\n  }\n  var index = ++connectionIndex;\n  if (connectionIndex >= connectionIndexOverflow) {\n    connectionIndex = 0;\n  }\n  var current = connections[index % length];\n  var previous = connections[(index - 1) % length];\n  if (previous.getInFlight() < current.getInFlight()) {\n    return previous;\n  }\n  return current;\n};\n\n/**\n * Create the min amount of connections, if the pool is empty.\n * @param {Boolean} warmup Determines if all connections must be created before invoking the callback\n * @param {Function} callback\n */\nHostConnectionPool.prototype.create = function (warmup, callback) {\n  if (this.isClosing()) {\n    return callback(new Error('Pool is being closed when calling create'));\n  }\n  // The value of this.coreConnectionsLength can change over time\n  // when an existing pool is being resized (by setting the distance).\n  if (this.connections.length >= this.coreConnectionsLength) {\n    return callback();\n  }\n  if (!warmup && this.connections.length > 0) {\n    // we already have a valid connection\n    // let the connection grow continue in the background\n    this.increaseSize();\n    return callback();\n  }\n  this.once('creation', callback);\n  if (this._creating) {\n    // wait for the pool to be creating\n    return;\n  }\n  this._creating = true;\n  var connectionsToCreate = this.coreConnectionsLength;\n  if (!warmup) {\n    connectionsToCreate = 1;\n  }\n  var self = this;\n  utils.whilst(\n    function condition() {\n      return self.connections.length < connectionsToCreate;\n    },\n    function iterator(next) {\n      self._attemptNewConnection(next);\n    }, function whilstEnded(err) {\n      self._creating = false;\n      if (err) {\n        if (self.isClosing()) {\n          self.log('info', 'Connection pool created but it was being closed');\n          self._closeAllConnections();\n          err = new Error('Pool is being closed');\n        }\n        else {\n          // there was an error and no connections could be successfully opened\n          self.log('warning', util.format('Connection pool to host %s could not be created', self._address), err);\n        }\n        return self.emit('creation', err);\n      }\n      self.log('info', util.format('Connection pool to host %s created with %d connection(s)',\n        self._address, self.connections.length));\n      self.emit('creation');\n      self.increaseSize();\n    });\n};\n\n/** @returns {Connection} */\nHostConnectionPool.prototype._createConnection = function () {\n  var c = new Connection(this._address, this.protocolVersion, this.options);\n  var self = this;\n  function connectionErrorCallback() {\n    // The socket is not fully open / can not send heartbeat\n    self.remove(c);\n  }\n  c.on('idleRequestError', connectionErrorCallback);\n  c.on('socketClose', connectionErrorCallback);\n  return c;\n};\n\n/**\n * Prevents reconnection timeout from triggering\n */\nHostConnectionPool.prototype.clearNewConnectionAttempt = function () {\n  if (!this._newConnectionTimeout) {\n    return;\n  }\n  clearTimeout(this._newConnectionTimeout);\n  this._newConnectionTimeout = null;\n};\n\n/**\n * @param {Function} callback\n */\nHostConnectionPool.prototype._attemptNewConnection = function (callback) {\n  var c = this._createConnection();\n  var self = this;\n  this.once('open', callback);\n  if (this._opening) {\n    // wait for the event to fire\n    return;\n  }\n  this._opening = true;\n  c.open(function attemptOpenCallback(err) {\n    self._opening = false;\n    if (err) {\n      self.log('warning', util.format('Connection to %s could not be created: %s', self._address, err), err);\n      c.close();\n      return self.emit('open', err);\n    }\n    if (self.isClosing()) {\n      self.log('info', util.format('Connection to %s opened successfully but pool was being closed', self._address));\n      c.close();\n      return self.emit('open', new Error('Connection closed'));\n    }\n    // use a copy of the connections array\n    var newConnections = self.connections.slice(0);\n    newConnections.push(c);\n    self.connections = newConnections;\n    self.log('info', util.format('Connection to %s opened successfully', self._address));\n    self.emit('open', null, c);\n  });\n};\n\nHostConnectionPool.prototype.attemptNewConnectionImmediate = function () {\n  var self = this;\n  function openConnection() {\n    self.clearNewConnectionAttempt();\n    self.scheduleNewConnectionAttempt(0);\n  }\n  if (this._state === state.initial) {\n    return openConnection();\n  }\n  if (this._state === state.closing) {\n    return this.once('close', openConnection);\n  }\n  // In the case the pool its being / has been shutdown for good\n  // Do not attempt to create a new connection.\n};\n\n/**\n * Closes the connection and removes a connection from the pool.\n * @param {Connection} connection\n */\nHostConnectionPool.prototype.remove = function (connection) {\n  // locating an object by position in the array is O(n), but normally there should be between 1 to 8 connections.\n  var index = this.connections.indexOf(connection);\n  if (index < 0) {\n    // it was already removed from the connections and it's closing\n    return;\n  }\n  // remove the connection from the pool, using an pool copy\n  var newConnections = this.connections.slice(0);\n  newConnections.splice(index, 1);\n  this.connections = newConnections;\n  // close the connection\n  setImmediate(function removeClose() {\n    connection.close();\n  });\n  this.emit('remove');\n};\n\n/**\n * @param {Number} delay\n */\nHostConnectionPool.prototype.scheduleNewConnectionAttempt = function (delay) {\n  if (this.isClosing()) {\n    return;\n  }\n  var self = this;\n  this._newConnectionTimeout = setTimeout(function newConnectionTimeoutExpired() {\n    self._newConnectionTimeout = null;\n    if (self.connections.length >= self.coreConnectionsLength) {\n      // new connection can be scheduled while a new connection is being opened\n      // the pool has the appropriate size\n      return;\n    }\n    self._attemptNewConnection(utils.noop);\n  }, delay);\n};\n\nHostConnectionPool.prototype.hasScheduledNewConnection = function () {\n  return !!this._newConnectionTimeout || this._opening;\n};\n\n/**\n * Increases the size of the connection pool in the background, if needed.\n */\nHostConnectionPool.prototype.increaseSize = function () {\n  if (this.connections.length < this.coreConnectionsLength && !this.hasScheduledNewConnection()) {\n    // schedule the next connection in the background\n    this.scheduleNewConnectionAttempt(0);\n  }\n};\n\n/**\n * Gets a boolean indicating if the pool is being closed / shutting down or has been shutdown.\n */\nHostConnectionPool.prototype.isClosing = function () {\n  return this._state !== state.initial;\n};\n\n/**\n * Gracefully waits for all in-flight requests to finish and closes the pool.\n */\nHostConnectionPool.prototype.drainAndShutdown = function () {\n  if (this.isClosing()) {\n    // Its already closing / shutting down\n    return;\n  }\n  this._state = state.closing;\n  this.clearNewConnectionAttempt();\n  var self = this;\n  if (this.connections.length === 0) {\n    return this._afterClosing();\n  }\n  var connections = this.connections;\n  this.connections = utils.emptyArray;\n  var closedConnections = 0;\n  this.log('info', util.format('Draining and closing %d connections to %s', connections.length, this._address));\n  for (var i = 0; i < connections.length; i++) {\n    var c = connections[i];\n    if (c.getInFlight() === 0) {\n      getDelayedClose(c)();\n      continue;\n    }\n    c.emitDrain = true;\n    c.once('drain', getDelayedClose(c));\n  }\n  var wasClosed = false;\n  var checkShutdownTimeout;\n  function getDelayedClose(connection) {\n    return (function delayedClose() {\n      connection.close();\n      if (++closedConnections < connections.length) {\n        return;\n      }\n      if (wasClosed) {\n        return;\n      }\n      wasClosed = true;\n      if (checkShutdownTimeout) {\n        clearTimeout(checkShutdownTimeout);\n      }\n      self._afterClosing();\n    });\n  }\n  // Check that after sometime (readTimeout + 100ms) the connections have been drained\n  var delay = (this.options.socketOptions.readTimeout || defaultOptions.socketOptions.readTimeout) + 100;\n  checkShutdownTimeout = setTimeout(function checkShutdown() {\n    wasClosed = true;\n    connections.forEach(function connectionEach(c) {\n      c.close();\n    });\n    self._afterClosing();\n  }, delay);\n};\n\nHostConnectionPool.prototype._afterClosing = function () {\n  var self = this;\n  function resetState() {\n    if (self._state === state.shuttingDown) {\n      self._state = state.shutDown;\n    }\n    else {\n      self._state = state.initial;\n    }\n    self.emit('close');\n  }\n  if (this._creating) {\n    // The pool is being created, reset the state back to init once the creation finished (without any new connection)\n    return this.once('creation', resetState);\n  }\n  if (this._opening) {\n    // The pool is growing, reset the state back to init once the open finished (without any new connection)\n    return this.once('open', resetState);\n  }\n  resetState();\n};\n\n/**\n * @param {Function} callback\n */\nHostConnectionPool.prototype.shutdown = function (callback) {\n  this.clearNewConnectionAttempt();\n  if (!this.connections.length) {\n    this._state = state.shutDown;\n    return callback();\n  }\n  var previousState = this._state;\n  this._state = state.shuttingDown;\n  if (previousState === state.closing) {\n    return this.once('close', callback);\n  }\n  this.once('shutdown', callback);\n  if (previousState === state.shuttingDown) {\n    // Its going to be emitted\n    return;\n  }\n  var self = this;\n  this._closeAllConnections(function closeAllCallback() {\n    self._state = state.shutDown;\n    self.emit('shutdown');\n  });\n};\n\n/** @param {Function} [callback] */\nHostConnectionPool.prototype._closeAllConnections = function (callback) {\n  callback = callback || utils.noop;\n  var connections = this.connections;\n  // point to an empty array\n  this.connections = utils.emptyArray;\n  if (connections.length === 0) {\n    return callback();\n  }\n  this.log('info', util.format('Closing %d connections to %s', connections.length, this._address));\n  utils.each(connections, function closeEach(c, next) {\n    c.close(function closedCallback() {\n      //ignore errors\n      next();\n    });\n  }, callback);\n};\n\nHostConnectionPool.prototype.log = utils.log;\n\nmodule.exports = HostConnectionPool;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/connection.js":"\"use strict\";\nvar net = require('net');\nvar events = require('events');\nvar util = require('util');\nvar tls = require('tls');\n\nvar Encoder = require('./encoder.js');\nvar writers = require('./writers');\nvar requests = require('./requests');\nvar streams = require('./streams');\nvar utils = require('./utils');\nvar types = require('./types');\nvar errors = require('./errors');\nvar StreamIdStack = require('./stream-id-stack');\n\n/**  @const */\nvar idleQuery = 'SELECT key from system.local';\n/**  @const */\nvar maxProtocolVersion = 4;\n/**\n * Represents a connection to a Cassandra node\n * @param {String} endpoint An string containing ip address and port of the host\n * @param {Number} protocolVersion\n * @param {ClientOptions} options\n * @extends EventEmitter\n * @constructor\n */\nfunction Connection(endpoint, protocolVersion, options) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n  if (!endpoint || endpoint.indexOf(':') < 0) {\n    throw new Error('EndPoint must contain the ip address and port separated by : symbol');\n  }\n  this.endpoint = endpoint;\n  var portSeparatorIndex = endpoint.lastIndexOf(':');\n  this.address = endpoint.substr(0, portSeparatorIndex);\n  this.port = endpoint.substr(portSeparatorIndex + 1);\n  Object.defineProperty(this, \"options\", { value: options, enumerable: false, writable: false});\n  if (protocolVersion === null) {\n    //Set initial protocol version\n    protocolVersion = maxProtocolVersion;\n    if (options.protocolOptions.maxVersion > 0 && options.protocolOptions.maxVersion < maxProtocolVersion) {\n      //limit the protocol version\n      protocolVersion = options.protocolOptions.maxVersion;\n    }\n    //Allow to check version using this connection instance\n    this.checkingVersion = true;\n  }\n  this.protocolVersion = protocolVersion;\n  this.streamHandlers = {};\n  this.pendingWrites = [];\n  this.preparing = {};\n  /**\n   * The timeout state for the idle request (heartbeat)\n   */\n  this.idleTimeout = null;\n  this.timedOutHandlers = 0;\n  this.streamIds = new StreamIdStack(this.protocolVersion);\n  this.encoder = new Encoder(protocolVersion, options);\n  this.keyspace = null;\n  this.emitDrain = false;\n  /**\n   * Determines if the socket is open and startup succeeded, whether the connection can be used to send requests / \n   * receive events\n   */\n  this.connected = false;\n  /**\n   * Determines if the socket can be considered as open\n   */\n  this.isSocketOpen = false;\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\nConnection.prototype.log = utils.log;\n\n/**\n * Binds the necessary event listeners for the socket\n */\nConnection.prototype.bindSocketListeners = function() {\n  //Remove listeners that were used for connecting\n  this.netClient.removeAllListeners('connect');\n  this.netClient.removeAllListeners('timeout');\n  // The socket is expected to be open at this point\n  this.isSocketOpen = true;\n  var self = this;\n  this.netClient.on('close', function() {\n    self.log('info', 'Connection to ' + self.endpoint + ' closed');\n    self.isSocketOpen = false;\n    var wasConnected = self.connected;\n    self.close();\n    if (wasConnected) {\n      // Emit only when it was closed unexpectedly\n      self.emit('socketClose');\n    }\n  });\n\n  this.protocol = new streams.Protocol({ objectMode: true });\n  this.parser = new streams.Parser({ objectMode: true }, this.encoder);\n  var resultEmitter = new streams.ResultEmitter({objectMode: true});\n  resultEmitter.on('result', this.handleResult.bind(this));\n  resultEmitter.on('row', this.handleRow.bind(this));\n  resultEmitter.on('frameEnded', this.freeStreamId.bind(this));\n  resultEmitter.on('nodeEvent', this.handleNodeEvent.bind(this));\n\n  this.netClient\n    .pipe(this.protocol)\n    .pipe(this.parser)\n    .pipe(resultEmitter);\n\n  this.writeQueue = new writers.WriteQueue(this.netClient, this.encoder, this.options);\n};\n\n/**\n * Connects a socket and sends the startup protocol messages.\n * Note that when open() callbacks in error, the caller should immediately call {@link Connection#close}.\n */\nConnection.prototype.open = function (callback) {\n  var self = this;\n  this.log('info', 'Connecting to ' + this.address + ':' + this.port);\n  if (!this.options.sslOptions) {\n    this.netClient = new net.Socket();\n    this.netClient.connect(this.port, this.address, function connectCallback() {\n      self.log('verbose', 'Socket connected to ' + self.address + ':' + self.port);\n      self.bindSocketListeners();\n      self.startup(callback);\n    });\n  }\n  else {\n    //use TLS\n    var sslOptions = utils.extend({rejectUnauthorized: false}, this.options.sslOptions);\n    this.netClient = tls.connect(this.port, this.address, sslOptions, function tlsConnectCallback() {\n      self.log('verbose', 'Secure socket connected to ' + self.address + ':' + self.port);\n      self.bindSocketListeners();\n      self.startup(callback);\n    });\n  }\n  this.netClient.once('error', function socketError(err) {\n    self.errorConnecting(err, false, callback);\n  });\n  this.netClient.once('timeout', function connectTimedOut() {\n    var err = new types.DriverError('Connection timeout');\n    self.errorConnecting(err, true, callback);\n  });\n  this.netClient.setTimeout(this.options.socketOptions.connectTimeout);\n  // Improve failure detection with TCP keep-alives\n  if (this.options.socketOptions.keepAlive) {\n    this.netClient.setKeepAlive(true, this.options.socketOptions.keepAliveDelay);\n  }\n  this.netClient.setNoDelay(!!this.options.socketOptions.tcpNoDelay);\n};\n\n/**\n * Determines the protocol version to use and sends the STARTUP request\n * @param {Function} callback\n */\nConnection.prototype.startup = function (callback) {\n  if (this.checkingVersion) {\n    this.log('info', 'Trying to use protocol version ' + this.protocolVersion);\n  }\n  var self = this;\n  this.sendStream(new requests.StartupRequest(), null, function responseCallback(err, response) {\n    if (err && self.checkingVersion && self.protocolVersion > 1) {\n      var invalidProtocol = (err instanceof errors.ResponseError &&\n        err.code === types.responseErrorCodes.protocolError &&\n        err.message.indexOf('Invalid or unsupported protocol version') >= 0);\n      if (!invalidProtocol && self.protocolVersion > 3) {\n        //For some versions of Cassandra, the error is wrapped into a server error\n        //See CASSANDRA-9451\n        invalidProtocol = (err instanceof errors.ResponseError &&\n          err.code === types.responseErrorCodes.serverError &&\n          err.message.indexOf('ProtocolException: Invalid or unsupported protocol version') > 0);\n      }\n      if (invalidProtocol) {\n        self.log('info', 'Protocol v' + self.protocolVersion + ' not supported, using v' + self.protocol.version);\n        self.decreaseVersion();\n        //The host closed the connection, close the socket\n        setImmediate(function decreasingVersionClosing() {\n          self.close(function decreasingVersionOpening() {\n            // Attempt to open with the correct protocol version\n            self.open(callback);\n          });\n        });\n        return;\n      }\n    }\n    if (response && response.mustAuthenticate) {\n      return self.startAuthenticating(response.authenticatorName, startupCallback);\n    }\n    startupCallback(err);\n  });\n\n  function startupCallback(err) {\n    if (err) {\n      return self.errorConnecting(err, false, callback);\n    }\n    //The socket is connected and the connection is authenticated\n    return self.connectionReady(callback);\n  }\n};\n\nConnection.prototype.errorConnecting = function (err, destroy, callback) {\n  this.log('warning', 'There was an error when trying to connect to the host ' + this.address, err);\n  if (destroy) {\n    //there is a TCP connection that should be killed.\n    this.netClient.destroy();\n  }\n  callback(err);\n};\n\n/**\n * Sets the connection to ready/connected status\n */\nConnection.prototype.connectionReady = function (callback) {\n  this.emit('connected');\n  this.connected = true;\n  // Remove existing error handlers as the connection is now ready.\n  this.netClient.removeAllListeners('error');\n  this.netClient.on('error', this.handleSocketError.bind(this));\n  callback();\n};\n\nConnection.prototype.decreaseVersion = function () {\n  // The response already has the max protocol version supported by the Cassandra host.\n  this.protocolVersion = this.protocol.version;\n  this.encoder.setProtocolVersion(this.protocolVersion);\n  this.streamIds.setVersion(this.protocolVersion);\n};\n\n/**\n * Handle socket errors, if the socket is not readable invoke all pending callbacks\n */\nConnection.prototype.handleSocketError = function (err) {\n  this.clearAndInvokePending(err);\n};\n\n/**\n * Cleans all internal state and invokes all pending callbacks of sent streams\n */\nConnection.prototype.clearAndInvokePending = function (innerError) {\n  if (this.idleTimeout) {\n    //Remove the idle request\n    clearTimeout(this.idleTimeout);\n    this.idleTimeout = null;\n  }\n  this.streamIds.clear();\n  if (this.emitDrain) {\n    this.emit('drain');\n  }\n  var err = new types.DriverError('Socket was closed');\n  err.isSocketError = true;\n  if (innerError) {\n    err.innerError = innerError;\n  }\n  //copy all handlers\n  var handlers = utils.objectValues(this.streamHandlers);\n  //remove it from the map\n  this.streamHandlers = {};\n  if (handlers.length > 0) {\n    this.log('info', 'Invoking ' + handlers.length + ' pending callbacks');\n  }\n  var self = this;\n  //invoke all handlers\n  utils.each(handlers, function (item, next) {\n    self.invokeCallback(item, err);\n    next();\n  });\n\n  var pendingWritesCopy = this.pendingWrites;\n  this.pendingWrites = [];\n  utils.each(pendingWritesCopy, function (item, next) {\n    if (!item.callback) {\n      return;\n    }\n    item.callback(err);\n    next();\n  });\n};\n\n/**\n * Starts the SASL flow\n * @param {String} authenticatorName\n * @param {Function} callback\n */\nConnection.prototype.startAuthenticating = function (authenticatorName, callback) {\n  if (!this.options.authProvider) {\n    return callback(new errors.AuthenticationError('Authentication provider not set'));\n  }\n  var authenticator = this.options.authProvider.newAuthenticator(this.endpoint, authenticatorName);\n  var self = this;\n  authenticator.initialResponse(function initialResponseCallback(err, token) {\n    // Start the flow with the initial token\n    if (err) {\n      return callback(err);\n    }\n    self.authenticate(authenticator, token, callback);\n  });\n};\n\n/**\n * Handles authentication requests and responses.\n * @param {Authenticator} authenticator\n * @param {Buffer} token\n * @param {Function} callback\n */\nConnection.prototype.authenticate = function(authenticator, token, callback) {\n  var self = this;\n  var request = new requests.AuthResponseRequest(token);\n  if (this.protocolVersion === 1) {\n    //No Sasl support, use CREDENTIALS\n    //noinspection JSUnresolvedVariable\n    if (!authenticator.username) {\n      return callback(new errors.AuthenticationError('Only plain text authenticator providers allowed under protocol v1'));\n    }\n    //noinspection JSUnresolvedVariable\n    request = new requests.CredentialsRequest(authenticator.username, authenticator.password);\n  }\n  this.sendStream(request, null, function authResponseCallback(err, result) {\n    if (err) {\n      if (err instanceof errors.ResponseError && err.code === types.responseErrorCodes.badCredentials) {\n        var authError = new errors.AuthenticationError(err.message);\n        authError.additionalInfo = err;\n        err = authError;\n      }\n      return callback(err);\n    }\n    if (result.ready) {\n      authenticator.onAuthenticationSuccess();\n      return callback();\n    }\n    if (result.authChallenge) {\n      return authenticator.evaluateChallenge(result.token, function evaluateCallback(err, t) {\n        if (err) {\n          return callback(err);\n        }\n        //here we go again\n        self.authenticate(authenticator, t, callback);\n      });\n    }\n    callback(new errors.DriverInternalError('Unexpected response from Cassandra: ' + util.inspect(result)));\n  });\n};\n\n/**\n * Executes a 'USE ' query, if keyspace is provided and it is different from the current keyspace\n * @param {?String} keyspace\n * @param {Function} callback\n */\nConnection.prototype.changeKeyspace = function (keyspace, callback) {\n  if (!keyspace || this.keyspace === keyspace) {\n    return callback();\n  }\n  this.once('keyspaceChanged', callback);\n  if (this.toBeKeyspace === keyspace) {\n    // It will be invoked once the keyspace is changed\n    return;\n  }\n  this.toBeKeyspace = keyspace;\n  var query = util.format('USE \"%s\"', keyspace);\n  var self = this;\n  this.sendStream(\n    new requests.QueryRequest(query, null, null),\n    null,\n    function changeKeyspaceResponseCallback(err) {\n      if (!err) {\n        self.keyspace = keyspace;\n      }\n      self.toBeKeyspace = null;\n      self.emit('keyspaceChanged', err, keyspace);\n    });\n};\n\n/**\n * Prepares a query on a given connection. If its already being prepared, it queues the callback.\n * @param {String} query\n * @param {function} callback\n */\nConnection.prototype.prepareOnce = function (query, callback) {\n  var name = ( this.keyspace || '' ) + query;\n  var info = this.preparing[name];\n  if (this.preparing[name]) {\n    //Its being already prepared\n    return info.once('prepared', callback);\n  }\n  info = new events.EventEmitter();\n  info.setMaxListeners(0);\n  info.once('prepared', callback);\n  this.preparing[name] = info;\n  var self = this;\n  this.sendStream(new requests.PrepareRequest(query), null, function (err, response) {\n    info.emit('prepared', err, response);\n    delete self.preparing[name];\n  });\n};\n\n/**\n * Uses the frame writer to write into the wire\n * @param request\n * @param {QueryOptions|null} options\n * @param {function} callback Function to be called once the response has been received\n */\nConnection.prototype.sendStream = function (request, options, callback) {\n  var self = this;\n  var streamId = this.getStreamId();\n  if (streamId === null) {\n    self.log('info',\n        'Enqueuing ' +\n        this.pendingWrites.length +\n        ', if this message is recurrent consider configuring more connections per host or lowering the pressure');\n    return this.pendingWrites.push({request: request, options: options, callback: callback});\n  }\n  this.log('verbose', 'Sending stream #' + streamId);\n  request.streamId = streamId;\n  request.version = this.protocolVersion;\n  this.writeQueue.push(request, this.getWriteCallback(request, options, callback));\n};\n\n/**\n * Returns the write callback\n * @param request\n * @param options\n * @param {Function} callback\n * @returns {Function}\n */\nConnection.prototype.getWriteCallback = function (request, options, callback) {\n  var self = this;\n  return (function writeCallback (err) {\n    if (err) {\n      return callback(err);\n    }\n    self.log('verbose', 'Sent stream #' + request.streamId + ' to ' + self.endpoint);\n    if (options && options.rowCallback) {\n      if (request instanceof requests.ExecuteRequest || request instanceof requests.QueryRequest) {\n        self.parser.setOptions(request.streamId, { byRow: true });\n      }\n    }\n    if (self.options.pooling.heartBeatInterval) {\n      // scheduling the new timeout before de-scheduling the previous performs significantly better\n      // than de-scheduling first, see nodejs implementation: https://github.com/nodejs/node/blob/master/lib/timers.js\n      var previousTimeout = self.idleTimeout;\n      self.idleTimeout = setTimeout(function () {\n        self.idleTimeoutHandler();\n      }, self.options.pooling.heartBeatInterval);\n      if (previousTimeout) {\n        //remove the previous timeout for the idle request\n        clearTimeout(previousTimeout);\n      }\n    }\n    //noinspection JSUnresolvedVariable\n    self.streamHandlers[request.streamId] = {\n      callback: callback,\n      rowCallback: options && options.rowCallback,\n      options: options,\n      timeout: self.setRequestTimeout(request, options)\n    };\n  });\n};\n\n/**\n * Function that gets executed once the idle timeout has passed to issue a request to keep the connection alive\n */\nConnection.prototype.idleTimeoutHandler = function () {\n  var self = this;\n  if (this.sendingIdleQuery) {\n    //don't issue another\n    //schedule for next time\n    this.idleTimeout = setTimeout(function () {\n      self.idleTimeoutHandler();\n    }, this.options.pooling.heartBeatInterval);\n    return;\n  }\n  this.log('verbose', 'Connection idling, issuing a Request to prevent idle disconnects');\n  this.sendingIdleQuery = true;\n  this.sendStream(new requests.QueryRequest(idleQuery), utils.emptyObject, function (err) {\n    self.sendingIdleQuery = false;\n    if (!err) {\n      //The sending succeeded\n      //There is a valid response but we don't care about the response\n      return;\n    }\n    self.log('warning', 'Received heartbeat request error', err);\n    self.emit('idleRequestError', err, self);\n  });\n};\n\n/**\n * Returns an available streamId or null if there isn't any available\n * @returns {Number}\n */\nConnection.prototype.getStreamId = function() {\n  return this.streamIds.pop();\n};\n\nConnection.prototype.freeStreamId = function(header) {\n  var streamId = header.streamId;\n  if (streamId < 0) {\n    return;\n  }\n  delete this.streamHandlers[streamId];\n  this.streamIds.push(streamId);\n  if (this.emitDrain && this.streamIds.inUse === 0 && this.pendingWrites.length === 0) {\n    this.emit('drain');\n  }\n  this.writeNext();\n  this.log('verbose', 'Done receiving frame #' + streamId);\n};\n\nConnection.prototype.writeNext = function () {\n  var self = this;\n  setImmediate(function writeNextPending() {\n    var pending = self.pendingWrites.shift();\n    if (!pending) {\n      return;\n    }\n    self.sendStream(pending.request, pending.options, pending.callback);\n  });\n};\n\n/**\n * Returns the number of requests waiting for response\n * @returns {Number}\n */\nConnection.prototype.getInFlight = function () {\n  return this.streamIds.inUse;\n};\n\n/**\n * Handles a result and error response\n */\nConnection.prototype.handleResult = function (header, err, result) {\n  var streamId = header.streamId;\n  if(streamId < 0) {\n    return this.log('verbose', 'event received', header);\n  }\n  var handler = this.streamHandlers[streamId];\n  if (!handler) {\n    return this.log('error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  this.log('verbose', 'Received frame #' + streamId + ' from ' + this.endpoint);\n  this.invokeCallback(handler, err, result);\n};\n\nConnection.prototype.handleNodeEvent = function (header, event) {\n  switch (event.eventType) {\n    case types.protocolEvents.schemaChange:\n      this.emit('nodeSchemaChange', event);\n      break;\n    case types.protocolEvents.topologyChange:\n      this.emit('nodeTopologyChange', event);\n      break;\n    case types.protocolEvents.statusChange:\n      this.emit('nodeStatusChange', event);\n      break;\n  }\n};\n\n/**\n * Handles a row response\n */\nConnection.prototype.handleRow = function (header, row, meta, rowLength, flags) {\n  var streamId = header.streamId;\n  if(streamId < 0) {\n    return this.log('verbose', 'Event received', header);\n  }\n  var handler = this.streamHandlers[streamId];\n  if (!handler) {\n    return this.log('error', 'The server replied with a wrong streamId #' + streamId);\n  }\n  this.log('verbose', 'Received streaming frame #' + streamId);\n  if (handler.timeout) {\n    //It started receiving, clear the read timeout\n    clearTimeout(handler.timeout);\n    handler.timeout = null;\n  }\n  if (!handler.rowCallback) {\n    return this.invokeCallback(\n      handler,\n      new errors.DriverInternalError('RowCallback not found for streaming frame handler'));\n  }\n  handler.rowIndex = handler.rowIndex || 0;\n  handler.rowCallback(handler.rowIndex++, row, rowLength);\n  if (handler.rowIndex === rowLength) {\n    this.invokeCallback(handler, null, { rowLength: rowLength, meta: meta, flags: flags });\n  }\n};\n\n/**\n * Invokes the handler callback and clears the callback and timers\n * @param {{callback, timeout}} handler\n * @param {Error} err\n * @param [response]\n */\nConnection.prototype.invokeCallback = function (handler, err, response) {\n  var callback = handler.callback;\n  //Prevent chained invocations\n  handler.callback = null;\n  if (handler.timeout) {\n    clearTimeout(handler.timeout);\n    handler.timeout = null;\n  }\n  if (callback) {\n    callback(err, response);\n  }\n};\n\n/**\n * Creates a timeout for the given request and returns the timeout object.\n * @param request\n * @param {QueryOptions} options\n * @returns {Object} The timeout object\n */\nConnection.prototype.setRequestTimeout = function (request, options) {\n  var millis = (options && options.readTimeout !== undefined) ? options.readTimeout : this.options.socketOptions.readTimeout;\n  if (!(millis > 0)) {\n    //read timeout disabled\n    return null;\n  }\n  var self = this;\n  return setTimeout(function () {\n    self.onTimeout(request.streamId, millis);\n  }, millis);\n};\n\n/**\n * Executed on request timeout, it callbacks with OperationTimedOutError and clears the closures\n */\nConnection.prototype.onTimeout = function (streamId, millis) {\n  var handler = this.streamHandlers[streamId];\n  if (!handler || !handler.callback) {\n    //it's being cleared, don't mind\n    return;\n  }\n  this.timedOutHandlers++;\n  var originalCallback = handler.callback;\n  var self = this;\n  //clear callback closures\n  handler.callback = function replyAfterTimeout() {\n    //if replies, remove from timedOutQueries\n    self.timedOutHandlers--;\n  };\n  if (handler.rowCallback) {\n    handler.rowCallback = function noop() {};\n  }\n  var message = util.format('The host %s did not reply before timeout %d ms', this.endpoint, millis);\n  originalCallback(new errors.OperationTimedOutError(message));\n};\n\n/**\n * Closes the socket (if not already closed) and cancels all in-flight requests.\n * Multiple calls to this method have no additional side-effects.\n * @param {Function} [callback]\n */\nConnection.prototype.close = function (callback) {\n  callback = callback || utils.noop;\n  if (!this.connected && !this.isSocketOpen) {\n    return callback();\n  }\n  this.connected = false;\n  // Drain is never going to be emitted, once it is set to closed\n  this.removeAllListeners('drain');\n  this.clearAndInvokePending();\n  if (!this.isSocketOpen) {\n    return callback();\n  }\n  // Set the socket as closed now (before socket.end() is called) to avoid being invoked more than once\n  this.isSocketOpen = false;\n  this.log('verbose', 'Closing connection to ' + this.endpoint);\n  var self = this;\n  this.netClient.once('close', function (hadError) {\n    if (hadError) {\n      self.log('info', 'The socket closed with a transmission error');\n    }\n    setImmediate(callback);\n  });\n  // Prevent 'error' listener to be executed before 'close' listener\n  this.netClient.removeAllListeners('error');\n  // Add a noop handler for 'error' event to prevent Socket to throw the error\n  this.netClient.on('error', utils.noop);\n  // Half-close the socket, it will result in 'close' event being fired\n  this.netClient.end();\n};\n\nmodule.exports = Connection;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/encoder.js":"\"use strict\";\nvar util = require('util');\n\nvar types = require('./types');\nvar dataTypes = types.dataTypes;\nvar Long = types.Long;\nvar Integer = types.Integer;\nvar BigDecimal = types.BigDecimal;\nvar utils = require('./utils');\n\nvar uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nvar int16Zero = new Buffer([0, 0]);\nvar int32Zero = new Buffer([0, 0, 0, 0]);\nvar complexTypeNames = Object.freeze({\n  list      : 'org.apache.cassandra.db.marshal.ListType',\n  set       : 'org.apache.cassandra.db.marshal.SetType',\n  map       : 'org.apache.cassandra.db.marshal.MapType',\n  udt       : 'org.apache.cassandra.db.marshal.UserType',\n  tuple     : 'org.apache.cassandra.db.marshal.TupleType',\n  frozen    : 'org.apache.cassandra.db.marshal.FrozenType',\n  reversed  : 'org.apache.cassandra.db.marshal.ReversedType',\n  composite : 'org.apache.cassandra.db.marshal.CompositeType',\n  empty     : 'org.apache.cassandra.db.marshal.EmptyType',\n  collection: 'org.apache.cassandra.db.marshal.ColumnToCollectionType'\n});\nvar cqlNames = Object.freeze({\n  frozen: 'frozen',\n  list: 'list',\n  'set': 'set',\n  map: 'map',\n  tuple: 'tuple',\n  empty: 'empty'\n});\nvar singleTypeNames = Object.freeze({\n  'org.apache.cassandra.db.marshal.UTF8Type':           dataTypes.varchar,\n  'org.apache.cassandra.db.marshal.AsciiType':          dataTypes.ascii,\n  'org.apache.cassandra.db.marshal.UUIDType':           dataTypes.uuid,\n  'org.apache.cassandra.db.marshal.TimeUUIDType':       dataTypes.timeuuid,\n  'org.apache.cassandra.db.marshal.Int32Type':          dataTypes.int,\n  'org.apache.cassandra.db.marshal.BytesType':          dataTypes.blob,\n  'org.apache.cassandra.db.marshal.FloatType':          dataTypes.float,\n  'org.apache.cassandra.db.marshal.DoubleType':         dataTypes.double,\n  'org.apache.cassandra.db.marshal.BooleanType':        dataTypes.boolean,\n  'org.apache.cassandra.db.marshal.InetAddressType':    dataTypes.inet,\n  'org.apache.cassandra.db.marshal.SimpleDateType':     dataTypes.date,\n  'org.apache.cassandra.db.marshal.TimeType':           dataTypes.time,\n  'org.apache.cassandra.db.marshal.ShortType':          dataTypes.smallint,\n  'org.apache.cassandra.db.marshal.ByteType':           dataTypes.tinyint,\n  'org.apache.cassandra.db.marshal.DateType':           dataTypes.timestamp,\n  'org.apache.cassandra.db.marshal.TimestampType':      dataTypes.timestamp,\n  'org.apache.cassandra.db.marshal.LongType':           dataTypes.bigint,\n  'org.apache.cassandra.db.marshal.DecimalType':        dataTypes.decimal,\n  'org.apache.cassandra.db.marshal.IntegerType':        dataTypes.varint,\n  'org.apache.cassandra.db.marshal.CounterColumnType':  dataTypes.counter\n});\nvar singleFqTypeNamesLength = Object.keys(singleTypeNames).reduce(function (previous, current) {\n  return current.length > previous ? current.length : previous;\n}, 0);\nvar nullValueBuffer = new Buffer([255, 255, 255, 255]);\nvar unsetValueBuffer = new Buffer([255, 255, 255, 254]);\n\n/**\n * Serializes and deserializes to and from a CQL type and a Javascript Type.\n * @param {Number} protocolVersion\n * @param {ClientOptions} options\n * @constructor\n */\nfunction Encoder(protocolVersion, options) {\n  this.encodingOptions = options.encoding || utils.emptyObject;\n  defineInstanceMembers.call(this);\n  this.setProtocolVersion(protocolVersion);\n  setEncoders.call(this);\n  if (this.encodingOptions.copyBuffer) {\n    this.handleBuffer = handleBufferCopy;\n  }\n  else {\n    this.handleBuffer = handleBufferRef;\n  }\n}\n\n/**\n * Declares the privileged instance members.\n * @private\n */\nfunction defineInstanceMembers() {\n  /**\n   * Sets the protocol version and the encoding/decoding methods depending on the protocol version\n   * @param {Number} value\n   * @ignore\n   * @internal\n   */\n  this.setProtocolVersion = function (value) {\n    this.protocolVersion = value;\n    //Set the collection serialization based on the protocol version\n    this.decodeCollectionLength = decodeCollectionLengthV3;\n    this.getLengthBuffer = getLengthBufferV3;\n    this.collectionLengthSize = 4;\n    if (this.protocolVersion < 3) {\n      this.decodeCollectionLength = decodeCollectionLengthV2;\n      this.getLengthBuffer = getLengthBufferV2;\n      this.collectionLengthSize = 2;\n    }\n  };\n  //Decoding methods\n  this.decodeBlob = function (bytes) {\n    return this.handleBuffer(bytes);\n  };\n  this.decodeUtf8String = function (bytes) {\n    return bytes.toString('utf8');\n  };\n  this.decodeAsciiString = function (bytes) {\n    return bytes.toString('ascii');\n  };\n  this.decodeBoolean = function (bytes) {\n    return !!bytes.readUInt8(0);\n  };\n  this.decodeDouble = function (bytes) {\n    return bytes.readDoubleBE(0);\n  };\n  this.decodeFloat = function (bytes) {\n    return bytes.readFloatBE(0);\n  };\n  this.decodeInt = function (bytes) {\n    return bytes.readInt32BE(0);\n  };\n  this.decodeSmallint = function (bytes) {\n    return bytes.readInt16BE(0);\n  };\n  this.decodeTinyint = function (bytes) {\n    return bytes.readInt8(0);\n  };\n  this.decodeLong = function (bytes) {\n    return Long.fromBuffer(bytes);\n  };\n  this.decodeVarint = function (bytes) {\n    return Integer.fromBuffer(bytes);\n  };\n  this.decodeDecimal = function(bytes) {\n    return BigDecimal.fromBuffer(bytes);\n  };\n  this.decodeTimestamp = function(bytes) {\n    return new Date(this.decodeLong(bytes).toNumber());\n  };\n  this.decodeDate = function (bytes) {\n    return types.LocalDate.fromBuffer(bytes);\n  };\n  this.decodeTime = function (bytes) {\n    return types.LocalTime.fromBuffer(bytes);\n  };\n  /*\n   * Reads a list from bytes\n   */\n  this.decodeList = function (bytes, subtype) {\n    var totalItems = this.decodeCollectionLength(bytes, 0);\n    var offset = this.collectionLengthSize;\n    var list = new Array(totalItems);\n    for(var i = 0; i < totalItems; i++) {\n      //bytes length of the item\n      var length = this.decodeCollectionLength(bytes, offset);\n      offset += this.collectionLengthSize;\n      //slice it\n      list[i] = this.decode(bytes.slice(offset, offset+length), subtype);\n      offset += length;\n    }\n    return list;\n  };\n  /*\n   * Reads a Set from bytes\n   */\n  this.decodeSet = function (bytes, subtype) {\n    var arr = this.decodeList(bytes, subtype);\n    if (this.encodingOptions.set) {\n      var setConstructor = this.encodingOptions.set;\n      return new setConstructor(arr);\n    }\n    return arr;\n  };\n  /*\n   * Reads a map (key / value) from bytes\n   */\n  this.decodeMap = function (bytes, subtypes) {\n    var map;\n    var totalItems = this.decodeCollectionLength(bytes, 0);\n    var offset = this.collectionLengthSize;\n    var self = this;\n    function readValues(callback, thisArg) {\n      for (var i = 0; i < totalItems; i++) {\n        var keyLength = self.decodeCollectionLength(bytes, offset);\n        offset += self.collectionLengthSize;\n        var key = self.decode(bytes.slice(offset, offset + keyLength), subtypes[0]);\n        offset += keyLength;\n        var valueLength = self.decodeCollectionLength(bytes, offset);\n        offset += self.collectionLengthSize;\n        if (valueLength <= 0) {\n          callback.call(thisArg, key, null);\n          continue;\n        }\n        var value = self.decode(bytes.slice(offset, offset + valueLength), subtypes[1]);\n        offset += valueLength;\n        callback.call(thisArg, key, value);\n      }\n    }\n    if (this.encodingOptions.map) {\n      var mapConstructor = this.encodingOptions.map;\n      map = new mapConstructor();\n      readValues(map.set, map);\n    }\n    else {\n      map = {};\n      readValues(function (key, value) {\n        map[key] = value;\n      });\n    }\n    return map;\n  };\n  this.decodeUuid = function (bytes) {\n    return new types.Uuid(this.handleBuffer(bytes));\n  };\n  this.decodeTimeUuid = function (bytes) {\n    return new types.TimeUuid(this.handleBuffer(bytes));\n  };\n  this.decodeInet = function (bytes) {\n    return new types.InetAddress(this.handleBuffer(bytes));\n  };\n  /**\n   * Decodes a user defined type into an object\n   * @param {Buffer} bytes\n   * @param {{fields: Array}} udtInfo\n   * @private\n   */\n  this.decodeUdt = function (bytes, udtInfo) {\n    var result = {};\n    var offset = 0;\n    for (var i = 0; i < udtInfo.fields.length && offset < bytes.length; i++) {\n      //bytes length of the field value\n      var length = bytes.readInt32BE(offset);\n      offset += 4;\n      //slice it\n      var field = udtInfo.fields[i];\n      if (length < 0) {\n        result[field.name] = null;\n        continue;\n      }\n      result[field.name] = this.decode(bytes.slice(offset, offset+length), field.type);\n      offset += length;\n    }\n    return result;\n  };\n  this.decodeTuple = function (bytes, tupleInfo) {\n    var elements = new Array(tupleInfo.length);\n    var offset = 0;\n    for (var i = 0; i < tupleInfo.length; i++) {\n      var length = bytes.readInt32BE(offset);\n      offset += 4;\n      if (length < 0) {\n        elements[i] = null;\n        continue;\n      }\n      elements[i] = this.decode(bytes.slice(offset, offset+length), tupleInfo[i]);\n      offset += length;\n    }\n    return new types.Tuple(elements);\n  };\n  //Encoding methods\n  this.encodeFloat = function (value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    var buf = new Buffer(4);\n    buf.writeFloatBE(value, 0);\n    return buf;\n  };\n  this.encodeDouble = function (value) {\n    if (typeof value !== 'number') {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    var buf = new Buffer(8);\n    buf.writeDoubleBE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Date|String|Long|Number} value\n   * @private\n   */\n  this.encodeTimestamp = function (value) {\n    var originalValue = value;\n    if (typeof value === 'string') {\n      value = new Date(value);\n    }\n    if (value instanceof Date) {\n      //milliseconds since epoch\n      value = value.getTime();\n      if (isNaN(value)) {\n        throw new TypeError('Invalid date: ' + originalValue);\n      }\n    }\n    //noinspection JSCheckFunctionSignatures\n    return this.encodeLong(value);\n  };\n  /**\n   * @param {Date|String|LocalDate} value\n   * @returns {Buffer}\n   * @throws {TypeError}\n   * @private\n   */\n  this.encodeDate = function (value) {\n    var originalValue = value;\n    try {\n      if (typeof value === 'string') {\n        value = types.LocalDate.fromString(value);\n      }\n      if (value instanceof Date) {\n        value = types.LocalDate.fromDate(value);\n      }\n    }\n    catch (err) {\n      //Wrap into a TypeError\n      throw new TypeError('LocalDate could not be parsed ' + err);\n    }\n    if (!(value instanceof types.LocalDate)) {\n      throw new TypeError('Expected Date/String/LocalDate, obtained ' + util.inspect(originalValue));\n    }\n    return value.toBuffer();\n  };\n  /**\n   * @param {String|LocalDate} value\n   * @returns {Buffer}\n   * @throws {TypeError}\n   * @private\n   */\n  this.encodeTime = function (value) {\n    var originalValue = value;\n    try {\n      if (typeof value === 'string') {\n        value = types.LocalTime.fromString(value);\n      }\n    }\n    catch (err) {\n      //Wrap into a TypeError\n      throw new TypeError('LocalTime could not be parsed ' + err);\n    }\n    if (!(value instanceof types.LocalTime)) {\n      throw new TypeError('Expected String/LocalTime, obtained ' + util.inspect(originalValue));\n    }\n    return value.toBuffer();\n  };\n  /**\n   * @param {Uuid|String|Buffer} value\n   * @private\n   */\n  this.encodeUuid = function (value) {\n    if (typeof value === 'string') {\n      try {\n        value = types.Uuid.fromString(value);\n      }\n      catch (err) {\n        throw new TypeError(err.message);\n      }\n    }\n    if (value instanceof types.Uuid) {\n      value = value.getBuffer();\n    }\n    if (!(value instanceof Buffer)) {\n      throw new TypeError('Not a valid Uuid, expected Uuid/String/Buffer, obtained ' + util.inspect(value));\n    }\n    return value;\n  };\n  /**\n   * @param {String|InetAddress|Buffer} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeInet = function (value) {\n    if (typeof value === 'string') {\n      value = types.InetAddress.fromString(value);\n    }\n    if (value instanceof types.InetAddress) {\n      value = value.getBuffer();\n    }\n    if (!(value instanceof Buffer)) {\n      throw new TypeError('Not a valid Inet, expected InetAddress/Buffer, obtained ' + util.inspect(value));\n    }\n    return value;\n  };\n  /**\n   * @param {Long|Buffer|String|Number} value\n   * @private\n   */\n  this.encodeLong = function (value) {\n    if (typeof value === 'number') {\n      value = Long.fromNumber(value);\n    }\n    if (typeof value === 'string') {\n      value = Long.fromString(value);\n    }\n    var buf = null;\n    if (value instanceof Buffer) {\n      buf = value;\n    }\n    if (value instanceof Long) {\n      //noinspection JSCheckFunctionSignatures\n      buf = Long.toBuffer(value);\n    }\n    if (buf === null) {\n      throw new TypeError('Not a valid bigint, expected Long/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n    return buf;\n  };\n  /**\n   * @param {Integer|Buffer|String|Number} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeVarint = function (value) {\n    if (typeof value === 'number') {\n      value = Integer.fromNumber(value);\n    }\n    if (typeof value === 'string') {\n      value = Integer.fromString(value);\n    }\n    var buf = null;\n    if (value instanceof Buffer) {\n      buf = value;\n    }\n    if (value instanceof Integer) {\n      buf = Integer.toBuffer(value);\n    }\n    if (buf === null) {\n      throw new TypeError('Not a valid varint, expected Integer/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n    return buf;\n  };\n  /**\n   * @param {BigDecimal|Buffer|String|Number} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeDecimal = function (value) {\n    if (typeof value === 'number') {\n      value = BigDecimal.fromNumber(value);\n    }\n    if (typeof value === 'string') {\n      value = BigDecimal.fromString(value);\n    }\n    var buf = null;\n    if (value instanceof Buffer) {\n      buf = value;\n    }\n    if (value instanceof BigDecimal) {\n      buf = BigDecimal.toBuffer(value);\n    }\n    if (buf === null) {\n      throw new TypeError('Not a valid varint, expected BigDecimal/Number/String/Buffer, obtained ' + util.inspect(value));\n    }\n    return buf;\n  };\n  this.encodeString = function (value, encoding) {\n    if (typeof value !== 'string') {\n      throw new TypeError('Not a valid text value, expected String obtained ' + util.inspect(value));\n    }\n    return new Buffer(value, encoding);\n  };\n  this.encodeUtf8String = function (value) {\n    return this.encodeString(value, 'utf8');\n  };\n  this.encodeAsciiString = function (value) {\n    return this.encodeString(value, 'ascii');\n  };\n  this.encodeBlob = function (value) {\n    if (!(value instanceof Buffer)) {\n      throw new TypeError('Not a valid blob, expected Buffer obtained ' + util.inspect(value));\n    }\n    return value;\n  };\n  /**\n   * @param {Boolean} value\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeBoolean = function (value) {\n    return new Buffer([(value ? 1 : 0)]);\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeInt = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    var buf = new Buffer(4);\n    buf.writeInt32BE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeSmallint = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    var buf = new Buffer(2);\n    buf.writeInt16BE(value, 0);\n    return buf;\n  };\n  /**\n   * @param {Number|String} value\n   * @private\n   */\n  this.encodeTinyint = function (value) {\n    if (isNaN(value)) {\n      throw new TypeError('Expected Number, obtained ' + util.inspect(value));\n    }\n    var buf = new Buffer(1);\n    buf.writeInt8(value, 0);\n    return buf;\n  };\n  this.encodeList = function (value, subtype) {\n    if (!util.isArray(value)) {\n      throw new TypeError('Not a valid list value, expected Array obtained ' + util.inspect(value));\n    }\n    if (value.length === 0) {\n      return null;\n    }\n    var parts = [];\n    parts.push(this.getLengthBuffer(value));\n    for (var i=0;i < value.length;i++) {\n      var val = value[i];\n      if (val === null || typeof val === 'undefined' || val === types.unset) {\n        throw new TypeError('A collection can\\'t contain null or unset values');\n      }\n      var bytes = this.encode(val, subtype);\n      //include item byte length\n      parts.push(this.getLengthBuffer(bytes));\n      //include item\n      parts.push(bytes);\n    }\n    return Buffer.concat(parts);\n  };\n  this.encodeSet = function (value, subtype) {\n    if (this.encodingOptions.set && value instanceof this.encodingOptions.set) {\n      var arr = [];\n      value.forEach(function (x) {\n        arr.push(x);\n      });\n      return this.encodeList(arr, subtype);\n    }\n    return this.encodeList(value, subtype);\n  };\n  /**\n   * Serializes a map into a Buffer\n   * @param value\n   * @param {Array} [subtypes]\n   * @returns {Buffer}\n   * @private\n   */\n  this.encodeMap = function (value, subtypes) {\n    var parts = [];\n    var propCounter = 0;\n    var keySubtype = null;\n    var valueSubtype = null;\n    var self = this;\n    if (subtypes) {\n      keySubtype = subtypes[0];\n      valueSubtype = subtypes[1];\n    }\n    function addItem(val, key) {\n      if (key === null || typeof key === 'undefined' || key === types.unset) {\n        throw new TypeError('A map can\\'t contain null or unset keys');\n      }\n      if (val === null || typeof val === 'undefined' || val === types.unset) {\n        throw new TypeError('A map can\\'t contain null or unset values');\n      }\n      var keyBuffer = self.encode(key, keySubtype);\n      //include item byte length\n      parts.push(self.getLengthBuffer(keyBuffer));\n      //include item\n      parts.push(keyBuffer);\n      //value\n      var valueBuffer = self.encode(val, valueSubtype);\n      //include item byte length\n      parts.push(self.getLengthBuffer(valueBuffer));\n      //include item\n      if (valueBuffer !== null) {\n        parts.push(valueBuffer);\n      }\n      propCounter++;\n    }\n    if (this.encodingOptions.map && value instanceof this.encodingOptions.map) {\n      //Use Map#forEach() method to iterate\n      value.forEach(addItem);\n    }\n    else {\n      //Use object\n      for (var key in value) {\n        if (!value.hasOwnProperty(key)) {\n          continue;\n        }\n        var val = value[key];\n        addItem(val, key);\n      }\n    }\n\n    parts.unshift(this.getLengthBuffer(propCounter));\n    return Buffer.concat(parts);\n  };\n  this.encodeUdt = function (value, udtInfo) {\n    var parts = [];\n    var totalLength = 0;\n    for (var i = 0; i < udtInfo.fields.length; i++) {\n      var field = udtInfo.fields[i];\n      var item = this.encode(value[field.name], field.type);\n      if (!item) {\n        parts.push(nullValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      if (item === types.unset) {\n        parts.push(unsetValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      var lengthBuffer = new Buffer(4);\n      lengthBuffer.writeInt32BE(item.length, 0);\n      parts.push(lengthBuffer);\n      parts.push(item);\n      totalLength += item.length + 4;\n    }\n    return Buffer.concat(parts, totalLength);\n  };\n  this.encodeTuple = function (value, tupleInfo) {\n    var parts = [];\n    var totalLength = 0;\n    for (var i = 0; i < tupleInfo.length; i++) {\n      var type = tupleInfo[i];\n      var item = this.encode(value.get(i), type);\n      if (!item) {\n        parts.push(nullValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      if (item === types.unset) {\n        parts.push(unsetValueBuffer);\n        totalLength += 4;\n        continue;\n      }\n      var lengthBuffer = new Buffer(4);\n      lengthBuffer.writeInt32BE(item.length, 0);\n      parts.push(lengthBuffer);\n      parts.push(item);\n      totalLength += item.length + 4;\n    }\n    return Buffer.concat(parts, totalLength);\n  };\n\n  /**\n   * If not provided, it uses the array of buffers or the parameters and hints to build the routingKey\n   * @param {Array} params\n   * @param {QueryOptions} options\n   * @param [keys] parameter keys and positions\n   * @throws TypeError\n   * @internal\n   * @ignore\n   */\n  this.setRoutingKey = function (params, options, keys) {\n    var totalLength;\n    if (util.isArray(options.routingKey)) {\n      if (options.routingKey.length === 1) {\n        options.routingKey = options.routingKey[0];\n        return;\n      }\n      //Is a Composite key\n      totalLength = 0;\n      for (var i = 0; i < options.routingKey.length; i++) {\n        var item = options.routingKey[i];\n        if (!item) {\n          //An routing key part may be null/undefined if provided by user\n          //Or when there is a hardcoded parameter in the query\n          //Clear the routing key\n          options.routingKey = null;\n          return;\n        }\n        totalLength += item.length + 3;\n      }\n      //Set the buffer containing the contents of the previous Array of buffers as routing key\n      options.routingKey = concatRoutingKey(options.routingKey, totalLength);\n      return;\n    }\n    if (options.routingKey instanceof Buffer || !params || params.length === 0) {\n      //There is already a routing key\n      // or no parameter indexes for routing were provided\n      // or there are no parameters to build the routing key\n      return;\n    }\n    var parts = [];\n    totalLength = 0;\n    if (options.routingIndexes) {\n      totalLength = this._encodeRoutingKeyParts(parts, options.routingIndexes, params, options.hints);\n    }\n    if (options.routingNames && keys) {\n      totalLength = this._encodeRoutingKeyParts(parts, options.routingNames, params, options.hints, keys);\n    }\n    if (totalLength === 0) {\n      options.routingKey = null;\n      return;\n    }\n    if (parts.length === 1) {\n      options.routingKey = parts[0];\n      return;\n    }\n    //its a composite partition key\n    options.routingKey = concatRoutingKey(parts, totalLength);\n  };\n\n  /**\n   * @param {Array} parts\n   * @param {Array} routingIndexes\n   * @param {Array} params\n   * @param {Array} hints\n   * @param {Object} [keys]\n   * @returns {Number} The total length\n   * @private\n   */\n  this._encodeRoutingKeyParts = function (parts, routingIndexes, params, hints, keys) {\n    hints = hints || utils.emptyArray;\n    var totalLength = 0;\n    for (var i = 0; i < routingIndexes.length; i++) {\n      var paramIndex = routingIndexes[i];\n      if (typeof paramIndex === 'undefined') {\n        //probably undefined (parameter not found) or bad input from the user\n        return 0;\n      }\n      if (keys) {\n        //is composed of parameter names\n        paramIndex = keys[paramIndex];\n      }\n      var item = this.encode(params[paramIndex], hints[paramIndex]);\n      if (!item) {\n        //bad input from the user\n        return 0;\n      }\n      totalLength += item.length + 3;\n      parts.push(item);\n    }\n    return totalLength;\n  };\n  /**\n   * Parses a CQL name string into data type information\n   * @param {String} keyspace\n   * @param {String} typeName\n   * @param {Number} startIndex\n   * @param {Number|null} length\n   * @param {Function} udtResolver\n   * @param {Function} callback Callback invoked with err and  {{code: number, info: Object|Array|null, options: {frozen: Boolean}}}\n   * @internal\n   * @ignore\n   */\n  this.parseTypeName = function (keyspace, typeName, startIndex, length, udtResolver, callback) {\n    startIndex = startIndex || 0;\n    if (!length) {\n      length = typeName.length;\n    }\n    var dataType = {\n      code: 0,\n      info: null,\n      options: {\n        frozen: false\n      }\n    };\n    var innerTypes;\n    if (typeName.indexOf(\"'\", startIndex) === startIndex) {\n      //If quoted, this is a custom type.\n      dataType.info = typeName.substr(startIndex+1, length-2);\n      return callback(null, dataType);\n    }\n    if (!length) {\n      length = typeName.length;\n    }\n    if (typeName.indexOf(cqlNames.frozen, startIndex) === startIndex) {\n      //Remove the frozen token\n      startIndex += cqlNames.frozen.length + 1;\n      length -= cqlNames.frozen.length + 2;\n      dataType.options.frozen = true;\n    }\n    if (typeName.indexOf(cqlNames.list, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.list.length + 1;\n      length -= cqlNames.list.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length !== 1) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.list;\n      return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver, function (err, childType) {\n        if (err) {\n          return callback(err);\n        }\n        dataType.info = childType;\n        callback(null, dataType);\n      });\n    }\n    if (typeName.indexOf(cqlNames.set, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.set.length + 1;\n      length -= cqlNames.set.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length !== 1) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.set;\n      return this.parseTypeName(keyspace, innerTypes[0], 0, null, udtResolver, function (err, childType) {\n        if (err) {\n          return callback(err);\n        }\n        dataType.info = childType;\n        callback(null, dataType);\n      });\n    }\n    if (typeName.indexOf(cqlNames.map, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.map.length + 1;\n      length -= cqlNames.map.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      //It should contain the key and value types\n      if (innerTypes.length !== 2) {\n        return callback(new TypeError('Not a valid type ' + typeName));\n      }\n      dataType.code = dataTypes.map;\n      return this._parseChildTypes(keyspace, dataType, innerTypes, udtResolver, callback);\n    }\n    if (typeName.indexOf(cqlNames.tuple, startIndex) === startIndex) {\n      //move cursor across the name and bypass the angle brackets\n      startIndex += cqlNames.tuple.length + 1;\n      length -= cqlNames.tuple.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length, '<', '>');\n      if (innerTypes.length < 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.tuple;\n      return this._parseChildTypes(keyspace, dataType, innerTypes, udtResolver, callback);\n    }\n    var quoted = typeName.indexOf('\"', startIndex) === startIndex;\n    if (quoted) {\n      //Remove quotes\n      startIndex++;\n      length -= 2;\n    }\n    //Quick check if its a single type\n    if (startIndex > 0) {\n      typeName = typeName.substr(startIndex, length);\n    }\n    // Un-escape double quotes if quoted.\n    if (quoted) {\n      typeName = typeName.replace('\"\"', '\"');\n    }\n    var typeCode = dataTypes[typeName];\n    if (typeof typeCode === 'number') {\n      dataType.code = typeCode;\n      return callback(null, dataType);\n    }\n    if (typeName === cqlNames.empty) {\n      //set as custom\n      dataType.info = 'empty';\n      return callback(null, dataType);\n    }\n    udtResolver(keyspace, typeName, function (err, udtInfo) {\n      if (err) {\n        return callback(err);\n      }\n      if (udtInfo) {\n        dataType.code = dataTypes.udt;\n        dataType.info = udtInfo;\n        return callback(null, dataType);\n      }\n      callback(new TypeError('Not a valid type \"' + typeName + '\"'));\n    });\n  };\n  /**\n   * @param {String} keyspace\n   * @param dataType\n   * @param {Array} typeNames\n   * @param {Function} udtResolver\n   * @param {Function} callback\n   * @private\n   */\n  this._parseChildTypes = function (keyspace, dataType, typeNames, udtResolver, callback) {\n    var self = this;\n    utils.mapSeries(typeNames, function (name, next) {\n      self.parseTypeName(keyspace, name.trim(), 0, null, udtResolver, next);\n    }, function (err, childTypes) {\n      if (err) {\n        return callback(err);\n      }\n      dataType.info = childTypes;\n      callback(null, dataType);\n    });\n  };\n\n  /**\n   * Parses a Cassandra fully-qualified class name string into data type information\n   * @param {String} typeName\n   * @param {Number} [startIndex]\n   * @param {Number} [length]\n   * @throws TypeError\n   * @returns {{code: number, info: Object|Array|null, options: {frozen: Boolean, reversed: Boolean}}}\n   * @internal\n   * @ignore\n   */\n  this.parseFqTypeName = function (typeName, startIndex, length) {\n    var dataType = {\n      code: 0,\n      info: null,\n      options: {\n        reversed: false,\n        frozen: false\n      }\n    };\n    startIndex = startIndex || 0;\n    var innerTypes;\n    if (!length) {\n      length = typeName.length;\n    }\n    if (length > complexTypeNames.reversed.length && typeName.indexOf(complexTypeNames.reversed) === startIndex) {\n      //Remove the reversed token\n      startIndex += complexTypeNames.reversed.length + 1;\n      length -= complexTypeNames.reversed.length + 2;\n      dataType.options.reversed = true;\n    }\n    if (length > complexTypeNames.frozen.length &&\n        typeName.indexOf(complexTypeNames.frozen, startIndex) === startIndex) {\n      //Remove the frozen token\n      startIndex += complexTypeNames.frozen.length + 1;\n      length -= complexTypeNames.frozen.length + 2;\n      dataType.options.frozen = true;\n    }\n    if (typeName === complexTypeNames.empty) {\n      //set as custom\n      dataType.info = 'empty';\n      return dataType;\n    }\n    //Quick check if its a single type\n    if (length <= singleFqTypeNamesLength) {\n      if (startIndex > 0) {\n        typeName = typeName.substr(startIndex, length);\n      }\n      var typeCode = singleTypeNames[typeName];\n      if (typeof typeCode === 'number') {\n        dataType.code = typeCode;\n        return dataType;\n      }\n      throw new TypeError('Not a valid type \"' + typeName + '\"');\n    }\n    if (typeName.indexOf(complexTypeNames.list, startIndex) === startIndex) {\n      //Its a list\n      //org.apache.cassandra.db.marshal.ListType(innerType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.list.length + 1;\n      length -= complexTypeNames.list.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length !== 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.list;\n      dataType.info = this.parseFqTypeName(innerTypes[0]);\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.set, startIndex) === startIndex) {\n      //Its a set\n      //org.apache.cassandra.db.marshal.SetType(innerType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.set.length + 1;\n      length -= complexTypeNames.set.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length !== 1)\n      {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.set;\n      dataType.info = this.parseFqTypeName(innerTypes[0]);\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.map, startIndex) === startIndex) {\n      //org.apache.cassandra.db.marshal.MapType(keyType,valueType)\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.map.length + 1;\n      length -= complexTypeNames.map.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      //It should contain the key and value types\n      if (innerTypes.length !== 2) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.map;\n      dataType.info = [this.parseFqTypeName(innerTypes[0]), this.parseFqTypeName(innerTypes[1])];\n      return dataType;\n    }\n    if (typeName.indexOf(complexTypeNames.udt, startIndex) === startIndex) {\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.udt.length + 1;\n      length -= complexTypeNames.udt.length + 2;\n      return this._parseUdtName(typeName, startIndex, length);\n    }\n    if (typeName.indexOf(complexTypeNames.tuple, startIndex) === startIndex) {\n      //move cursor across the name and bypass the parenthesis\n      startIndex += complexTypeNames.tuple.length + 1;\n      length -= complexTypeNames.tuple.length + 2;\n      innerTypes = parseParams(typeName, startIndex, length);\n      if (innerTypes.length < 1) {\n        throw new TypeError('Not a valid type ' + typeName);\n      }\n      dataType.code = dataTypes.tuple;\n      dataType.info = innerTypes.map(function (x) {\n        return this.parseFqTypeName(x);\n      }, this);\n      return dataType;\n    }\n\n    // Assume custom type if cannot be parsed up to this point.\n    dataType.info = typeName.substr(startIndex, length);\n    return dataType;\n  };\n  /**\n   * Parses type names with composites\n   * @param {String} typesString\n   * @returns {{types: Array, isComposite: Boolean, hasCollections: Boolean}}\n   * @internal\n   * @ignore\n   */\n  this.parseKeyTypes = function (typesString) {\n    var i = 0;\n    var length = typesString.length;\n    var isComposite = typesString.indexOf(complexTypeNames.composite) === 0;\n    if (isComposite) {\n      i = complexTypeNames.composite.length + 1;\n      length--;\n    }\n    var types = [];\n    var startIndex = i;\n    var nested = 0;\n    var inCollectionType = false;\n    var hasCollections = false;\n    //as collection types are not allowed, it is safe to split by ,\n    while (++i < length) {\n      switch (typesString[i]) {\n        case ',':\n          if (nested > 0) {\n            break;\n          }\n          if (inCollectionType) {\n            //remove type id\n            startIndex = typesString.indexOf(':', startIndex) + 1;\n          }\n          types.push(typesString.substring(startIndex, i));\n          startIndex = i + 1;\n          break;\n        case '(':\n          if (nested === 0 && typesString.indexOf(complexTypeNames.collection, startIndex) === startIndex) {\n            inCollectionType = true;\n            hasCollections = true;\n            //skip collection type\n            i++;\n            startIndex = i;\n            break;\n          }\n          nested++;\n          break;\n        case ')':\n          if (inCollectionType && nested === 0){\n            types.push(typesString.substring(typesString.indexOf(':', startIndex) + 1, i));\n            startIndex = i + 1;\n            break;\n          }\n          nested--;\n          break;\n      }\n    }\n    if (startIndex < length) {\n      types.push(typesString.substring(startIndex, length));\n    }\n    return {\n      types: types.map(function (name) {\n        return this.parseFqTypeName(name);\n      }, this),\n      hasCollections: hasCollections,\n      isComposite: isComposite\n    };\n  };\n  this._parseUdtName = function (typeName, startIndex, length) {\n    var udtParams = parseParams(typeName, startIndex, length);\n    if (udtParams.length < 2) {\n      //It should contain at least the keyspace, name of the udt and a type\n      throw new TypeError('Not a valid type ' + typeName);\n    }\n    var dataType = {\n      code: dataTypes.udt,\n      info: null\n    };\n    var udtInfo = {\n      keyspace: udtParams[0],\n      name: new Buffer(udtParams[1], 'hex').toString(),\n      fields: []\n    };\n    for (var i = 2; i < udtParams.length; i++) {\n      var p = udtParams[i];\n      var separatorIndex = p.indexOf(':');\n      var fieldType = this.parseFqTypeName(p, separatorIndex + 1, p.length - (separatorIndex + 1));\n      udtInfo.fields.push({\n        name: new Buffer(p.substr(0, separatorIndex), 'hex').toString(),\n        type: fieldType\n      });\n    }\n    dataType.info = udtInfo;\n    return dataType;\n  };\n}\n\n/**\n * Sets the encoder and decoder methods for this instance\n * @private\n */\nfunction setEncoders() {\n  //decoders\n  var d = {};\n  d[dataTypes.custom] = this.decodeBlob;\n  d[dataTypes.ascii] = this.decodeAsciiString;\n  d[dataTypes.bigint] = this.decodeLong;\n  d[dataTypes.blob] = this.decodeBlob;\n  d[dataTypes.boolean] = this.decodeBoolean;\n  d[dataTypes.counter] = this.decodeLong;\n  d[dataTypes.decimal] = this.decodeDecimal;\n  d[dataTypes.double] = this.decodeDouble;\n  d[dataTypes.float] = this.decodeFloat;\n  d[dataTypes.int] = this.decodeInt;\n  d[dataTypes.text] = this.decodeUtf8String;\n  d[dataTypes.timestamp] = this.decodeTimestamp;\n  d[dataTypes.uuid] = this.decodeUuid;\n  d[dataTypes.varchar] = this.decodeUtf8String;\n  d[dataTypes.varint] = this.decodeVarint;\n  d[dataTypes.timeuuid] = this.decodeTimeUuid;\n  d[dataTypes.inet] = this.decodeInet;\n  d[dataTypes.date] = this.decodeDate;\n  d[dataTypes.time] = this.decodeTime;\n  d[dataTypes.smallint] = this.decodeSmallint;\n  d[dataTypes.tinyint] = this.decodeTinyint;\n  d[dataTypes.list] = this.decodeList;\n  d[dataTypes.map] = this.decodeMap;\n  d[dataTypes.set] = this.decodeSet;\n  d[dataTypes.udt] = this.decodeUdt;\n  d[dataTypes.tuple] = this.decodeTuple;\n\n  //encoders\n  var e = {};\n  e[dataTypes.custom] = this.encodeBlob;\n  e[dataTypes.ascii] = this.encodeAsciiString;\n  e[dataTypes.bigint] = this.encodeLong;\n  e[dataTypes.blob] = this.encodeBlob;\n  e[dataTypes.boolean] = this.encodeBoolean;\n  e[dataTypes.counter] = this.encodeLong;\n  e[dataTypes.decimal] = this.encodeDecimal;\n  e[dataTypes.double] = this.encodeDouble;\n  e[dataTypes.float] = this.encodeFloat;\n  e[dataTypes.int] = this.encodeInt;\n  e[dataTypes.text] = this.encodeUtf8String;\n  e[dataTypes.timestamp] = this.encodeTimestamp;\n  e[dataTypes.uuid] = this.encodeUuid;\n  e[dataTypes.varchar] = this.encodeUtf8String;\n  e[dataTypes.varint] = this.encodeVarint;\n  e[dataTypes.timeuuid] = this.encodeUuid;\n  e[dataTypes.inet] = this.encodeInet;\n  e[dataTypes.date] = this.encodeDate;\n  e[dataTypes.time] = this.encodeTime;\n  e[dataTypes.smallint] = this.encodeSmallint;\n  e[dataTypes.tinyint] = this.encodeTinyint;\n  e[dataTypes.list] = this.encodeList;\n  e[dataTypes.map] = this.encodeMap;\n  e[dataTypes.set] = this.encodeSet;\n  e[dataTypes.udt] = this.encodeUdt;\n  e[dataTypes.tuple] = this.encodeTuple;\n\n  this.decoders = d;\n  this.encoders = e;\n}\n\n/**\n * Decodes Cassandra bytes into Javascript values.\n * <p>\n * This is part of an <b>experimental</b> API, this can be changed future releases.\n * </p>\n * @param {Buffer} buffer Raw buffer to be decoded.\n * @param {Object} type An object containing the data type <code>code</code> and <code>info</code>.\n * @param {Number} type.code Type code.\n * @param {Object} [type.info] Additional information on the type for complex / nested types.\n */\nEncoder.prototype.decode = function (buffer, type) {\n  if (buffer === null) {\n    return null;\n  }\n  var decoder = this.decoders[type.code];\n  if (!decoder) {\n    throw new Error('Unknown data type: ' + type.code);\n  }\n  return decoder.call(this, buffer, type.info);\n};\n\n/**\n * Encodes Javascript types into Buffer according to the Cassandra protocol.\n * <p>\n * This is part of an <b>experimental</b> API, this can be changed future releases.\n * </p>\n * @param {*} value The value to be converted.\n * @param {{code: number, info: *|Object}|String|Number} [typeInfo] The type information.\n * <p>It can be either a:</p>\n * <ul>\n *   <li>A <code>String</code> representing the data type.</li>\n *   <li>A <code>Number</code> with one of the values of {@link module:types~dataTypes dataTypes}.</li>\n *   <li>An <code>Object</code> containing the <code>type.code</code> as one of the values of\n *   {@link module:types~dataTypes dataTypes} and <code>type.info</code>.\n *   </li>\n * </ul>\n * @returns {Buffer}\n * @throws {TypeError} When there is an encoding error\n */\nEncoder.prototype.encode = function (value, typeInfo) {\n  if (value === undefined) {\n    //defaults to null\n    value = null;\n    if (this.encodingOptions.useUndefinedAsUnset && this.protocolVersion >= 4) {\n      //use undefined as unset\n      value = types.unset;\n    }\n  }\n  if (value === null) {\n    return value;\n  }\n  if (value === types.unset) {\n    if (this.protocolVersion < 4) {\n      throw new TypeError('Unset value can not be used for this version of Cassandra, protocol version: ' + this.protocolVersion);\n    }\n    return value;\n  }\n  /** @type {{code: Number, info: object}} */\n  var type = {\n    code: null,\n    info: null\n  };\n  if (typeInfo) {\n    if (typeof typeInfo === 'number') {\n      type.code = typeInfo;\n    }\n    else if (typeof typeInfo === 'string') {\n      type = dataTypes.getByName(typeInfo);\n    }\n    if (typeof typeInfo.code === 'number') {\n      type.code = typeInfo.code;\n      type.info = typeInfo.info;\n    }\n    if (typeof type.code !== 'number') {\n      throw new TypeError('Type information not valid, only String and Number values are valid hints');\n    }\n  }\n  else {\n    //Lets guess\n    type = Encoder.guessDataType(value);\n    if (!type) {\n      throw new TypeError('Target data type could not be guessed, you should use prepared statements for accurate type mapping. Value: ' + util.inspect(value));\n    }\n  }\n  var encoder = this.encoders[type.code];\n  if (!encoder) {\n    throw new Error('Type not supported ' + type.code);\n  }\n  return encoder.call(this, value, type.info);\n};\n\n/**\n * Try to guess the Cassandra type to be stored, based on the javascript value type\n * @param value\n * @returns {{code: number, info: object}}\n * @ignore\n * @internal\n */\nEncoder.guessDataType = function (value) {\n  var code = null;\n  if (typeof value === 'number') {\n    code = dataTypes.double;\n  }\n  else if (typeof value === 'string') {\n    code = dataTypes.text;\n    if (value.length === 36 && uuidRegex.test(value)){\n      code = dataTypes.uuid;\n    }\n  }\n  else if (value instanceof Buffer) {\n    code = dataTypes.blob;\n  }\n  else if (value instanceof Date) {\n    code = dataTypes.timestamp;\n  }\n  else if (value instanceof Long) {\n    code = dataTypes.bigint;\n  }\n  else if (value instanceof Integer) {\n    code = dataTypes.varint;\n  }\n  else if (value instanceof BigDecimal) {\n    code = dataTypes.decimal;\n  }\n  else if (value instanceof types.Uuid) {\n    code = dataTypes.uuid;\n  }\n  else if (value instanceof types.InetAddress) {\n    code = dataTypes.inet;\n  }\n  else if (value instanceof types.Tuple) {\n    code = dataTypes.tuple;\n  }\n  else if (value instanceof types.LocalDate) {\n    code = dataTypes.date;\n  }\n  else if (value instanceof types.LocalTime) {\n    code = dataTypes.time;\n  }\n  else if (util.isArray(value)) {\n    code = dataTypes.list;\n  }\n  else if (value === true || value === false) {\n    code = dataTypes.boolean;\n  }\n\n  if (code === null) {\n    return null;\n  }\n  return {code: code, info: null};\n};\n\n/**\n * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v2 and below\n * @param {Buffer|Number} value\n * @returns {Buffer}\n * @private\n */\nfunction getLengthBufferV2(value) {\n  if (!value) {\n    return int16Zero;\n  }\n  var lengthBuffer = new Buffer(2);\n  if (typeof value === 'number') {\n    lengthBuffer.writeUInt16BE(value, 0);\n  }\n  else {\n    lengthBuffer.writeUInt16BE(value.length, 0);\n  }\n  return lengthBuffer;\n}\n\n/**\n * Gets a buffer containing with the bytes (BE) representing the collection length for protocol v3 and above\n * @param {Buffer|Number} value\n * @returns {Buffer}\n * @private\n */\nfunction getLengthBufferV3(value) {\n  if (!value) {\n    return int32Zero;\n  }\n  var lengthBuffer = new Buffer(4);\n  if (typeof value === 'number') {\n    lengthBuffer.writeUInt32BE(value, 0);\n  }\n  else {\n    lengthBuffer.writeUInt32BE(value.length, 0);\n  }\n  return lengthBuffer;\n}\n\n/**\n * @param {Buffer} buffer\n * @private\n */\nfunction handleBufferCopy(buffer) {\n  if (buffer === null) {\n    return null;\n  }\n  return utils.copyBuffer(buffer);\n}\n\n/**\n * @param {Buffer} buffer\n * @private\n */\nfunction handleBufferRef(buffer) {\n  return buffer;\n}\n/**\n * Decodes collection length for protocol v3 and above\n * @param bytes\n * @param offset\n * @returns {Number}\n * @private\n */\nfunction decodeCollectionLengthV3(bytes, offset) {\n  return bytes.readUInt32BE(offset);\n}\n/**\n * Decodes collection length for protocol v2 and below\n * @param bytes\n * @param offset\n * @returns {Number}\n * @private\n */\nfunction decodeCollectionLengthV2(bytes, offset) {\n  return bytes.readUInt16BE(offset);\n}\n\n/**\n * @param {String} value\n * @param {Number} startIndex\n * @param {Number} length\n * @param {String} [open]\n * @param {String} [close]\n * @returns {Array}\n * @private\n */\nfunction parseParams(value, startIndex, length, open, close) {\n  open = open || '(';\n  close = close || ')';\n  var types = [];\n  var paramStart = startIndex;\n  var level = 0;\n  for (var i = startIndex; i < startIndex + length; i++) {\n    var c = value[i];\n    if (c === open) {\n      level++;\n    }\n    if (c === close) {\n      level--;\n    }\n    if (level === 0 && c === ',') {\n      types.push(value.substr(paramStart, i - paramStart));\n      paramStart = i + 1;\n    }\n  }\n  //Add the last one\n  types.push(value.substr(paramStart, length - (paramStart - startIndex)));\n  return types;\n}\n\n/**\n * @param {Array.<Buffer>} parts\n * @param {Number} totalLength\n * @returns {Buffer}\n * @private\n */\nfunction concatRoutingKey(parts, totalLength) {\n  var routingKey = new Buffer(totalLength);\n  var offset = 0;\n  parts.forEach(function (item) {\n    routingKey.writeInt16BE(item.length, offset);\n    offset += 2;\n    item.copy(routingKey, offset);\n    offset += item.length;\n    routingKey[offset] = 0;\n    offset++;\n  });\n  return routingKey;\n}\n\nmodule.exports = Encoder;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/writers.js":"'use strict';\nvar events = require('events');\nvar util = require('util');\n\nvar types = require('./types');\nvar utils = require('./utils.js');\nvar FrameHeader = types.FrameHeader;\n\n/**\n * Contains the logic to write all the different types to the frame.\n * @param {Number} opcode\n * @constructor\n */\nfunction FrameWriter(opcode) {\n  if (!opcode) {\n    throw new Error('Opcode not provided');\n  }\n  this.buffers = [];\n  this.opcode = opcode;\n  this.bodyLength = 0;\n}\n\nFrameWriter.prototype.add = function(buf) {\n  this.buffers.push(buf);\n  this.bodyLength += buf.length;\n};\n\nFrameWriter.prototype.writeShort = function(num) {\n  var buf = new Buffer(2);\n  buf.writeUInt16BE(num, 0);\n  this.add(buf);\n};\n\nFrameWriter.prototype.writeInt = function(num) {\n  var buf = new Buffer(4);\n  buf.writeInt32BE(num, 0);\n  this.add(buf);\n};\n\n/** @param {Long} num */\nFrameWriter.prototype.writeLong = function(num) {\n  this.add(types.Long.toBuffer(num));\n};\n\n/**\n * Writes bytes according to Cassandra <int byteLength><bytes>\n * @param {Buffer|null|types.unset} bytes\n */\nFrameWriter.prototype.writeBytes = function(bytes) {\n  if (bytes === null) {\n    //Only the length buffer containing -1\n    this.writeInt(-1);\n    return;\n  }\n  if (bytes === types.unset) {\n    this.writeInt(-2);\n    return;\n  }\n  //Add the length buffer\n  this.writeInt(bytes.length);\n  //Add the actual buffer\n  this.add(bytes);\n};\n\n/**\n * Writes a buffer according to Cassandra protocol: bytes.length (2) + bytes\n * @param {Buffer} bytes\n */\nFrameWriter.prototype.writeShortBytes = function(bytes) {\n  if(bytes === null) {\n    //Only the length buffer containing -1\n    this.writeShort(-1);\n    return;\n  }\n  //Add the length buffer\n  this.writeShort(bytes.length);\n  //Add the actual buffer\n  this.add(bytes);\n};\n\n/**\n * Writes a single byte\n * @param {Number} num Value of the byte, a number between 0 and 255.\n */\nFrameWriter.prototype.writeByte = function (num) {\n  this.add(new Buffer([num]));\n};\n\nFrameWriter.prototype.writeString = function(str) {\n  if (typeof str === \"undefined\") {\n    throw new Error(\"can not write undefined\");\n  }\n  var len = Buffer.byteLength(str, 'utf8');\n  var buf = new Buffer(2 + len);\n  buf.writeUInt16BE(len, 0);\n  buf.write(str, 2, buf.length-2, 'utf8');\n  this.add(buf);\n};\n\nFrameWriter.prototype.writeLString = function(str) {\n  var len = Buffer.byteLength(str, 'utf8');\n  var buf = new Buffer(4 + len);\n  buf.writeInt32BE(len, 0);\n  buf.write(str, 4, buf.length-4, 'utf8');\n  this.add(buf);\n};\n\nFrameWriter.prototype.writeStringList = function (values) {\n  this.writeShort(values.length);\n  values.forEach(this.writeString, this);\n};\n\nFrameWriter.prototype.writeCustomPayload = function (payload) {\n  var keys = Object.keys(payload);\n  this.writeShort(keys.length);\n  keys.forEach(function (k) {\n    this.writeString(k);\n    this.writeBytes(payload[k]);\n  }, this);\n};\n\nFrameWriter.prototype.writeStringMap = function (map) {\n  var keys = [];\n  for (var k in map) {\n    if (map.hasOwnProperty(k)) {\n      keys.push(k);\n    }\n  }\n\n  this.writeShort(keys.length);\n\n  for(var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    this.writeString(key);\n    this.writeString(map[key]);\n  }\n};\n\n/**\n * @param {Number} version\n * @param {Number} streamId\n * @param {Number} [flags] Header flags\n * @returns {Buffer}\n * @throws {TypeError}\n */\nFrameWriter.prototype.write = function (version, streamId, flags) {\n  var header = new FrameHeader(version, flags || 0, streamId, this.opcode, this.bodyLength);\n  var headerBuffer = header.toBuffer();\n  this.buffers.unshift(headerBuffer);\n  return Buffer.concat(this.buffers, headerBuffer.length + this.bodyLength);\n};\n\n/**\n * Represents a queue that process one write at a time (FIFO).\n * @param {Socket} netClient\n * @param {Encoder} encoder\n * @param {ClientOptions} options\n * @extends {EventEmitter}\n */\nfunction WriteQueue (netClient, encoder, options) {\n  WriteQueue.super_.call(this);\n  this.netClient = netClient;\n  this.encoder = encoder;\n  this.isRunning = false;\n  /** @type {Array<{request: Request, callback: Function}>} */\n  this.queue = [];\n  this.coalescingThreshold = options.socketOptions.coalescingThreshold;\n  this.error = null;\n}\n\nutil.inherits(WriteQueue, events.EventEmitter);\n/**\n * Enqueues a new request\n * @param {Request} request\n * @param {Function} callback\n */\nWriteQueue.prototype.push = function (request, callback) {\n  var self = this;\n  if (this.error) {\n    // There was a write error, there is no point in further trying to write to the socket.\n    return process.nextTick(function writePushError() {\n      callback(self.error);\n    });\n  }\n  this.queue.push({ request: request, callback: callback});\n  this.run();\n};\n\nWriteQueue.prototype.run = function () {\n  if (!this.isRunning) {\n    this.process();\n  }\n};\n\nWriteQueue.prototype.process = function () {\n  var self = this;\n  utils.whilst(\n    function condition() {\n      return self.queue.length > 0;\n    },\n    function whileProcess(next) {\n      self.isRunning = true;\n      var buffers = [];\n      var callbacks = [];\n      var totalLength = 0;\n      while (totalLength < self.coalescingThreshold && self.queue.length > 0) {\n        var writeItem = self.queue.shift();\n        try {\n          var data = writeItem.request.write(self.encoder);\n          totalLength += data.length;\n          buffers.push(data);\n          callbacks.push(writeItem.callback);\n        }\n        catch (err) {\n          writeItem.callback(err);\n          //break and flush what we have\n          break;\n        }\n      }\n      if (buffers.length === 0) {\n        // No need to invoke socket.write()\n        return next();\n      }\n      // Before invoking socket.write(), mark that the request has been written to avoid race conditions.\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i]();\n      }\n      self.netClient.write(Buffer.concat(buffers, totalLength), function socketWriteCallback(err) {\n        if (err) {\n          self.setWriteError(err);\n        }\n        // Allow IO between writes\n        setImmediate(next);\n      });\n    },\n    function loopFinished() {\n      // The queue is now empty\n      self.isRunning = false;\n    }\n  );\n};\n\n/**\n * Emits the 'error' event and callbacks items that haven't been written and clears them from the queue.\n * @param err\n */\nWriteQueue.prototype.setWriteError = function (err) {\n  err.isSocketError = true;\n  this.error = new types.DriverError('Socket was closed');\n  this.error.isSocketError = true;\n  // Use an special flag for items that haven't been written\n  this.error.requestNotWritten = true;\n  this.error.innerError = err;\n  var q = this.queue;\n  // Not more items can be added to the queue.\n  this.queue = utils.emptyArray;\n  for (var i = 0; i < q.length; i++) {\n    var item = q[i];\n    // Use the error marking that it was not written\n    item.callback(this.error);\n  }\n};\n\nexports.WriteQueue = WriteQueue;\nexports.FrameWriter = FrameWriter;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/requests.js":"'use strict';\nvar util = require('util');\n\nvar FrameWriter = require('./writers').FrameWriter;\nvar types = require('./types');\nvar utils = require('./utils');\n\n/**\n * Options for the execution of the query / prepared statement\n * @private\n */\nvar queryFlag = {\n  values:                 0x01,\n  skipMetadata:           0x02,\n  pageSize:               0x04,\n  withPagingState:        0x08,\n  withSerialConsistency:  0x10,\n  withDefaultTimestamp:   0x20,\n  withNameForValues:      0x40\n};\n\n/**\n * Options for the executing of a batch request from protocol v3 and above\n * @private\n */\nvar batchFlag = {\n  withSerialConsistency:  0x10,\n  withDefaultTimestamp:   0x20,\n  withNameForValues:      0x40\n};\n\n/**\n * Abstract class Request\n * @constructor\n */\nfunction Request() {\n\n}\n\n/**\n * @abstract\n * @param {Encoder} encoder\n * @throws {TypeError}\n * @returns {Buffer}\n */\nRequest.prototype.write = function (encoder) {\n  throw new Error('Method must be implemented');\n};\n\n/**\n * Writes a execute query (given a prepared queryId)\n * @param {String} query\n * @param {Buffer} queryId\n * @param {Array} params\n * @param options\n */\nfunction ExecuteRequest(query, queryId, params, options) {\n  this.streamId = null;\n  this.query = query;\n  this.queryId = queryId;\n  this.params = params;\n  this.setOptions(options);\n}\n\nutil.inherits(ExecuteRequest, Request);\n\nExecuteRequest.prototype.write = function (encoder) {\n  //v1: <queryId>\n  //      <n><value_1>....<value_n><consistency>\n  //v2: <queryId>\n  //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n  //v3: <queryId>\n  //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n  var frameWriter = new FrameWriter(types.opcodes.execute);\n  var headerFlags = this.options.traceQuery ? types.frameFlags.tracing : 0;\n  if (this.options.customPayload) {\n    //The body may contain the custom payload\n    headerFlags |= types.frameFlags.customPayload;\n    frameWriter.writeCustomPayload(this.options.customPayload);\n  }\n  frameWriter.writeShortBytes(this.queryId);\n  this.writeQueryParameters(frameWriter, encoder);\n  return frameWriter.write(this.version, this.streamId, headerFlags);\n};\n\n/**\n * Writes v1 and v2 execute query parameters\n * @param {FrameWriter} frameWriter\n * @param {Encoder} encoder\n */\nExecuteRequest.prototype.writeQueryParameters = function (frameWriter, encoder) {\n  //v1: <n><value_1>....<value_n><consistency>\n  //v2: <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n  //v3: <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n  var flags = 0;\n  if (this.version > 1) {\n    flags |= (this.params && this.params.length) ? queryFlag.values : 0;\n    flags |= (this.options.fetchSize > 0) ? queryFlag.pageSize : 0;\n    flags |= this.options.pageState ? queryFlag.withPagingState : 0;\n    flags |= this.options.serialConsistency ? queryFlag.withSerialConsistency : 0;\n    flags |= this.options.timestamp ? queryFlag.withDefaultTimestamp : 0;\n    flags |= this.options.namedParameters ? queryFlag.withNameForValues : 0;\n    frameWriter.writeShort(this.consistency);\n    frameWriter.writeByte(flags);\n  }\n  if (this.params && this.params.length) {\n    frameWriter.writeShort(this.params.length);\n    for (var i = 0; i < this.params.length; i++) {\n      var paramValue = this.params[i];\n      if (flags & queryFlag.withNameForValues) {\n        //parameter is composed by name / value\n        frameWriter.writeString(paramValue.name);\n        paramValue = paramValue.value;\n      }\n      frameWriter.writeBytes(encoder.encode(paramValue, this.hints[i]));\n    }\n  }\n  if (this.version === 1) {\n    if (!this.params || !this.params.length) {\n      //zero parameters\n      frameWriter.writeShort(0);\n    }\n    frameWriter.writeShort(this.consistency);\n    return;\n  }\n  if (flags & queryFlag.pageSize) {\n    frameWriter.writeInt(this.options.fetchSize);\n  }\n  if (flags & queryFlag.withPagingState) {\n    frameWriter.writeBytes(this.options.pageState);\n  }\n  if (flags & queryFlag.withSerialConsistency) {\n    frameWriter.writeShort(this.options.serialConsistency);\n  }\n  if (flags & queryFlag.withDefaultTimestamp) {\n    var timestamp = this.options.timestamp;\n    if (typeof timestamp === 'number') {\n      timestamp = types.Long.fromNumber(timestamp);\n    }\n    frameWriter.writeLong(timestamp);\n  }\n};\n\nExecuteRequest.prototype.setOptions = function (options) {\n  this.options = options || utils.emptyObject;\n  this.consistency = this.options.consistency || types.consistencies.one;\n  this.hints = this.options.hints || utils.emptyArray;\n};\n\nfunction QueryRequest(query, params, options) {\n  this.streamId = null;\n  this.query = query;\n  this.params = params;\n  this.setOptions(options);\n}\n\nutil.inherits(QueryRequest, ExecuteRequest);\n\nQueryRequest.prototype.write = function (encoder) {\n  //v1: <query><consistency>\n  //v2: <query>\n  //      <consistency><flags>[<n><value_1>...<value_n>][<result_page_size>][<paging_state>][<serial_consistency>]\n  //v3: <query>\n  //      <consistency><flags>[<n>[name_1]<value_1>...[name_n]<value_n>][<result_page_size>][<paging_state>][<serial_consistency>][<timestamp>]\n  var frameWriter = new FrameWriter(types.opcodes.query);\n  var headerFlags = this.options.traceQuery ? types.frameFlags.tracing : 0;\n  if (this.options.customPayload) {\n    //The body may contain the custom payload\n    headerFlags |= types.frameFlags.customPayload;\n    frameWriter.writeCustomPayload(this.options.customPayload);\n  }\n  frameWriter.writeLString(this.query);\n  if (this.version === 1) {\n    frameWriter.writeShort(this.consistency);\n  }\n  else {\n    //Use the same fields as the execute writer\n    this.writeQueryParameters(frameWriter, encoder);\n  }\n  return frameWriter.write(this.version, this.streamId, headerFlags);\n};\n\nfunction PrepareRequest(query) {\n  this.streamId = null;\n  this.query = query;\n}\n\nutil.inherits(PrepareRequest, Request);\n\nPrepareRequest.prototype.write = function () {\n  var frameWriter = new FrameWriter(types.opcodes.prepare);\n  frameWriter.writeLString(this.query);\n  return frameWriter.write(this.version, this.streamId);\n};\n\nfunction StartupRequest(cqlVersion) {\n  this.cqlVersion = cqlVersion || '3.0.0';\n  this.streamId = null;\n}\n\nutil.inherits(StartupRequest, Request);\n\nStartupRequest.prototype.write = function() {\n  var frameWriter = new FrameWriter(types.opcodes.startup);\n  frameWriter.writeStringMap({\n    CQL_VERSION: this.cqlVersion\n  });\n  return frameWriter.write(this.version, this.streamId);\n};\n\nfunction RegisterRequest(events) {\n  this.events = events;\n  this.streamId = null;\n}\n\nutil.inherits(RegisterRequest, Request);\n\nRegisterRequest.prototype.write = function() {\n  var frameWriter = new FrameWriter(types.opcodes.register);\n  frameWriter.writeStringList(this.events);\n  return frameWriter.write(this.version, this.streamId);\n};\n\n/**\n * Represents an AUTH_RESPONSE request\n * @param {Buffer} token\n * @constructor\n */\nfunction AuthResponseRequest(token) {\n  this.token = token;\n  this.streamId = null;\n}\n\nutil.inherits(AuthResponseRequest, Request);\n\nAuthResponseRequest.prototype.write = function () {\n  var frameWriter = new FrameWriter(types.opcodes.authResponse);\n  frameWriter.writeBytes(this.token);\n  return frameWriter.write(this.version, this.streamId);\n};\n\n/**\n * Represents a protocol v1 CREDENTIALS request message\n * @constructor\n */\nfunction CredentialsRequest(username, password) {\n  this.username = username;\n  this.password = password;\n  this.streamId = null;\n}\n\nutil.inherits(CredentialsRequest, Request);\n\nCredentialsRequest.prototype.write = function () {\n  var frameWriter = new FrameWriter(types.opcodes.credentials);\n  frameWriter.writeStringMap({username:this.username, password:this.password});\n  return frameWriter.write(this.version, this.streamId);\n};\n\n/**\n * Writes a batch request\n * @param {Array.<{query, params, [info]}>} queries Array of objects with the properties query and params\n * @param {QueryOptions} options\n * @constructor\n */\nfunction BatchRequest(queries, options) {\n  this.queries = queries;\n  /** @type {QueryOptions} */\n  this.options = options;\n  this.type = options.logged ? 0 : 1;\n  this.type = options.counter ? 2 : this.type;\n  this.streamId = null;\n  this.hints = options.hints || utils.emptyArray;\n}\n\nutil.inherits(BatchRequest, Request);\n\nBatchRequest.prototype.write = function (encoder) {\n  //v2: <type><n><query_1>...<query_n><consistency>\n  //v3: <type><n><query_1>...<query_n><consistency><flags>[<serial_consistency>][<timestamp>]\n  if (!this.queries || !(this.queries.length > 0)) {\n    throw new TypeError(util.format('Invalid queries provided %s', this.queries));\n  }\n  var frameWriter = new FrameWriter(types.opcodes.batch);\n  var headerFlags = this.options.traceQuery ? types.frameFlags.tracing : 0;\n  if (this.options.customPayload) {\n    //The body may contain the custom payload\n    headerFlags |= types.frameFlags.customPayload;\n    frameWriter.writeCustomPayload(this.options.customPayload);\n  }\n  frameWriter.writeByte(this.type);\n  frameWriter.writeShort(this.queries.length);\n  var self = this;\n  this.queries.forEach(function eachQuery(item, i) {\n    var hints = self.hints[i];\n    var params = item.params || utils.emptyArray;\n    if (item.info) {\n      //As prepared queries\n      frameWriter.writeByte(1);\n      frameWriter.writeShortBytes(item.info.queryId);\n      hints = item.info.meta.columns.map(function (c) { return c.type; });\n      var paramsInfo = utils.adaptNamedParamsPrepared(params, item.info.meta.columns);\n      params = paramsInfo.params;\n    }\n    else {\n      //as simple query\n      frameWriter.writeByte(0);\n      frameWriter.writeLString(item.query);\n    }\n    frameWriter.writeShort(params.length);\n    params.forEach(function (param, paramIndex) {\n      frameWriter.writeBytes(encoder.encode(param, hints ? hints[paramIndex] : null));\n    });\n  }, this);\n  frameWriter.writeShort(this.options.consistency);\n  if (this.version >= 3) {\n    //Batch flags\n    var flags = this.options.serialConsistency ? batchFlag.withSerialConsistency : 0;\n    flags |= this.options.timestamp ? batchFlag.withDefaultTimestamp : 0;\n    frameWriter.writeByte(flags);\n    if (this.options.serialConsistency) {\n      frameWriter.writeShort(this.options.serialConsistency);\n    }\n    if (this.options.timestamp) {\n      var timestamp = this.options.timestamp;\n      if (typeof timestamp === 'number') {\n        timestamp = types.Long.fromNumber(timestamp);\n      }\n      frameWriter.writeLong(timestamp);\n    }\n  }\n  return frameWriter.write(this.version, this.streamId, headerFlags);\n};\n\n\nexports.AuthResponseRequest = AuthResponseRequest;\nexports.BatchRequest = BatchRequest;\nexports.CredentialsRequest = CredentialsRequest;\nexports.ExecuteRequest = ExecuteRequest;\nexports.PrepareRequest = PrepareRequest;\nexports.QueryRequest = QueryRequest;\nexports.Request = Request;\nexports.RegisterRequest = RegisterRequest;\nexports.StartupRequest = StartupRequest;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/streams.js":"'use strict';\nvar util = require('util');\nvar stream = require('stream');\nvar Transform = stream.Transform;\nvar Writable = stream.Writable;\n\nvar types = require('./types');\nvar utils = require('./utils');\nvar errors = require('./errors');\nvar FrameHeader = types.FrameHeader;\nvar FrameReader = require('./readers').FrameReader;\n\n/**\n * Transforms chunks, emits data objects {header, chunk}\n * @param options Stream options\n * @extends Transform\n */\nfunction Protocol (options) {\n  Transform.call(this, options);\n  this.header = null;\n  this.bodyLength = 0;\n  this.clearHeaderChunks();\n  this.version = 0;\n  this.headerSize = 0;\n}\n\nutil.inherits(Protocol, Transform);\n\nProtocol.prototype._transform = function (chunk, encoding, callback) {\n  var error = null;\n  try {\n    this.readItems(chunk);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n};\n\n/**\n * Parses the chunk into frames (header and body).\n * Emits (push) complete frames or frames with incomplete bodies. Following chunks containing the rest of the body will\n * be emitted using the same frame.\n * It buffers incomplete headers.\n * @param {Buffer} chunk\n */\nProtocol.prototype.readItems = function (chunk) {\n  if (!chunk || chunk.length === 0) {\n    return;\n  }\n  if (this.version === 0) {\n    //The server replies the first message with the max protocol version supported\n    this.version = FrameHeader.getProtocolVersion(chunk);\n    this.headerSize = FrameHeader.size(this.version);\n  }\n  var offset = 0;\n  var currentHeader = this.header;\n  this.header = null;\n  if (this.headerChunks.byteLength !== 0) {\n    //incomplete header was buffered try to read the header from the buffered chunks\n    this.headerChunks.parts.push(chunk);\n    if (this.headerChunks.byteLength + chunk.length < this.headerSize) {\n      this.headerChunks.byteLength += chunk.length;\n      return;\n    }\n    currentHeader = FrameHeader.fromBuffer(Buffer.concat(this.headerChunks.parts, this.headerSize));\n    offset = this.headerSize - this.headerChunks.byteLength;\n    this.clearHeaderChunks();\n  }\n  var items = [];\n  while (true) {\n    if (!currentHeader) {\n      if (this.headerSize > chunk.length - offset) {\n        if (chunk.length - offset <= 0) {\n          break;\n        }\n        //the header is incomplete, buffer it until the next chunk\n        var headerPart = chunk.slice(offset, chunk.length);\n        this.headerChunks.parts.push(headerPart);\n        this.headerChunks.byteLength = headerPart.length;\n        break;\n      }\n      //read header\n      currentHeader = FrameHeader.fromBuffer(chunk, offset);\n      offset += this.headerSize;\n    }\n    //parse body\n    var remaining = chunk.length - offset;\n    if (currentHeader.bodyLength <= remaining + this.bodyLength) {\n      items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: true });\n      offset += currentHeader.bodyLength - this.bodyLength;\n      //reset the body length\n      this.bodyLength = 0;\n    }\n    else if (remaining >= 0) {\n      //the body is not fully contained in this chunk\n      //will continue later\n      this.header = currentHeader;\n      this.bodyLength += remaining;\n      if (remaining > 0) {\n        //emit if there is at least a byte to emit\n        items.push({ header: currentHeader, chunk: chunk, offset: offset, frameEnded: false });\n      }\n      break;\n    }\n    currentHeader = null;\n  }\n  for (var i = 0; i < items.length; i++) {\n    this.push(items[i]);\n  }\n};\n\nProtocol.prototype.clearHeaderChunks = function () {\n  this.headerChunks = { byteLength: 0, parts: [] };\n};\n\n/**\n * A stream that gets reads header + body chunks and transforms them into header + (row | error)\n * @param {Object} streamOptions Node.js Stream options\n * @param {Encoder} encoder Encoder instance for the parser to use\n * @extends Transform\n */\nfunction Parser (streamOptions, encoder) {\n  Transform.call(this, streamOptions);\n  //frames that are streaming, indexed by id\n  this.frames = {};\n  this.encoder = encoder;\n}\n\nutil.inherits(Parser, Transform);\n\nParser.prototype._transform = function (item, encoding, callback) {\n  var frameInfo = this.frameState(item);\n\n  var error = null;\n  try {\n    this.parseBody(frameInfo, item);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n\n  if (item.frameEnded) {\n    if (frameInfo.cellBuffer) {\n      //Frame was being streamed but an error force it to buffer the result\n      this.push({\n        header: frameInfo.header,\n        error: new errors.DriverInternalError('There was an problem while parsing streaming frame, opcode ' +\n          frameInfo.header.opcode)\n      });\n    }\n    //all the parsing finished and it was streamed down\n    //emit an item that signals it\n    this.push({ header: frameInfo.header, frameEnded: true});\n  }\n};\n\n/**\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.parseBody = function (frameInfo, item) {\n  frameInfo.isStreaming = frameInfo.byRow && item.header.opcode === types.opcodes.result;\n  if (!this.handleFrameBuffers(frameInfo, item)) {\n    // Frame isn't complete and we are not streaming the frame\n    return;\n  }\n  var reader = new FrameReader(item.header, item.chunk, item.offset);\n  // Check that flags have not been parsed yet for this frame\n  if (frameInfo.flagsInfo === undefined) {\n    var originalOffset = reader.offset;\n    try {\n      frameInfo.flagsInfo = reader.readFlagsInfo();\n    }\n    catch (e) {\n      return this.handleParsingError(e, frameInfo, reader, originalOffset);\n    }\n  }\n\n  //All the body for most operations is already buffered at this stage\n  //Except for RESULT\n  switch (item.header.opcode) {\n    case types.opcodes.result:\n      return this.parseResult(frameInfo, reader);\n    case types.opcodes.ready:\n    case types.opcodes.authSuccess:\n      return this.push({ header: frameInfo.header, ready: true });\n    case types.opcodes.authChallenge:\n      return this.push({ header: frameInfo.header, authChallenge: true, token: reader.readBytes()});\n    case types.opcodes.authenticate:\n      return this.push({ header: frameInfo.header, mustAuthenticate: true, authenticatorName: reader.readString()});\n    case types.opcodes.error:\n      return this.push({ header: frameInfo.header, error: reader.readError()});\n    case types.opcodes.supported:\n      return this.push({ header: frameInfo.header });\n    case types.opcodes.event:\n      return this.push({ header: frameInfo.header, event: reader.readEvent()});\n    default:\n      return this.push({ header: frameInfo.header, error: new Error('Received invalid opcode: ' + item.header.opcode) });\n  }\n};\n\n/**\n * Buffers if needed and returns true if it has all the necessary data to continue parsing the frame.\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n * @returns {Boolean}\n */\nParser.prototype.handleFrameBuffers = function (frameInfo, item) {\n  if (!frameInfo.isStreaming) {\n    // Handle buffering for complete frame bodies\n    var currentLength = (frameInfo.bufferLength || 0) + item.chunk.length - item.offset;\n    if (currentLength < item.header.bodyLength) {\n      //buffer until the frame is completed\n      this.addFrameBuffer(frameInfo, item);\n      return false;\n    }\n    //We have received the full frame body\n    if (frameInfo.buffers) {\n      item.chunk = this.getFrameBuffer(frameInfo, item);\n      item.offset = 0;\n    }\n    return true;\n  }\n  if (frameInfo.cellBuffer) {\n    // Handle buffering for frame cells (row cells or metadata cells)\n    if (item.offset !== 0) {\n      throw new errors.DriverInternalError('Following chunks can not have an offset greater than zero');\n    }\n    frameInfo.cellBuffer.parts.push(item.chunk);\n    if (!frameInfo.cellBuffer.expectedLength) {\n      //Its a buffer outside a row cell (metadata or other)\n      if (frameInfo.cellBuffer.parts.length !== 2) {\n        throw new errors.DriverInternalError('Buffer for streaming frame can not contain more than 1 item');\n      }\n      item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);\n      frameInfo.cellBuffer = null;\n      return true;\n    }\n    if (frameInfo.cellBuffer.expectedLength > frameInfo.cellBuffer.byteLength + item.chunk.length) {\n      //We still haven't got the cell data\n      frameInfo.cellBuffer.byteLength += item.chunk.length;\n      return false;\n    }\n    item.chunk = Buffer.concat(frameInfo.cellBuffer.parts, frameInfo.cellBuffer.byteLength + item.chunk.length);\n    frameInfo.cellBuffer = null;\n  }\n  return true;\n};\n\n/**\n * Adds this chunk to the frame buffers.\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.addFrameBuffer = function (frameInfo, item) {\n  if (!frameInfo.buffers) {\n    frameInfo.buffers = [ item.chunk.slice(item.offset) ];\n    frameInfo.bufferLength = item.chunk.length - item.offset;\n    return;\n  }\n  if (item.offset > 0) {\n    throw new errors.DriverInternalError('Following chunks can not have an offset greater than zero');\n  }\n  frameInfo.buffers.push(item.chunk);\n  frameInfo.bufferLength += item.chunk.length;\n};\n\n/**\n * Adds the last chunk and concatenates the frame buffers\n * @param frameInfo\n * @param {{header: FrameHeader, chunk: Buffer, offset: Number}} item\n */\nParser.prototype.getFrameBuffer = function (frameInfo, item) {\n  frameInfo.buffers.push(item.chunk);\n  var result = Buffer.concat(frameInfo.buffers, frameInfo.bodyLength);\n  frameInfo.buffers = null;\n  return result;\n};\n\n/**\n * Tries to read the result in the body of a message\n * @param frameInfo Frame information, header / metadata\n * @param {FrameReader} reader\n */\nParser.prototype.parseResult = function (frameInfo, reader) {\n  var result;\n  // As we might be streaming and the frame buffer might not be complete,\n  // read the metadata and different types of result values in a try-catch.\n  // Store the reader position\n  var originalOffset = reader.offset;\n  try {\n    if (!frameInfo.meta) {\n      frameInfo.kind = reader.readInt();\n      // Spec 4.2.5\n      switch (frameInfo.kind) {\n        case types.resultKind.voidResult:\n          result = { header: frameInfo.header, flags: frameInfo.flagsInfo };\n          break;\n        case types.resultKind.rows:\n          // Parse the rows metadata, the rest of the response is going to be parsed afterwards\n          frameInfo.meta = reader.readMetadata(frameInfo.kind);\n          break;\n        case types.resultKind.setKeyspace:\n          result = { header: frameInfo.header, keyspaceSet: reader.readString(), flags: frameInfo.flagsInfo };\n          break;\n        case types.resultKind.prepared:\n          var preparedId = utils.copyBuffer(reader.readShortBytes());\n          frameInfo.meta = reader.readMetadata(frameInfo.kind);\n          result = { header: frameInfo.header, id: preparedId, meta: frameInfo.meta, flags: frameInfo.flagsInfo };\n          break;\n        case types.resultKind.schemaChange:\n          result = { header: frameInfo.header, schemaChange: reader.parseSchemaChange(), flags: frameInfo.flagsInfo };\n          break;\n        default:\n          //noinspection ExceptionCaughtLocallyJS\n          throw errors.DriverInternalError('Unexpected result kind: ' + frameInfo.kind);\n      }\n    }\n  }\n  catch (e) {\n    return this.handleParsingError(e, frameInfo, reader, originalOffset);\n  }\n  if (result) {\n    if (frameInfo.emitted) {\n      // It may contain additional metadata and info that it's not being parsed\n      return;\n    }\n    frameInfo.emitted = true;\n    return this.push(result);\n  }\n  // Its a `Rows` result\n  if (reader.remainingLength() > 0) {\n    this.parseRows(frameInfo, reader);\n  }\n};\n\n/**\n * @param frameInfo\n * @param {FrameReader} reader\n */\nParser.prototype.parseRows = function (frameInfo, reader) {\n  if (frameInfo.parsingError) {\n    //No more processing on this frame\n    return;\n  }\n  if (frameInfo.rowLength === undefined) {\n    try {\n      frameInfo.rowLength = reader.readInt();\n    }\n    catch (e) {\n      return this.handleParsingError(e, frameInfo, reader);\n    }\n  }\n  if (frameInfo.rowLength === 0) {\n    return this.push({\n      header: frameInfo.header,\n      result: { rows: utils.emptyArray, meta: frameInfo.meta, flags: frameInfo.flagsInfo }\n    });\n  }\n  var meta = frameInfo.meta;\n  frameInfo.rowIndex = frameInfo.rowIndex || 0;\n  for (var i = frameInfo.rowIndex; i < frameInfo.rowLength; i++) {\n    var rowOffset = reader.offset;\n    var row = new types.Row(meta.columns);\n    var cellBuffer;\n    for (var j = 0; j < meta.columns.length; j++ ) {\n      var c = meta.columns[j];\n      try {\n        cellBuffer = reader.readBytes();\n      }\n      catch (e) {\n        return this.handleParsingError(e, frameInfo, reader, rowOffset, i);\n      }\n      try {\n        row[c.name] = this.encoder.decode(cellBuffer, c.type);\n      }\n      catch (e) {\n        //Something went wrong while decoding, we are not going to be able to recover\n        return this.handleParsingError(e, frameInfo, null);\n      }\n    }\n    this.push({\n      header: frameInfo.header,\n      row: row,\n      meta: frameInfo.meta,\n      byRow: frameInfo.byRow,\n      length: frameInfo.rowLength,\n      flags: frameInfo.flagsInfo\n    });\n  }\n};\n\n/**\n * Sets parser options (ie: how to yield the results as they are parsed)\n * @param {Number} id Id of the stream\n * @param options\n */\nParser.prototype.setOptions = function (id, options) {\n  if (this.frames[id.toString()]) {\n    throw new types.DriverError('There was already state for this frame');\n  }\n  this.frames[id.toString()] = options;\n};\n\n/**\n * Gets the frame info from the internal state.\n * In case it is not there, it creates it.\n * In case the frame ended\n */\nParser.prototype.frameState = function (item) {\n  var frameInfo = this.frames[item.header.streamId];\n  if (!frameInfo) {\n    frameInfo = {};\n    if (!item.frameEnded) {\n      //store it in the frames\n      this.frames[item.header.streamId] = frameInfo;\n    }\n  }\n  else if (item.frameEnded) {\n    //if it was already stored, remove it\n    delete this.frames[item.header.streamId];\n  }\n  frameInfo.header = item.header;\n  return frameInfo;\n};\n\n/**\n * Handles parsing error: pushing an error if its unexpected or buffer the cell if its streaming\n * @param {Error} e\n * @param frameInfo\n * @param {FrameReader} reader\n * @param {Number} [originalOffset]\n * @param {Number} [rowIndex]\n */\nParser.prototype.handleParsingError = function (e, frameInfo, reader, originalOffset, rowIndex) {\n  if (reader && frameInfo.isStreaming && (e instanceof RangeError)) {\n    //A controlled error, buffer from offset and move on\n    return this.bufferResultCell(frameInfo, reader, originalOffset, rowIndex, e.expectedLength);\n  }\n  frameInfo.parsingError = true;\n  frameInfo.cellBuffer = null;\n  this.push({ header: frameInfo.header, error: e });\n};\n\n/**\n * When streaming, it buffers data since originalOffset.\n * @param frameInfo\n * @param {FrameReader} reader\n * @param {Number} [originalOffset]\n * @param {Number} [rowIndex]\n * @param {Number} [expectedLength]\n */\nParser.prototype.bufferResultCell = function (frameInfo, reader, originalOffset, rowIndex, expectedLength) {\n  if (!originalOffset && originalOffset !== 0) {\n    originalOffset = reader.offset;\n  }\n  frameInfo.rowIndex = rowIndex;\n  var buffer = reader.slice(originalOffset);\n  frameInfo.cellBuffer = {\n    parts: [ buffer ],\n    byteLength: buffer.length,\n    expectedLength: expectedLength\n  };\n};\n\n/**\n * Represents a writable streams that emits results\n */\nfunction ResultEmitter(options) {\n  Writable.call(this, options);\n  /**\n   * Stores the rows for frames that needs to be yielded as one result with many rows\n   */\n  this.rowBuffer = {};\n}\n\nutil.inherits(ResultEmitter, Writable);\n\nResultEmitter.prototype._write = function (item, encoding, callback) {\n  var error = null;\n  try {\n    this.each(item);\n  }\n  catch (err) {\n    error = err;\n  }\n  callback(error);\n};\n\n\n/**\n * Analyzes the item and emit the corresponding event\n */\nResultEmitter.prototype.each = function (item) {\n  if (item.error || item.result) {\n    //Its either an error or an empty array rows\n    //no transformation needs to be made\n    return this.emit('result', item.header, item.error, item.result);\n  }\n  if (item.frameEnded) {\n    return this.emit('frameEnded', item.header);\n  }\n  if (item.byRow) {\n    //it should be yielded by row\n    return this.emit('row', item.header, item.row, item.meta, item.length, item.flags);\n  }\n  if (item.row) {\n    //it should be yielded as a result\n    //it needs to be buffered to an array of rows\n    return this.bufferAndEmit(item);\n  }\n  if (item.event) {\n    //its an event from Cassandra\n    return this.emit('nodeEvent', item.header, item.event);\n  }\n  //its a raw response (object with flags)\n  return this.emit('result', item.header, null, item);\n};\n\n/**\n * Buffers the rows until the result set is completed and emits the result event.\n */\nResultEmitter.prototype.bufferAndEmit = function (item) {\n  var rows = this.rowBuffer[item.header.streamId];\n  if (!rows) {\n    rows = this.rowBuffer[item.header.streamId] = [];\n  }\n  rows.push(item.row);\n  if (rows.length === item.length) {\n    this.emit('result', item.header, null, { rows: rows, meta: item.meta, flags: item.flags});\n    delete this.rowBuffer[item.header.streamId];\n  }\n};\n\nexports.Protocol = Protocol;\nexports.Parser = Parser;\nexports.ResultEmitter = ResultEmitter;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/readers.js":"'use strict';\n\nvar utils = require('./utils');\nvar types = require('./types');\nvar errors = require('./errors');\n\n/**\n * Information on the formatting of the returned rows\n */\nvar resultFlag = {\n  globalTablesSpec:   0x0001,\n  hasMorePages:       0x0002,\n  noMetadata:         0x0004\n};\n\n/**\n * Buffer forward reader of CQL binary frames\n * @param {FrameHeader} header\n * @param {Buffer} body\n * @param {Number} [offset]\n */\nfunction FrameReader(header, body, offset) {\n  this.header = header;\n  this.opcode = header.opcode;\n  this.offset = offset || 0;\n  this.buf = body;\n}\n\nFrameReader.prototype.remainingLength = function () {\n  return this.buf.length - this.offset;\n};\n\nFrameReader.prototype.getBuffer = function () {\n  return this.buf;\n};\n\n/**\n * Slices the underlining buffer\n * @param {Number} begin\n * @param {Number} [end]\n * @returns {Buffer}\n */\nFrameReader.prototype.slice = function (begin, end) {\n  if (typeof end === 'undefined') {\n    end = this.buf.length;\n  }\n  return this.buf.slice(begin, end);\n};\n\n/**\n * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)\n */\nFrameReader.prototype.unshift = function (bytes) {\n  if (this.offset > 0) {\n    throw new Error('Can not modify the underlying buffer if already read');\n  }\n  this.buf = Buffer.concat([bytes, this.buf], bytes.length + this.buf.length);\n};\n\n/**\n * Reads any number of bytes and moves the offset.\n * if length not provided or it's larger than the remaining bytes, reads to end.\n * @param length\n * @returns {Buffer}\n */\nFrameReader.prototype.read = function (length) {\n  var end = this.buf.length;\n  if (typeof length !== 'undefined' && this.offset + length < this.buf.length) {\n    end = this.offset + length;\n  }\n  var bytes = this.slice(this.offset, end);\n  this.offset = end;\n  return bytes;\n};\n\n/**\n * Moves the reader cursor to the end\n */\nFrameReader.prototype.toEnd = function () {\n  this.offset = this.buf.length;\n};\n\n/**\n * Reads a BE Int and moves the offset\n * @returns {Number}\n */\nFrameReader.prototype.readInt = function() {\n  var result = this.buf.readInt32BE(this.offset);\n  this.offset += 4;\n  return result;\n};\n\n/** @returns {Number} */\nFrameReader.prototype.readShort = function () {\n  var result = this.buf.readUInt16BE(this.offset);\n  this.offset += 2;\n  return result;\n};\n\nFrameReader.prototype.readByte = function () {\n  var result = this.buf.readUInt8(this.offset);\n  this.offset += 1;\n  return result;\n};\n\nFrameReader.prototype.readString = function () {\n  var length = this.readShort();\n  this.checkOffset(length);\n  var result = this.buf.toString('utf8', this.offset, this.offset+length);\n  this.offset += length;\n  return result;\n};\n\n/**\n * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.\n * @param {Number} newLength\n */\nFrameReader.prototype.checkOffset = function (newLength) {\n  if (this.offset + newLength > this.buf.length) {\n    var err = new RangeError('Trying to access beyond buffer length');\n    err.expectedLength = newLength;\n    throw err;\n  }\n};\n\n/**\n * Reads a protocol string list\n * @returns {Array}\n */\nFrameReader.prototype.readStringList = function () {\n  var length = this.readShort();\n  var list = new Array(length);\n  for (var i = 0; i < length; i++) {\n    list[i] = this.readString();\n  }\n  return list;\n};\n\n/**\n * Reads the amount of bytes that the field has and returns them (slicing them).\n * @returns {Buffer}\n */\nFrameReader.prototype.readBytes = function () {\n  var length = this.readInt();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n  return this.read(length);\n};\n\nFrameReader.prototype.readShortBytes = function () {\n  var length = this.readShort();\n  if (length < 0) {\n    return null;\n  }\n  this.checkOffset(length);\n  return this.read(length);\n};\n\n/**\n * Reads an associative array of strings as keys and bytes as values\n * @returns {Object}\n */\nFrameReader.prototype.readBytesMap = function () {\n  //A [short] n, followed by n pair <k><v> where <k> is a\n  //[string] and <v> is a [bytes].\n  var length = this.readShort();\n  if (length < 0) {\n    return null;\n  }\n  var map = {};\n  for (var i = 0; i < length; i++) {\n    map[this.readString()] = this.readBytes();\n  }\n  return map;\n};\n\n/**\n * Reads a data type definition\n * @returns {{code: Number, info: Object|null}} An array of 2 elements\n */\nFrameReader.prototype.readType = function () {\n  var i;\n  var type = {\n    code: this.readShort(),\n    type: null\n  };\n  switch (type.code) {\n    case types.dataTypes.custom:\n      type.info = this.readString();\n      break;\n    case types.dataTypes.list:\n    case types.dataTypes.set:\n      type.info = this.readType();\n      break;\n    case types.dataTypes.map:\n      type.info = [this.readType(), this.readType()];\n      break;\n    case types.dataTypes.udt:\n      type.info = {\n        keyspace: this.readString(),\n        name: this.readString(),\n        fields: new Array(this.readShort())\n      };\n      for (i = 0; i < type.info.fields.length; i++) {\n        type.info.fields[i] = {\n          name: this.readString(),\n          type: this.readType()\n        };\n      }\n      break;\n    case types.dataTypes.tuple:\n      type.info = new Array(this.readShort());\n      for (i = 0; i < type.info.length; i++) {\n        type.info[i] = this.readType();\n      }\n      break;\n  }\n  return type;\n};\n\n/**\n * Reads an Ip address and port\n * @returns {{address: exports.InetAddress, port: Number}}\n */\nFrameReader.prototype.readInet = function () {\n  var length = this.readByte();\n  var address = this.read(length);\n  return {address: new types.InetAddress(address), port: this.readInt()};\n};\n\n/**\n * Reads the body bytes corresponding to the flags\n * @returns {{traceId: Uuid, warnings: Array, customPayload}}\n * @throws {RangeError}\n */\nFrameReader.prototype.readFlagsInfo = function () {\n  if (this.header.flags === 0) {\n    return utils.emptyObject;\n  }\n  var result = {};\n  if (this.header.flags & types.frameFlags.tracing) {\n    this.checkOffset(16);\n    result.traceId = new types.Uuid(utils.copyBuffer(this.read(16)));\n  }\n  if (this.header.flags & types.frameFlags.warning) {\n    result.warnings = this.readStringList();\n  }\n  if (this.header.flags & types.frameFlags.customPayload) {\n    result.customPayload = this.readBytesMap();\n  }\n  return result;\n};\n\n/**\n * Reads the metadata from a row or a prepared result response\n * @param {Number} kind\n * @returns {Object}\n * @throws {RangeError}\n */\nFrameReader.prototype.readMetadata = function (kind) {\n  var i;\n  //Determines if its a prepared metadata\n  var isPrepared = (kind === types.resultKind.prepared);\n  var meta = {};\n  //as used in Rows and Prepared responses\n  var flags = this.readInt();\n\n  var columnLength = this.readInt();\n  if (this.header.version > 3 && isPrepared) {\n    //read the pk columns\n    meta.partitionKeys = new Array(this.readInt());\n    for (i = 0; i < meta.partitionKeys.length; i++) {\n      meta.partitionKeys[i] = this.readShort();\n    }\n  }\n  if (flags & resultFlag.hasMorePages) {\n    meta.pageState = utils.copyBuffer(this.readBytes());\n  }\n  if (flags & resultFlag.globalTablesSpec) {\n    meta.global_tables_spec = true;\n    meta.keyspace = this.readString();\n    meta.table = this.readString();\n  }\n  meta.columns = new Array(columnLength);\n  meta.columnsByName = utils.emptyObject;\n  if (isPrepared) {\n    //for prepared metadata, we will need a index of the columns (param) by name\n    meta.columnsByName = {};\n  }\n  for (i = 0; i < columnLength; i++) {\n    var col = {};\n    if(!meta.global_tables_spec) {\n      col.ksname = this.readString();\n      col.tablename = this.readString();\n    }\n    col.name = this.readString();\n    col.type = this.readType();\n    meta.columns[i] = col;\n    if (isPrepared) {\n      meta.columnsByName[col.name] = i;\n    }\n  }\n\n  return meta;\n};\n\n/**\n * Reads the error from the frame\n * @throws {RangeError}\n * @returns {exports.ResponseError}\n */\nFrameReader.prototype.readError = function () {\n  var code = this.readInt();\n  var message = this.readString();\n  var err = new errors.ResponseError(code, message);\n  //read extra info\n  switch (code) {\n    case types.responseErrorCodes.unavailableException:\n      err.consistencies = this.readShort();\n      err.required = this.readInt();\n      err.alive = this.readInt();\n      break;\n    case types.responseErrorCodes.readTimeout:\n    case types.responseErrorCodes.readFailure:\n      err.consistencies = this.readShort();\n      err.received = this.readInt();\n      err.blockFor = this.readInt();\n      if (code === types.responseErrorCodes.readFailure) {\n        err.failures = this.readInt();\n      }\n      err.isDataPresent = this.readByte();\n      break;\n    case types.responseErrorCodes.writeTimeout:\n    case types.responseErrorCodes.writeFailure:\n      err.consistencies = this.readShort();\n      err.received = this.readInt();\n      err.blockFor = this.readInt();\n      if (code === types.responseErrorCodes.writeFailure) {\n        err.failures = this.readInt();\n      }\n      err.writeType = this.readString();\n      break;\n    case types.responseErrorCodes.unprepared:\n      err.queryId = utils.copyBuffer(this.readShortBytes());\n      break;\n    case types.responseErrorCodes.functionFailure:\n      err.keyspace = this.readString();\n      err.functionName = this.readString();\n      err.argTypes = this.readStringList();\n      break;\n  }\n  return err;\n};\n\n/**\n * Reads an event from Cassandra and returns the detail\n * @returns {{eventType: String, inet: {address: Buffer, port: Number}}, *}\n */\nFrameReader.prototype.readEvent = function () {\n  var eventType = this.readString();\n  switch (eventType) {\n    case types.protocolEvents.topologyChange:\n      return {\n        added: this.readString() === 'NEW_NODE',\n        inet: this.readInet(),\n        eventType: eventType};\n    case types.protocolEvents.statusChange:\n      return {\n        up: this.readString() === 'UP',\n        inet: this.readInet(),\n        eventType: eventType};\n    case types.protocolEvents.schemaChange:\n      return this.parseSchemaChange();\n  }\n  //Forward compatibility\n  return { eventType: eventType};\n};\n\nFrameReader.prototype.parseSchemaChange = function () {\n  var result;\n  if (this.header.version < 3) {\n    //v1/v2: 3 strings, the table value can be empty\n    result = {\n      eventType: types.protocolEvents.schemaChange,\n      schemaChangeType: this.readString(),\n      keyspace: this.readString(),\n      table: this.readString()\n    };\n    result.isKeyspace = !result.table;\n    return result;\n  }\n  //v3+: 3 or 4 strings: change_type, target, keyspace and (table, type, functionName or aggregate)\n  result = {\n    eventType: types.protocolEvents.schemaChange,\n    schemaChangeType: this.readString(),\n    target: this.readString(),\n    keyspace: this.readString(),\n    table: null,\n    udt: null,\n    signature: null\n  };\n  result.isKeyspace = result.target === 'KEYSPACE';\n  switch (result.target) {\n    case 'TABLE':\n      result.table = this.readString();\n      break;\n    case 'TYPE':\n      result.udt = this.readString();\n      break;\n    case 'FUNCTION':\n      result.functionName = this.readString();\n      result.signature = this.readStringList();\n      break;\n    case 'AGGREGATE':\n      result.aggregate = this.readString();\n      result.signature = this.readStringList();\n  }\n  return result;\n};\n\nexports.FrameReader = FrameReader;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/stream-id-stack.js":"\"use strict\";\n\n/**\n * Group size\n * @type {number}\n */\nvar groupSize = 128;\n/**\n * Number used to right shift ids to allocate them into groups\n * @const\n * @type {number}\n */\nvar shiftToGroup = 7;\n/**\n * Amount of groups that can be released per time\n * If it grows larger than 4 groups (128 * 4), groups can be released\n * @const\n * @type {number}\n */\nvar releasableSize = 4;\n/**\n * 32K possible stream ids depending for protocol v3 and above\n * @const\n * @type {number}\n */\nvar maxGroupsFor2Bytes = 256;\n/**\n * Delay used to check if groups can be released\n * @const\n * @type {number}\n */\nvar releaseDelay = 5000;\n/**\n * Represents a queue of ids from 0 to maximum stream id supported by the protocol version.\n * Clients can dequeue a stream id using {@link StreamIdStack#shift()} and enqueue (release) using {@link StreamIdStack#push()}\n * @param {Number} version Protocol version\n * @constructor\n */\nfunction StreamIdStack(version) {\n  //Ecmascript Number is 64-bit double, it can be optimized by the engine into a 32-bit int, but nothing below that.\n  //We try to allocate as few as possible in arrays of 128\n  this.currentGroup = generateGroup(0);\n  this.groupIndex = 0;\n  this.groups = [this.currentGroup];\n  this.releaseTimeout = null;\n  this.setVersion(version);\n  /**\n   * Returns the amount of ids currently in use\n   * @member {number}\n   */\n  this.inUse = 0;\n}\n\n/**\n * Sets the protocol version\n * @param {Number} version\n */\nStreamIdStack.prototype.setVersion = function (version) {\n  //128 or 32K stream ids depending on the protocol version\n  this.maxGroups = version < 3 ? 1 : maxGroupsFor2Bytes;\n};\n\n/**\n * Dequeues an id.\n * Similar to {@link Array#pop()}.\n * @returns {Number} Returns an id or null\n */\nStreamIdStack.prototype.pop = function () {\n  var id = this.currentGroup.pop();\n  if (typeof id !== 'undefined') {\n    this.inUse++;\n    return id;\n  }\n  //try to use the following groups\n  while (this.groupIndex < this.groups.length - 1) {\n    //move to the following group\n    this.currentGroup = this.groups[++this.groupIndex];\n    //try dequeue\n    id = this.currentGroup.pop();\n    if (typeof id !== 'undefined') {\n      this.inUse++;\n      return id;\n    }\n  }\n  return this._tryCreateGroup();\n};\n/**\n * Enqueue an id for future use.\n * Similar to {@link Array#push()}.\n * @param {Number} id\n */\nStreamIdStack.prototype.push = function (id) {\n  this.inUse--;\n  var groupIndex = id >> shiftToGroup;\n  var group = this.groups[groupIndex];\n  group.push(id);\n  if (groupIndex < this.groupIndex) {\n    //Set the lower group to be used to dequeue from\n    this.groupIndex = groupIndex;\n    this.currentGroup = group;\n  }\n  this._tryIssueRelease();\n};\n\n/**\n * Clears all timers\n */\nStreamIdStack.prototype.clear = function () {\n  if (this.releaseTimeout) {\n    clearTimeout(this.releaseTimeout);\n    this.releaseTimeout = null;\n  }\n};\n\n/**\n * Tries to create an additional group and returns a new id\n * @returns {Number} Returns a new id or null if it's not possible to create a new group\n * @private\n */\nStreamIdStack.prototype._tryCreateGroup = function () {\n  if (this.groups.length === this.maxGroups) {\n    //we can have an additional group\n    return null;\n  }\n  //Add a new group at the last position\n  this.groupIndex = this.groups.length;\n  //Using 128 * groupIndex as initial value\n  this.currentGroup = generateGroup(this.groupIndex << shiftToGroup);\n  this.groups.push(this.currentGroup);\n  this.inUse++;\n  return this.currentGroup.pop();\n};\n\nStreamIdStack.prototype._tryIssueRelease = function () {\n  if (this.releaseTimeout || this.groups.length <= releasableSize) {\n    //Nothing to release or a release delay has been issued\n    return;\n  }\n  var self = this;\n  this.releaseTimeout = setTimeout(function () {\n    self._releaseGroups();\n  }, releaseDelay);\n};\n\nStreamIdStack.prototype._releaseGroups = function () {\n  var counter = 0;\n  var index = this.groups.length - 1;\n  //only release up to n groups (n = releasable size)\n  //shrink back up to n groups not all the way up to 1\n  while (counter++ < releasableSize && this.groups.length > releasableSize && index > this.groupIndex) {\n    if (this.groups[index].length !== groupSize) {\n      //the group is being used\n      break;\n    }\n    this.groups.pop();\n    index--;\n  }\n  this.releaseTimeout = null;\n  //Issue next release if applies\n  this._tryIssueRelease();\n};\n\nfunction generateGroup(initialValue) {\n  var arr = new Array(groupSize);\n  var upperBound = initialValue + groupSize - 1;\n  for (var i = 0; i < groupSize; i++) {\n    arr[i] = upperBound - i;\n  }\n  return arr;\n}\n\nmodule.exports = StreamIdStack;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/index.js":"\"use strict\";\nvar events = require('events');\nvar util = require('util');\n/**\n * Module containing classes and fields related to metadata.\n * @module metadata\n */\nvar t = require('../tokenizer');\nvar utils = require('../utils');\nvar errors = require('../errors');\nvar types = require('../types');\nvar requests = require('../requests');\nvar schemaParserFactory = require('./schema-parser');\n\n/**\n * @const\n * @private\n */\nvar _selectTraceSession = \"SELECT * FROM system_traces.sessions WHERE session_id=%s\";\n/**\n * @const\n * @private\n */\nvar _selectTraceEvents = \"SELECT * FROM system_traces.events WHERE session_id=%s\";\n/**\n * @const\n * @private\n */\nvar _selectSchemaVersionPeers = \"SELECT schema_version FROM system.peers\";\n/**\n * @const\n * @private\n */\nvar _selectSchemaVersionLocal = \"SELECT schema_version FROM system.local\";\n/**\n * @const\n * @private\n */\nvar _traceMaxAttemps = 5;\n/**\n * @const\n * @private\n */\nvar _traceAttemptDelay = 200;\n\n/**\n * Represents cluster and schema information.\n * The metadata class acts as a internal state of the driver.\n * @param {ClientOptions} options\n * @param {ControlConnection} controlConnection Control connection used to retrieve information.\n * @constructor\n */\nfunction Metadata (options, controlConnection) {\n  Object.defineProperty(this, 'options', { value: options, enumerable: false, writable: false});\n  Object.defineProperty(this, 'controlConnection', { value: controlConnection, enumerable: false, writable: false});\n  this.keyspaces = {};\n  this.clearPrepared();\n  this._schemaParser = schemaParserFactory.getByVersion(controlConnection, this.getUdt.bind(this));\n}\n\n/**\n * Sets the cassandra version\n * @internal\n * @ignore\n * @param {Array.<Number>} version\n */\nMetadata.prototype.setCassandraVersion = function (version) {\n  this._schemaParser = schemaParserFactory.getByVersion(\n    this.controlConnection, this.getUdt.bind(this), version, this._schemaParser);\n};\n\n/**\n * @ignore\n * @param {String} partitionerName\n */\nMetadata.prototype.setPartitioner = function (partitionerName) {\n  if (/RandomPartitioner$/.test(partitionerName)) {\n    return this.tokenizer = new t.RandomTokenizer();\n  }\n  if (/ByteOrderedPartitioner$/.test(partitionerName)) {\n    return this.tokenizer = new t.ByteOrderedTokenizer();\n  }\n  return this.tokenizer = new t.Murmur3Tokenizer();\n};\n\n/**\n * Populates the information regarding primary replica per token, datacenters (+ racks) and sorted token ring.\n * @ignore\n * @param {HostMap} hosts\n */\nMetadata.prototype.buildTokens = function (hosts) {\n  if (!this.tokenizer) {\n    return this.log('error', 'Tokenizer could not be determined');\n  }\n  //Get a sorted array of tokens\n  var allSorted = [];\n  //Get a map of <token, primaryHost>\n  var primaryReplicas = {};\n  //Depending on the amount of tokens, this could be an expensive operation\n  var hostArray = hosts.values();\n  var parser = this.tokenizer.parse;\n  var compare = this.tokenizer.compare;\n  var stringify = this.tokenizer.stringify;\n  var datacenters = {};\n  hostArray.forEach(function (h) {\n    if (!h.tokens) {\n      return;\n    }\n    h.tokens.forEach(function (tokenString) {\n      var token = parser(tokenString);\n      utils.insertSorted(allSorted, token, compare);\n      primaryReplicas[stringify(token)] = h;\n    });\n    var dc = datacenters[h.datacenter];\n    if (!dc) {\n      dc = datacenters[h.datacenter] = {\n        hostLength: 0,\n        racks: new utils.HashSet()\n      };\n    }\n    dc.hostLength++;\n    dc.racks.add(h.rack);\n  });\n  //Primary replica for given token\n  this.primaryReplicas = primaryReplicas;\n  //All the tokens in ring order\n  this.ring = allSorted;\n  //Datacenter metadata (host length and racks)\n  this.datacenters = datacenters;\n};\n\n/**\n * Gets the keyspace metadata information and updates the internal state of the driver.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the keyspaces metadata refresh completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {String} name Name of the keyspace.\n * @param {Function} [callback] Optional callback.\n */\nMetadata.prototype.refreshKeyspace = function (name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, true, function handler(cb) {\n    this._refreshKeyspaceCb(name, cb);\n  });\n};\n\n/**\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._refreshKeyspaceCb = function (name, callback) {\n  this.log('info', util.format('Retrieving keyspace %s metadata', name));\n  var self = this;\n  this._schemaParser.getKeyspace(name, function (err, ksInfo) {\n    if (err) {\n      self.log('error', 'There was an error while trying to retrieve keyspace information', err);\n      return callback(err);\n    }\n    if (!ksInfo) {\n      // the keyspace was dropped\n      delete self.keyspaces[name];\n      return callback();\n    }\n    // tokens are lazily init on the keyspace, once a replica from that keyspace is retrieved.\n    self.keyspaces[ksInfo.name] = ksInfo;\n    callback(null, ksInfo);\n  });\n};\n\n/**\n * Gets the metadata information of all the keyspaces and updates the internal state of the driver.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the keyspace metadata refresh completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {Boolean|Function} [waitReconnect] Determines if it should wait for reconnection in case the control connection is not\n * connected at the moment. Default: true.\n * @param {Function} [callback] Optional callback.\n */\nMetadata.prototype.refreshKeyspaces = function (waitReconnect, callback) {\n  if (typeof waitReconnect === 'function' || typeof waitReconnect === 'undefined') {\n    callback = waitReconnect;\n    waitReconnect = true;\n  }\n\n  return utils.promiseWrapper.call(this, this.options, callback, true, function handler(cb) {\n    this._refreshKeyspacesCb(waitReconnect, cb);\n  });\n};\n\n/**\n * @param {Boolean} waitReconnect\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._refreshKeyspacesCb = function (waitReconnect, callback) {\n  this.log('info', 'Retrieving keyspaces metadata');\n  var self = this;\n  this._schemaParser.getKeyspaces(waitReconnect, function getKeyspacesCallback(err, keyspaces) {\n    if (err) {\n      self.log('error', 'There was an error while trying to retrieve keyspaces information', err);\n      return callback(err);\n    }\n    self.keyspaces = keyspaces;\n    callback(null, keyspaces);\n  });\n};\n\n/**\n * Gets the host list representing the replicas that contain such partition.\n * <p>\n *   It uses the pre-loaded keyspace metadata to retrieve the replicas for a token for a given keyspace.\n *   When the keyspace metadata has not been loaded, it returns null.\n * </p>\n * @param {String} keyspaceName\n * @param {Buffer} tokenBuffer\n * @returns {Array}\n */\nMetadata.prototype.getReplicas = function (keyspaceName, tokenBuffer) {\n  if (!this.ring) {\n    return null;\n  }\n  var keyspace;\n  if (keyspaceName) {\n    keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      // the keyspace was not found, the metadata should be loaded beforehand\n      return null;\n    }\n  }\n  var token = this.tokenizer.hash(tokenBuffer);\n  var i = utils.binarySearch(this.ring, token, this.tokenizer.compare);\n  if (i < 0) {\n    i = ~i;\n  }\n  if (i >= this.ring.length) {\n    //it circled back\n    i = i % this.ring.length;\n  }\n  var closestToken = this.tokenizer.stringify(this.ring[i]);\n\n  if (!keyspaceName) {\n    return [this.primaryReplicas[closestToken]];\n  }\n  if (!keyspace.replicas) {\n    //Calculate replicas the first time for the keyspace\n    keyspace.replicas = keyspace.tokenToReplica(this.tokenizer, this.ring, this.primaryReplicas, this.datacenters);\n  }\n  return keyspace.replicas[closestToken];\n};\n\nMetadata.prototype.log = utils.log;\n\n/**\n * Gets the metadata information already stored associated to a prepared statement\n * @param {String} keyspaceName\n * @param {String} query\n * @ignore\n */\nMetadata.prototype.getPreparedInfo = function (keyspaceName, query) {\n  //overflow protection\n  if (this.preparedQueries.__length >= this.options.maxPrepared) {\n    var toRemove;\n    this.log('warning',\n      'Prepared statements exceeded maximum. This could be caused by preparing queries that contain parameters');\n    var existingKeys = Object.keys(this.preparedQueries);\n    for (var i = 0; i < existingKeys.length; i++) {\n      var key = existingKeys[i];\n      if (this.preparedQueries[key].queryId) {\n        toRemove = key;\n        break;\n      }\n    }\n    if (toRemove) {\n      delete this.preparedQueries[toRemove];\n      this.preparedQueries.__length--;\n    }\n  }\n  var name = ( keyspaceName || '' ) + query;\n  var info = this.preparedQueries[name];\n  if (!info) {\n    info = new events.EventEmitter();\n    info.setMaxListeners(0);\n    this.preparedQueries[name] = info;\n    this.preparedQueries.__length++;\n  }\n  return info;\n};\n\n/**\n * Clears the internal state related to the prepared statements.\n * Following calls to the Client using the prepare flag will re-prepare the statements.\n */\nMetadata.prototype.clearPrepared = function () {\n  this.preparedQueries = {\"__length\": 0};\n};\n\n/**\n * Gets the definition of an user-defined type.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same UDT definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the UDT.\n * @param {Function} [callback] The callback to invoke when retrieval completes.\n */\nMetadata.prototype.getUdt = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getUdtCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getUdtCb = function (keyspaceName, name, callback) {\n  var cache;\n  if (this.options.isMetadataSyncEnabled) {\n    var keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.udts;\n  }\n  this._schemaParser.getUdt(keyspaceName, name, cache, callback);\n};\n\n/**\n * Gets the definition of a table.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same table definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the Table.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link TableMetadata} as\n * second parameter.\n */\nMetadata.prototype.getTable = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getTableCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getTableCb = function (keyspaceName, name, callback) {\n  var cache;\n  if (this.options.isMetadataSyncEnabled) {\n    var keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.tables;\n  }\n  this._schemaParser.getTable(keyspaceName, name, cache, callback);\n};\n\n/**\n * Gets the definition of CQL functions for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace.\n * @param {String} name Name of the Function.\n * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link SchemaFunction}\n * as second parameter.\n */\nMetadata.prototype.getFunctions = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getFunctionsCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getFunctionsCb = function (keyspaceName, name, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(\n      new errors.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata'));\n  }\n  this._getFunctions(keyspaceName, name, false, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, utils.objectValues(functionsMap));\n  });\n};\n\n/**\n * Gets a definition of CQL function for a given name and signature.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same function definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the Function\n * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link SchemaFunction} as second\n * parameter.\n */\nMetadata.prototype.getFunction = function (keyspaceName, name, signature, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getSingleFunctionCb(keyspaceName, name, signature, false, cb);\n  });\n};\n\n/**\n * Gets the definition of CQL aggregate for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same aggregates definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the Function\n * @param {Function} [callback] The callback with the err as a first parameter and the array of {@link Aggregate} as\n * second parameter.\n */\nMetadata.prototype.getAggregates = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getAggregatesCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getAggregatesCb = function (keyspaceName, name, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(new errors.ArgumentError('You must provide the keyspace name and cql aggregate name to retrieve the metadata'));\n  }\n  this._getFunctions(keyspaceName, name, true, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    callback(null, utils.objectValues(functionsMap));\n  });\n};\n\n/**\n * Gets a definition of CQL aggregate for a given name and signature.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n * When trying to retrieve the same aggregate definition concurrently, it will query once and invoke all callbacks\n * with the retrieved information.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the aggregate\n * @param {Array.<String>|Array.<{code, info}>} signature Array of types of the parameters.\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link Aggregate} as second parameter.\n */\nMetadata.prototype.getAggregate = function (keyspaceName, name, signature, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getSingleFunctionCb(keyspaceName, name, signature, true, cb);\n  });\n};\n\n/**\n * Gets the definition of a CQL materialized view for a given name.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * <p>\n *   Note that, unlike the rest of the {@link Metadata} methods, this method does not cache the result for following\n *   calls, as the current version of the Cassandra native protocol does not support schema change events for\n *   materialized views. Each call to this method will produce one or more queries to the cluster.\n * </p>\n * @param {String} keyspaceName Name of the keyspace\n * @param {String} name Name of the materialized view\n * @param {Function} [callback] The callback with the err as a first parameter and the {@link MaterializedView} as\n * second parameter.\n */\nMetadata.prototype.getMaterializedView = function (keyspaceName, name, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getMaterializedViewCb(keyspaceName, name, cb);\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getMaterializedViewCb = function (keyspaceName, name, callback) {\n  var cache;\n  if (this.options.isMetadataSyncEnabled) {\n    var keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = keyspace.views;\n  }\n  this._schemaParser.getMaterializedView(keyspaceName, name, cache, callback);\n};\n\n/**\n * Gets a map of cql function definitions or aggregates based on signature.\n * @param {String} keyspaceName\n * @param {String} name Name of the function or aggregate\n * @param {Boolean} aggregate\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getFunctions = function (keyspaceName, name, aggregate, callback) {\n  var cache;\n  if (this.options.isMetadataSyncEnabled) {\n    var keyspace = this.keyspaces[keyspaceName];\n    if (!keyspace) {\n      return callback(null, null);\n    }\n    cache = aggregate ? keyspace.aggregates : keyspace.functions;\n  }\n  this._schemaParser.getFunctions(keyspaceName, name, aggregate, cache, callback);\n};\n\n/**\n * Gets a single cql function or aggregate definition\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Array} signature\n * @param {Boolean} aggregate\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getSingleFunctionCb = function (keyspaceName, name, signature, aggregate, callback) {\n  if (typeof callback !== 'function') {\n    throw new errors.ArgumentError('Callback is not a function');\n  }\n  if (!keyspaceName || !name) {\n    return callback(\n      new errors.ArgumentError('You must provide the keyspace name and cql function name to retrieve the metadata'));\n  }\n  if (!util.isArray(signature)) {\n    return callback(new errors.ArgumentError('Signature must be an array of types'));\n  }\n  try {\n    signature = signature.map(function (item) {\n      if (typeof item === 'string') {\n        return item;\n      }\n      return types.getDataTypeNameByCode(item);\n    });\n  }\n  catch (err) {\n    return callback(err);\n  }\n  this._getFunctions(keyspaceName, name, aggregate, function (err, functionsMap) {\n    if (err) {\n      return callback(err, null);\n    }\n    var f;\n    if (functionsMap) {\n      f = functionsMap['(' + signature.join(',') + ')'];\n    }\n    callback(null, f || null);\n  });\n};\n\n/**\n * Gets the trace session generated by Cassandra when query tracing is enabled for the\n * query. The trace itself is stored in Cassandra in the <code>sessions</code> and\n * <code>events</code> table in the <code>system_traces</code> keyspace and can be\n * retrieve manually using the trace identifier.\n * <p>\n *   If a <code>callback</code> is provided, the callback is invoked when the metadata retrieval completes.\n *   Otherwise, it returns a <code>Promise</code>.\n * </p>\n * @param {Uuid} traceId Identifier of the trace session.\n * @param {Function} [callback] The callback with the err as first parameter and the query trace as second parameter.\n */\nMetadata.prototype.getTrace = function (traceId, callback) {\n  return utils.promiseWrapper.call(this, this.options, callback, false, function handler(cb) {\n    this._getTraceCb(traceId, cb);\n  });\n};\n\n/**\n * @param {Uuid} traceId\n * @param {Function} callback\n * @private\n */\nMetadata.prototype._getTraceCb = function (traceId, callback) {\n  var trace;\n  var attempts = 0;\n  var selectSession = util.format(_selectTraceSession, traceId);\n  var selectEvents = util.format(_selectTraceEvents, traceId);\n  var self = this;\n  utils.whilst(function condition() {\n    return !trace && (attempts++ < _traceMaxAttemps);\n  }, function iterator(next) {\n    self.controlConnection.query(selectSession, function (err, result) {\n      if (err) {\n        return next(err);\n      }\n      var sessionRow = result.rows[0];\n      if (!sessionRow || !sessionRow['duration']) {\n        return setTimeout(next, _traceAttemptDelay);\n      }\n      trace = {\n        requestType: sessionRow['request'],\n        coordinator: sessionRow['coordinator'],\n        parameters: sessionRow['parameters'],\n        startedAt: sessionRow['started_at'],\n        duration: sessionRow['duration'],\n        clientAddress: sessionRow['client'],\n        events: []\n      };\n      self.controlConnection.query(selectEvents, function (err, result) {\n        if (err) {\n          return next(err);\n        }\n        result.rows.forEach(function (row) {\n          trace.events.push({\n            id: row['event_id'],\n            activity: row['activity'],\n            source: row['source'],\n            elapsed: row['source_elapsed'],\n            thread: row['thread']\n          });\n        });\n        next();\n      });\n    });\n  }, function getTraceEnded(err) {\n    if (!err && !trace) {\n      err = new Error(util.format('Trace %s could not fully retrieved after %d attempts', traceId, _traceMaxAttemps));\n    }\n    callback(err, trace);\n  });\n};\n\n/**\n * Uses the metadata to fill the user provided parameter hints\n * @param {String} keyspace\n * @param {Array} hints\n * @param {Function} callback\n * @internal\n * @ignore\n */\nMetadata.prototype.adaptUserHints = function (keyspace, hints, callback) {\n  var udts = [];\n  //check for udts and get the metadata\n  function checkUdtTypes(type) {\n    if (type.code === types.dataTypes.udt) {\n      var udtName = type.info.split('.');\n      type.info = {\n        keyspace: udtName[0],\n        name: udtName[1]\n      };\n      if (!type.info.name) {\n        if (!keyspace) {\n          throw new TypeError('No keyspace specified for udt: ' + udtName.join('.'));\n        }\n        //use the provided keyspace\n        type.info.name = type.info.keyspace;\n        type.info.keyspace = keyspace;\n      }\n      udts.push(type);\n      return;\n    }\n    if (!type.info) {\n      return;\n    }\n    if (type.code === types.dataTypes.list || type.code === types.dataTypes.set) {\n      return checkUdtTypes(type.info);\n    }\n    if (type.code === types.dataTypes.map) {\n      checkUdtTypes(type.info[0]);\n      checkUdtTypes(type.info[1]);\n    }\n  }\n  for (var i = 0; i < hints.length; i++) {\n    var hint = hints[i];\n    if (typeof hint !== 'string') {\n      continue;\n    }\n    try {\n      var type = types.dataTypes.getByName(hint);\n      checkUdtTypes(type);\n      hints[i] = type;\n    }\n    catch (err) {\n      return callback(err);\n    }\n  }\n  var self = this;\n  utils.each(udts, function (type, next) {\n    self.getUdt(type.info.keyspace, type.info.name, function (err, udtInfo) {\n      if (err) {\n        return next(err);\n      }\n      if (!udtInfo) {\n        return next(new TypeError('User defined type not found: ' + type.info.keyspace + '.' + type.info.name));\n      }\n      type.info = udtInfo;\n      next();\n    });\n  }, callback);\n};\n\n/**\n * Uses the provided connection to query for the local schema version\n * @param {Connection} connection\n * @param {Function} callback\n * @internal\n * @ignore\n */\nMetadata.prototype.getLocalSchemaVersion = function (connection, callback) {\n  var request = new requests.QueryRequest(_selectSchemaVersionLocal, null, null);\n  connection.sendStream(request, utils.emptyObject, function (err, result) {\n    var version;\n    if (!err && result && result.rows && result.rows.length === 1) {\n      version = result.rows[0]['schema_version'];\n    }\n    callback(err, version);\n  });\n};\n\n/**\n * Uses the provided connection to query for peers' schema version\n * @param {Connection} connection\n * @param {Function} callback\n * @internal\n * @ignore\n */\nMetadata.prototype.getPeersSchemaVersions = function (connection, callback) {\n  var request = new requests.QueryRequest(_selectSchemaVersionPeers, null, null);\n  connection.sendStream(request, utils.emptyObject, function (err, result) {\n    var versions = [];\n    if (!err && result && result.rows) {\n      for (var i = 0; i < result.rows.length; i++) {\n        var schemaVersion = result.rows[i]['schema_version'];\n        if (schemaVersion) {\n          versions.push(schemaVersion);\n        }\n      }\n    }\n    callback(err, versions);\n  });\n};\n\nmodule.exports = Metadata;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/tokenizer.js":"'use strict';\nvar util = require('util');\n\nvar types = require('./types');\nvar Long = types.Long;\nvar Integer = types.Integer;\n\n/**\n * Represents a set of methods that are able to generate and parse tokens for the C* partitioner\n * @constructor\n */\nfunction Tokenizer() {\n\n}\n\n//noinspection JSUnusedLocalSymbols\n/**\n * Creates a token based on the Buffer value provided\n * @param {Buffer|Array} value\n */\nTokenizer.prototype.hash = function (value) {\n  throw new Error('You must implement a hash function for the tokenizer');\n};\n\n//noinspection JSUnusedLocalSymbols\n/**\n * Parses a token string and returns a representation of the token\n * @param {String} value\n */\nTokenizer.prototype.parse = function (value) {\n  throw new Error('You must implement a parse function for the tokenizer');\n};\n\n/**\n * Returns 0 if the values are equal, 1 if val1 is greater then val2 and -1 if val2 is greater than val1\n * @param val1\n * @param val2\n * @returns {number}\n */\nTokenizer.prototype.compare = function (val1, val2) {\n  if (val1 > val2) {\n    return 1;\n  }\n  if (val1 < val2) {\n    return -1;\n  }\n  return 0;\n};\n\nTokenizer.prototype.stringify = function (value) {\n  return value.toString();\n};\n\n/**\n * Uniformly distributes data across the cluster based on Cassandra flavored MurmurHash hash values.\n * @constructor\n */\nfunction Murmur3Tokenizer() {\n\n}\n\nutil.inherits(Murmur3Tokenizer, Tokenizer);\n\n/**\n * @param {Buffer|Array} value\n * @returns {Long}\n */\nMurmur3Tokenizer.prototype.hash = function (value) {\n  // This is an adapted version of the MurmurHash.hash3_x64_128 from Cassandra used\n  // for M3P. Compared to that methods, there's a few inlining of arguments and we\n  // only return the first 64-bits of the result since that's all M3 partitioner uses.\n\n  //Change to Array of signed Int8\n  var data = [];\n  for (var j = 0; j < value.length; j++)\n  {\n    var item = value[j];\n    if (item > 127) {\n      item = item - 256;\n    }\n    data.push(item);\n  }\n  var offset = 0;\n  var length = data.length;\n\n  var nblocks = length >> 4; // Process as 128-bit blocks.\n\n  var h1 = Long.fromNumber(0);\n  var h2 = Long.fromNumber(0);\n  var k1 = Long.fromNumber(0);\n  var k2 = Long.fromNumber(0);\n  //-0x783C846EEEBDAC2B\n  var c1 = Long.fromBits(0x114253d5, 0x87c37b91);\n  //0x4cf5ad432745937f\n  var c2 = Long.fromBits(0x2745937f, 0x4cf5ad43);\n\n  for (var i = 0; i < nblocks; i++) {\n    k1 = this.getBlock(data, offset, i * 2 + 0);\n    k2 = this.getBlock(data, offset, i * 2 + 1);\n\n    k1 = k1.multiply(c1);\n    k1 = this.rotl64(k1, 31);\n    k1 = k1.multiply(c2);\n\n    h1 = h1.xor(k1);\n    h1 = this.rotl64(h1, 27);\n    h1 = h1.add(h2);\n    h1 = h1.multiply(Long.fromNumber(5)).add(Long.fromNumber(0x52dce729));\n\n    k2 = k2.multiply(c2);\n    k2 = this.rotl64(k2, 33);\n    k2 = k2.multiply(c1);\n    h2 = h2.xor(k2);\n    h2 = this.rotl64(h2, 31);\n    h2 = h2.add(h1);\n    h2 = h2.multiply(Long.fromNumber(5)).add(Long.fromNumber(0x38495ab5));\n  }\n  //----------\n  // tail\n\n  // Advance offset to the unprocessed tail of the data.\n  offset += nblocks * 16;\n\n  k1 = Long.fromNumber(0);\n  k2 = Long.fromNumber(0);\n\n  /* eslint-disable no-fallthrough */\n  //noinspection FallThroughInSwitchStatementJS\n  switch(length & 15) {\n    case 15:\n      k2 = k2.xor(Long.fromNumber(data[offset+14]).shiftLeft(48));\n    case 14:\n      k2 = k2.xor(Long.fromNumber(data[offset+13]).shiftLeft(40));\n    case 13:\n      k2 = k2.xor(Long.fromNumber(data[offset+12]).shiftLeft(32));\n    case 12:\n      k2 = k2.xor(Long.fromNumber(data[offset+12]).shiftLeft(24));\n    case 11:\n      k2 = k2.xor(Long.fromNumber(data[offset+10]).shiftLeft(16));\n    case 10:\n      k2 = k2.xor(Long.fromNumber(data[offset+9]).shiftLeft(8));\n    case 9:\n      k2 = k2.xor(Long.fromNumber(data[offset+8]));\n      k2 = k2.multiply(c2);\n      k2 = this.rotl64(k2, 33);\n      k2 = k2.multiply(c1);\n      h2 = h2.xor(k2);\n    case 8:\n      k1 = k1.xor(Long.fromNumber(data[offset+7]).shiftLeft(56));\n    case 7:\n      k1 = k1.xor(Long.fromNumber(data[offset+6]).shiftLeft(48));\n    case 6:\n      k1 = k1.xor(Long.fromNumber(data[offset+5]).shiftLeft(40));\n    case 5:\n      k1 = k1.xor(Long.fromNumber(data[offset+4]).shiftLeft(32));\n    case 4:\n      k1 = k1.xor(Long.fromNumber(data[offset+3]).shiftLeft(24));\n    case 3:\n      k1 = k1.xor(Long.fromNumber(data[offset+2]).shiftLeft(16));\n    case 2:\n      k1 = k1.xor(Long.fromNumber(data[offset+1]).shiftLeft(8));\n    case 1:\n      k1 = k1.xor(Long.fromNumber(data[offset]));\n      k1 = k1.multiply(c1);\n      k1 = this.rotl64(k1,31);\n      k1 = k1.multiply(c2);\n      h1 = h1.xor(k1);\n  }\n  /* eslint-enable no-fallthrough */\n\n  h1 = h1.xor(length);\n  h2 = h2.xor(length);\n\n  h1 = h1.add(h2);\n  h2 = h2.add(h1);\n\n  h1 = this.fmix(h1);\n  h2 = this.fmix(h2);\n\n  h1 = h1.add(h2);\n\n  return h1;\n};\n\n\nMurmur3Tokenizer.prototype.getBlock = function (key, offset, index) {\n  var i8 = index << 3;\n  var blockOffset = offset + i8;\n  return (\n    Long.fromNumber(key[blockOffset + 0] & 0xff)\n      .add(Long.fromNumber(key[blockOffset + 1] & 0xff).shiftLeft(8))\n      .add(Long.fromNumber(key[blockOffset + 2] & 0xff).shiftLeft(16))\n      .add(Long.fromNumber(key[blockOffset + 3] & 0xff).shiftLeft(24))\n      .add(Long.fromNumber(key[blockOffset + 4] & 0xff).shiftLeft(32))\n      .add(Long.fromNumber(key[blockOffset + 5] & 0xff).shiftLeft(40))\n      .add(Long.fromNumber(key[blockOffset + 6] & 0xff).shiftLeft(48))\n      .add(Long.fromNumber(key[blockOffset + 7] & 0xff).shiftLeft(56))\n  );\n};\n\n/**\n * @param {Long} v\n * @param {Number} n\n * @returns {Long}\n */\nMurmur3Tokenizer.prototype.rotl64 = function (v, n) {\n  return (\n    v.shiftRightUnsigned(64 - n).or(v.shiftLeft(n))\n  );\n};\n\n/**\n * @param {Long} k\n * @returns {Long}\n */\nMurmur3Tokenizer.prototype.fmix = function (k) {\n  k = k.xor(k.shiftRightUnsigned(33));\n  //0xff51afd7ed558ccd\n  k = k.multiply(Long.fromBits(0xed558ccd, 0xff51afd7));\n  k = k.xor(k.shiftRightUnsigned(33));\n  //0xc4ceb9fe1a85ec53\n  k = k.multiply(Long.fromBits(0x1a85ec53, 0xc4ceb9fe));\n  k = k.xor(k.shiftRightUnsigned(33));\n  return k;\n};\n\n/**\n *\n * @param {String} value\n * @returns {Long}\n */\nMurmur3Tokenizer.prototype.parse = function (value) {\n  return Long.fromString(value);\n};\n\n/**\n * @param {Long} val1\n * @param {Long} val2\n * @returns {number}\n */\nMurmur3Tokenizer.prototype.compare = function (val1, val2) {\n  return val1.compare(val2);\n};\n\n/**\n * Uniformly distributes data across the cluster based on MD5 hash values.\n * @constructor\n */\nfunction RandomTokenizer() {\n  // eslint-disable-next-line\n  this._crypto = require('crypto');\n}\n\nutil.inherits(RandomTokenizer, Tokenizer);\n\n/**\n * @param {Buffer|Array} value\n * @returns {Integer}\n */\nRandomTokenizer.prototype.hash = function (value) {\n  if (util.isArray(value)) {\n    value = new Buffer(value);\n  }\n  var hashedValue = this._crypto.createHash('md5').update(value).digest();\n  return Integer.fromBuffer(hashedValue).abs();\n};\n\n/**\n * @returns {Integer}\n */\nRandomTokenizer.prototype.parse = function (value) {\n  return Integer.fromString(value);\n};\n\n/**\n * @param {Integer} val1\n * @param {Integer} val2\n * @returns {number}\n */\nRandomTokenizer.prototype.compare = function (val1, val2) {\n  return val1.compare(val2);\n};\n\nfunction ByteOrderedTokenizer() {\n\n}\n\nutil.inherits(ByteOrderedTokenizer, Tokenizer);\n\n/**\n * @param {Buffer|Array} value\n * @returns {Buffer}\n */\nByteOrderedTokenizer.prototype.hash = function (value) {\n  return value;\n};\n\nByteOrderedTokenizer.prototype.stringify = function (value) {\n  return value.toString('hex');\n};\n\nByteOrderedTokenizer.prototype.parse = function (value) {\n  return new Buffer(value);\n};\n\nexports.Murmur3Tokenizer = Murmur3Tokenizer;\nexports.RandomTokenizer = RandomTokenizer;\nexports.ByteOrderedTokenizer = ByteOrderedTokenizer;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/schema-parser.js":"\"use strict\";\nvar util = require('util');\nvar events = require('events');\nvar types = require('../types');\nvar utils = require('../utils');\nvar errors = require('../errors');\nvar TableMetadata = require('./table-metadata');\nvar Aggregate = require('./aggregate');\nvar SchemaFunction = require('./schema-function');\nvar Index = require('./schema-index');\nvar MaterializedView = require('./materialized-view');\n/**\n * @module metadata/schemaParser\n * @ignore\n */\n\nvar _selectAllKeyspacesV1 = \"SELECT * FROM system.schema_keyspaces\";\nvar _selectSingleKeyspaceV1 = \"SELECT * FROM system.schema_keyspaces where keyspace_name = '%s'\";\nvar _selectAllKeyspacesV2 = \"SELECT * FROM system_schema.keyspaces\";\nvar _selectSingleKeyspaceV2 = \"SELECT * FROM system_schema.keyspaces where keyspace_name = '%s'\";\nvar _selectTableV1 = \"SELECT * FROM system.schema_columnfamilies WHERE keyspace_name='%s' AND columnfamily_name='%s'\";\nvar _selectTableV2 = \"SELECT * FROM system_schema.tables WHERE keyspace_name='%s' AND table_name='%s'\";\nvar _selectColumnsV1 = \"SELECT * FROM system.schema_columns WHERE keyspace_name='%s' AND columnfamily_name='%s'\";\nvar _selectColumnsV2 = \"SELECT * FROM system_schema.columns WHERE keyspace_name='%s' AND table_name='%s'\";\nvar _selectIndexesV2 = \"SELECT * FROM system_schema.indexes WHERE keyspace_name='%s' AND table_name='%s'\";\nvar _selectUdtV1 = \"SELECT * FROM system.schema_usertypes WHERE keyspace_name='%s' AND type_name='%s'\";\nvar _selectUdtV2 = \"SELECT * FROM system_schema.types WHERE keyspace_name='%s' AND type_name='%s'\";\nvar _selectFunctionsV1 = \"SELECT * FROM system.schema_functions WHERE keyspace_name = '%s' AND function_name = '%s'\";\nvar _selectFunctionsV2 = \"SELECT * FROM system_schema.functions WHERE keyspace_name = '%s' AND function_name = '%s'\";\nvar _selectAggregatesV1 = \"SELECT * FROM system.schema_aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'\";\nvar _selectAggregatesV2 = \"SELECT * FROM system_schema.aggregates WHERE keyspace_name = '%s' AND aggregate_name = '%s'\";\nvar _selectMaterializedViewV2 = \"SELECT * FROM system_schema.views WHERE keyspace_name = '%s' AND view_name = '%s'\";\n\n/**\n * @abstract\n * @param {ControlConnection} cc\n * @constructor\n * @ignore\n */\nfunction SchemaParser(cc) {\n  this.cc = cc;\n  this.selectTable = null;\n  this.selectColumns = null;\n  this.selectIndexes = null;\n  this.selectUdt = null;\n  this.selectAggregates = null;\n  this.selectFunctions = null;\n}\n\n/**\n * @param name\n * @param durableWrites\n * @param strategy\n * @param strategyOptions\n * @returns {{name, durableWrites, strategy, strategyOptions, tokenToReplica, udts, tables, functions, aggregates}|null}\n * @protected\n */\nSchemaParser.prototype._createKeyspace = function (name, durableWrites, strategy, strategyOptions) {\n  var ksInfo = {\n    name: name,\n    durableWrites: durableWrites,\n    strategy: strategy,\n    strategyOptions: strategyOptions,\n    tokenToReplica: null,\n    udts: {},\n    tables: {},\n    functions: {},\n    aggregates: {},\n    views: {}\n  };\n  ksInfo.tokenToReplica = getTokenToReplicaMapper(strategy, strategyOptions);\n  return ksInfo;\n};\n\n/**\n * @abstract\n * @param {String} name\n * @param {Function} callback\n */\nSchemaParser.prototype.getKeyspace = function (name, callback) {\n};\n\n/**\n * @abstract\n * @param {Boolean} waitReconnect\n * @param {Function} callback\n */\nSchemaParser.prototype.getKeyspaces = function (waitReconnect, callback) {\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getTable = function (keyspaceName, name, cache, callback) {\n  var tableInfo = cache && cache[name];\n  if (!tableInfo) {\n    tableInfo = new TableMetadata(name);\n    if (cache) {\n      cache[name] = tableInfo;\n    }\n  }\n  if (tableInfo.loaded) {\n    return callback(null, tableInfo);\n  }\n  tableInfo.once('load', callback);\n  if (tableInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  // its not cached and not being retrieved\n  tableInfo.loading = true;\n  var tableRow, columnRows, indexRows;\n  var self = this;\n  utils.series([\n    function getTableRow(next) {\n      var query = util.format(self.selectTable, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        tableRow = response.rows[0];\n        next();\n      });\n    },\n    function getColumnRows (next) {\n      if (!tableRow) {\n        return next(null, null, null);\n      }\n      var query = util.format(self.selectColumns, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        columnRows = response.rows;\n        next();\n      });\n    },\n    function getIndexes(next) {\n      if (!tableRow || !self.selectIndexes) {\n        //either the table does not exists or it does not support indexes schema table\n        return next();\n      }\n      var query = util.format(self.selectIndexes, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        indexRows = response.rows;\n        next();\n      });\n    }\n  ], function afterQuery (err) {\n    if (err || !tableRow) {\n      tableInfo.loading = false;\n      return tableInfo.emit('load', err, null);\n    }\n    self._parseTableOrView(tableInfo, tableRow, columnRows, indexRows, function (err) {\n      tableInfo.loading = false;\n      tableInfo.loaded = !err;\n      tableInfo.emit('load', err, tableInfo);\n    });\n  });\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getUdt = function (keyspaceName, name, cache, callback) {\n  var udtInfo = cache && cache[name];\n  if (!udtInfo) {\n    udtInfo = new events.EventEmitter();\n    if (cache) {\n      cache[name] = udtInfo;\n    }\n    udtInfo.setMaxListeners(0);\n    udtInfo.loading = false;\n    udtInfo.name = name;\n    udtInfo.fields = null;\n  }\n  if (udtInfo.fields) {\n    return callback(null, udtInfo);\n  }\n  udtInfo.once('load', callback);\n  if (udtInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  udtInfo.loading = true;\n  //it is not cached, try to query for it\n  var query = util.format(this.selectUdt, keyspaceName, name);\n  var self = this;\n  this.cc.query(query, function (err, response) {\n    if (err) {\n      return udtInfo.emit('load', err);\n    }\n    var row = response.rows[0];\n    if (!row) {\n      udtInfo.loading = false;\n      return udtInfo.emit('load', null, null);\n    }\n    self._parseUdt(udtInfo, row, function (err) {\n      udtInfo.loading = false;\n      if (err) {\n        return udtInfo.emit('load', err);\n      }\n      return udtInfo.emit('load', null, udtInfo);\n    });\n  });\n};\n\n/**\n * Parses the udt information from the row\n * @param udtInfo\n * @param {Row} row\n * @param {Function} callback Callback to be invoked with the err and {{fields: Array}}|null\n * @abstract\n */\nSchemaParser.prototype._parseUdt = function (udtInfo, row, callback) {\n};\n\n//noinspection JSValidateJSDoc\n/**\n * Builds the metadata based on the table and column rows\n * @abstract\n * @param {module:metadata~TableMetadata} tableInfo\n * @param {Row} tableRow\n * @param {Array.<Row>} columnRows\n * @param {Array.<Row>} indexRows\n * @param {Function} callback\n * @throws {Error}\n */\nSchemaParser.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, callback) {\n};\n\n\n/**\n * @abstract\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n\n};\n\n/**\n * @param {String} keyspaceName\n * @param {String} name\n * @param {Boolean} aggregate\n * @param {Object} cache\n * @param {Function} callback\n */\nSchemaParser.prototype.getFunctions = function (keyspaceName, name, aggregate, cache, callback) {\n  /** @type {String} */\n  var query = this.selectFunctions;\n  var parser = this._parseFunction.bind(this);\n  if (aggregate) {\n    query = this.selectAggregates;\n    parser = this._parseAggregate.bind(this);\n  }\n  //if not already loaded\n  //get all functions with that name\n  //cache it by name and, within name, by signature\n  var functionsInfo = cache && cache[name];\n  if (!functionsInfo) {\n    functionsInfo = new events.EventEmitter();\n    if (cache) {\n      cache[name] = functionsInfo;\n    }\n    functionsInfo.setMaxListeners(0);\n  }\n  if (functionsInfo.values) {\n    return callback(null, functionsInfo.values);\n  }\n  functionsInfo.once('load', callback);\n  if (functionsInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  functionsInfo.loading = true;\n  //it is not cached, try to query for it\n  query = util.format(query, keyspaceName, name);\n  this.cc.query(query, function (err, response) {\n    functionsInfo.loading = false;\n    if (err || response.rows.length === 0) {\n      return functionsInfo.emit('load', err, null);\n    }\n    if (response.rows.length > 0) {\n      functionsInfo.values = {};\n    }\n    utils.each(response.rows, function (row, next) {\n      parser(row, function (err, func) {\n        if (err) {\n          return next(err);\n        }\n        functionsInfo.values['(' + func.signature.join(',') + ')'] = func;\n        next();\n      });\n    }, function (err) {\n      if (err) {\n        return functionsInfo.emit('load', err);\n      }\n      functionsInfo.emit('load', null, functionsInfo.values);\n    });\n  });\n};\n\n/**\n * @abstract\n * @param {Row} row\n * @param {Function} callback\n */\nSchemaParser.prototype._parseAggregate = function (row, callback) {\n};\n\n/**\n * @abstract\n * @param {Row} row\n * @param {Function} callback\n */\nSchemaParser.prototype._parseFunction = function (row, callback) {\n};\n\n/**\n * Used to parse schema information for Cassandra versions 1.2.x, and 2.x\n * @param {ControlConnection} cc\n * @constructor\n * @ignore\n */\nfunction SchemaParserV1(cc) {\n  SchemaParser.call(this, cc);\n  this.selectTable = _selectTableV1;\n  this.selectColumns = _selectColumnsV1;\n  this.selectUdt = _selectUdtV1;\n  this.selectAggregates = _selectAggregatesV1;\n  this.selectFunctions = _selectFunctionsV1;\n}\n\nutil.inherits(SchemaParserV1, SchemaParser);\n\n/** @override */\nSchemaParserV1.prototype.getKeyspaces = function (waitReconnect, callback) {\n  var self = this;\n  var keyspaces = {};\n  this.cc.query(_selectAllKeyspacesV1, waitReconnect, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    for (var i = 0; i < result.rows.length; i++) {\n      var row = result.rows[i];\n      var ksInfo = self._createKeyspace(\n        row['keyspace_name'],\n        row['durable_writes'],\n        row['strategy_class'],\n        JSON.parse(row['strategy_options']));\n      keyspaces[ksInfo.name] = ksInfo;\n    }\n    callback(null, keyspaces);\n  });\n};\n\n/** @override */\nSchemaParserV1.prototype.getKeyspace = function (name, callback) {\n  var self = this;\n  this.cc.query(util.format(_selectSingleKeyspaceV1, name), function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    var row = result.rows[0];\n    if (!row) {\n      return callback(null, null);\n    }\n    callback(null, self._createKeyspace(\n      row['keyspace_name'],\n      row['durable_writes'],\n      row['strategy_class'],\n      JSON.parse(row['strategy_options'])));\n  });\n};\n\n//noinspection JSUnusedLocalSymbols\n/** @override */\nSchemaParserV1.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, callback) {\n  var i, c, name, types;\n  var encoder = this.cc.getEncoder();\n  var columnsKeyed = {};\n  var partitionKeys = [];\n  var clusteringKeys = [];\n  tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];\n  tableInfo.caching = tableRow['caching'];\n  tableInfo.comment = tableRow['comment'];\n  tableInfo.compactionClass = tableRow['compaction_strategy_class'];\n  tableInfo.compactionOptions = JSON.parse(tableRow['compaction_strategy_options']);\n  tableInfo.compression = JSON.parse(tableRow['compression_parameters']);\n  tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];\n  tableInfo.localReadRepairChance = tableRow['local_read_repair_chance'];\n  tableInfo.readRepairChance = tableRow['read_repair_chance'];\n  tableInfo.populateCacheOnFlush = tableRow['populate_io_cache_on_flush'] || tableInfo.populateCacheOnFlush;\n  tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;\n  tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;\n  tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;\n  tableInfo.indexInterval = tableRow['index_interval'] || tableInfo.indexInterval;\n  if (typeof tableRow['min_index_interval'] !== 'undefined') {\n    //Cassandra 2.1+\n    tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;\n    tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;\n  }\n  else {\n    //set to null\n    tableInfo.minIndexInterval = null;\n    tableInfo.maxIndexInterval = null;\n  }\n  if (typeof tableRow['replicate_on_write'] !== 'undefined') {\n    //leave the default otherwise\n    tableInfo.replicateOnWrite = tableRow['replicate_on_write'];\n  }\n  tableInfo.columns = [];\n  try {\n    (function parseColumns() {\n      //function context\n      for (i = 0; i < columnRows.length; i++) {\n        var row = columnRows[i];\n        var type = encoder.parseFqTypeName(row['validator']);\n        c = {\n          name: row['column_name'],\n          type: type\n        };\n        tableInfo.columns.push(c);\n        columnsKeyed[c.name] = c;\n        switch (row['type']) {\n          case 'partition_key':\n            partitionKeys.push({c: c, index: (row['component_index'] || 0)});\n            break;\n          case 'clustering_key':\n            clusteringKeys.push({\n              c: c,\n              index: (row['component_index'] || 0),\n              order: c.type.options.reversed ? 'DESC' : 'ASC'\n            });\n            break;\n        }\n      }\n    })();\n    if (partitionKeys.length > 0) {\n      tableInfo.partitionKeys = partitionKeys.sort(utils.propCompare('index')).map(function (item) {\n        return item.c;\n      });\n      clusteringKeys.sort(utils.propCompare('index'));\n      tableInfo.clusteringKeys = clusteringKeys.map(function (item) {\n        return item.c;\n      });\n      tableInfo.clusteringOrder = clusteringKeys.map(function (item) {\n        return item.order;\n      });\n    }\n    //In C* 1.2, keys are not stored on the schema_columns table\n    var keysStoredInTableRow = (tableInfo.partitionKeys.length === 0);\n    if (keysStoredInTableRow && tableRow['key_aliases']) {\n      //In C* 1.2, keys are not stored on the schema_columns table\n      partitionKeys = JSON.parse(tableRow['key_aliases']);\n      types = encoder.parseKeyTypes(tableRow['key_validator']).types;\n      for (i = 0; i < partitionKeys.length; i++) {\n        name = partitionKeys[i];\n        c = columnsKeyed[name];\n        if (!c) {\n          c = {\n            name: name,\n            type: types[i]\n          };\n          tableInfo.columns.push(c);\n        }\n        tableInfo.partitionKeys.push(c);\n      }\n    }\n    var comparator = encoder.parseKeyTypes(tableRow['comparator']);\n    if (keysStoredInTableRow && tableRow['column_aliases']) {\n      clusteringKeys = JSON.parse(tableRow['column_aliases']);\n      for (i = 0; i < clusteringKeys.length; i++) {\n        name = clusteringKeys[i];\n        c = columnsKeyed[name];\n        if (!c) {\n          c = {\n            name: name,\n            type: comparator.types[i]\n          };\n          tableInfo.columns.push(c);\n        }\n        tableInfo.clusteringKeys.push(c);\n        tableInfo.clusteringOrder.push(c.type.options.reversed ? 'DESC' : 'ASC');\n      }\n    }\n    tableInfo.isCompact = !!tableRow['is_dense'];\n    if (!tableInfo.isCompact) {\n      //is_dense column does not exist in previous versions of Cassandra\n      //also, compact pk, ck and val appear as is_dense false\n      // clusteringKeys != comparator types - 1\n      // or not composite (comparator)\n      tableInfo.isCompact = (\n        //clustering keys are not marked as composite\n        !comparator.isComposite ||\n          //only 1 column not part of the partition or clustering keys\n        (!comparator.hasCollections && tableInfo.clusteringKeys.length !== comparator.types.length - 1)\n      );\n    }\n    name = tableRow['value_alias'];\n    if (tableInfo.isCompact && name && !columnsKeyed[name]) {\n      //additional column in C* 1.2 as value_alias\n      c = {\n        name: name,\n        type: encoder.parseFqTypeName(tableRow['default_validator'])\n      };\n      tableInfo.columns.push(c);\n      columnsKeyed[name] = c;\n    }\n    tableInfo.columnsByName = columnsKeyed;\n    tableInfo.indexes = Index.fromColumnRows(columnRows, tableInfo.columnsByName);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  //All the tableInfo parsing in V1 is sync, it uses a callback because the super defines one\n  //to support other versions.\n  callback();\n};\n\n/** @override */\nSchemaParserV1.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n  callback(new errors.NotSupportedError('Materialized views are not supported on Cassandra versions below 3.0'));\n};\n\n/** @override */\nSchemaParserV1.prototype._parseAggregate = function (row, callback) {\n  var encoder = this.cc.getEncoder();\n  var aggregate = new Aggregate();\n  aggregate.name = row['aggregate_name'];\n  aggregate.keyspaceName = row['keyspace_name'];\n  aggregate.signature = row['signature'] || utils.emptyArray;\n  aggregate.stateFunction = row['state_func'];\n  aggregate.finalFunction = row['final_func'];\n  aggregate.initConditionRaw = row['initcond'];\n  try {\n    aggregate.argumentTypes = (row['argument_types'] || utils.emptyArray).map(function (name) {\n      return encoder.parseFqTypeName(name);\n    });\n    aggregate.stateType = encoder.parseFqTypeName(row['state_type']);\n    var initConditionValue = encoder.decode(aggregate.initConditionRaw, aggregate.stateType);\n    if (initConditionValue !== null && typeof initConditionValue !== 'undefined') {\n      aggregate.initCondition = initConditionValue.toString();\n    }\n    aggregate.returnType = encoder.parseFqTypeName(row['return_type']);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  callback(null, aggregate);\n};\n\n/** @override */\nSchemaParserV1.prototype._parseFunction = function (row, callback) {\n  var encoder = this.cc.getEncoder();\n  var func = new SchemaFunction();\n  func.name = row['function_name'];\n  func.keyspaceName = row['keyspace_name'];\n  func.signature = row['signature'] || utils.emptyArray;\n  func.argumentNames = row['argument_names'] || utils.emptyArray;\n  func.body = row['body'];\n  func.calledOnNullInput = row['called_on_null_input'];\n  func.language = row['language'];\n  try {\n    func.argumentTypes = (row['argument_types'] || utils.emptyArray).map(function (name) {\n      return encoder.parseFqTypeName(name);\n    });\n    func.returnType = encoder.parseFqTypeName(row['return_type']);\n  }\n  catch (err) {\n    return callback(err);\n  }\n  callback(null, func);\n};\n\n/** @override */\nSchemaParserV1.prototype._parseUdt = function (udtInfo, row, callback) {\n  var encoder = this.cc.getEncoder();\n  var fieldNames = row['field_names'];\n  var fieldTypes = row['field_types'];\n  var fields = new Array(fieldNames.length);\n  try {\n    for (var i = 0; i < fieldNames.length; i++) {\n      fields[i] = {\n        name: fieldNames[i],\n        type: encoder.parseFqTypeName(fieldTypes[i])\n      };\n    }\n  }\n  catch (err) {\n    return callback(err);\n  }\n  udtInfo.fields = fields;\n  callback(null, udtInfo);\n};\n\n/**\n * Used to parse schema information for Cassandra versions 3.x and above\n * @param {ControlConnection} cc The control connection to be used\n * @param {Function} udtResolver The function to be used to retrieve the udts.\n * @constructor\n * @ignore\n */\nfunction SchemaParserV2(cc, udtResolver) {\n  SchemaParser.call(this, cc);\n  this.udtResolver = udtResolver;\n  this.selectTable = _selectTableV2;\n  this.selectColumns = _selectColumnsV2;\n  this.selectUdt = _selectUdtV2;\n  this.selectAggregates = _selectAggregatesV2;\n  this.selectFunctions = _selectFunctionsV2;\n  this.selectIndexes = _selectIndexesV2;\n}\n\nutil.inherits(SchemaParserV2, SchemaParser);\n\n/** @override */\nSchemaParserV2.prototype.getKeyspaces = function (waitReconnect, callback) {\n  var self = this;\n  var keyspaces = {};\n  this.cc.query(_selectAllKeyspacesV2, waitReconnect, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    for (var i = 0; i < result.rows.length; i++) {\n      var ksInfo = self._parseKeyspace(result.rows[i]);\n      keyspaces[ksInfo.name] = ksInfo;\n    }\n    callback(null, keyspaces);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype.getKeyspace = function (name, callback) {\n  var self = this;\n  this.cc.query(util.format(_selectSingleKeyspaceV2, name), function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n    var row = result.rows[0];\n    if (!row) {\n      return callback(null, null);\n    }\n    callback(null, self._parseKeyspace(row));\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype.getMaterializedView = function (keyspaceName, name, cache, callback) {\n  var viewInfo = cache && cache[name];\n  if (!viewInfo) {\n    viewInfo = new MaterializedView(name);\n    if (cache) {\n      cache[name] = viewInfo;\n    }\n  }\n  if (viewInfo.loaded) {\n    return callback(null, viewInfo);\n  }\n  viewInfo.once('load', callback);\n  if (viewInfo.loading) {\n    //It' already queued, it will be emitted\n    return;\n  }\n  viewInfo.loading = true;\n  var tableRow, columnRows;\n  //it is not cached, try to query for it\n  var self = this;\n  utils.series([\n    function getTableRow(next) {\n      var query = util.format(_selectMaterializedViewV2, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        tableRow = response.rows[0];\n        next();\n      });\n    },\n    function getColumnRows (next) {\n      if (!tableRow) {\n        return next();\n      }\n      var query = util.format(self.selectColumns, keyspaceName, name);\n      self.cc.query(query, function (err, response) {\n        if (err) {\n          return next(err);\n        }\n        columnRows = response.rows;\n        next();\n      });\n    }\n  ], function afterQuery (err) {\n    viewInfo.loading = false;\n    if (err || !tableRow) {\n      return viewInfo.emit('load', err, null);\n    }\n    self._parseTableOrView(viewInfo, tableRow, columnRows, null, function (err) {\n      viewInfo.loading = false;\n      viewInfo.loaded = !err;\n      viewInfo.emit('load', err, viewInfo);\n    });\n  });\n\n};\n\nSchemaParserV2.prototype._parseKeyspace = function (row) {\n  var replication = row['replication'];\n  var strategy;\n  var strategyOptions;\n  if (replication) {\n    strategy = replication['class'];\n    strategyOptions = {};\n    for (var key in replication) {\n      if (!replication.hasOwnProperty(key) || key === 'class') {\n        continue;\n      }\n      strategyOptions[key] = replication[key];\n    }\n  }\n  return this._createKeyspace(\n    row['keyspace_name'],\n    row['durable_writes'],\n    strategy,\n    strategyOptions);\n};\n\n/** @override */\nSchemaParserV2.prototype._parseTableOrView = function (tableInfo, tableRow, columnRows, indexRows, callback) {\n  var encoder = this.cc.getEncoder();\n  var columnsKeyed = {};\n  var partitionKeys = [];\n  var clusteringKeys = [];\n  var isView = tableInfo instanceof MaterializedView;\n  tableInfo.bloomFilterFalsePositiveChance = tableRow['bloom_filter_fp_chance'];\n  tableInfo.caching = JSON.stringify(tableRow['caching']);\n  tableInfo.comment = tableRow['comment'];\n  var compaction = tableRow['compaction'];\n  if (compaction) {\n    tableInfo.compactionOptions = {};\n    tableInfo.compactionClass = compaction['class'];\n    for (var key in compaction) {\n      if (!compaction.hasOwnProperty(key) || key === 'class') {\n        continue;\n      }\n      tableInfo.compactionOptions[key] = compaction[key];\n    }\n  }\n  tableInfo.compression = tableRow['compression'];\n  tableInfo.gcGraceSeconds = tableRow['gc_grace_seconds'];\n  tableInfo.localReadRepairChance = tableRow['dclocal_read_repair_chance'];\n  tableInfo.readRepairChance = tableRow['read_repair_chance'];\n  tableInfo.extensions = tableRow['extensions'];\n  tableInfo.crcCheckChance = tableRow['crc_check_chance'];\n  tableInfo.memtableFlushPeriod = tableRow['memtable_flush_period_in_ms'] || tableInfo.memtableFlushPeriod;\n  tableInfo.defaultTtl = tableRow['default_time_to_live'] || tableInfo.defaultTtl;\n  tableInfo.speculativeRetry = tableRow['speculative_retry'] || tableInfo.speculativeRetry;\n  tableInfo.minIndexInterval = tableRow['min_index_interval'] || tableInfo.minIndexInterval;\n  tableInfo.maxIndexInterval = tableRow['max_index_interval'] || tableInfo.maxIndexInterval;\n  var self = this;\n  utils.map(columnRows, function (row, next) {\n    encoder.parseTypeName(tableRow['keyspace_name'], row['type'], 0, null, self.udtResolver, function (err, type) {\n      if (err) {\n        return next(err);\n      }\n      var c = {\n        name: row['column_name'],\n        type: type,\n        isStatic: false\n      };\n      columnsKeyed[c.name] = c;\n      switch (row['kind']) {\n        case 'partition_key':\n          partitionKeys.push({ c: c, index: (row['position'] || 0)});\n          break;\n        case 'clustering':\n          clusteringKeys.push({ c: c, index: (row['position'] || 0), order: row['clustering_order'] === 'desc' ? 'DESC' : 'ASC'});\n          break;\n        case 'static':\n          c.isStatic = true;\n          break;\n      }\n      next(null, c);\n    });\n  }, function (err, columns) {\n    if (err) {\n      return callback(err);\n    }\n    tableInfo.columns = columns;\n    tableInfo.columnsByName = columnsKeyed;\n    tableInfo.partitionKeys = partitionKeys.sort(utils.propCompare('index')).map(function (item) {\n      return item.c;\n    });\n    clusteringKeys.sort(utils.propCompare('index'));\n    tableInfo.clusteringKeys = clusteringKeys.map(function (item) {\n      return item.c;\n    });\n    tableInfo.clusteringOrder = clusteringKeys.map(function (item) {\n      return item.order;\n    });\n    if (isView) {\n      tableInfo.tableName = tableRow['base_table_name'];\n      tableInfo.whereClause = tableRow['where_clause'];\n      tableInfo.includeAllColumns = tableRow['include_all_columns'];\n      return callback();\n    }\n    tableInfo.indexes = Index.fromRows(indexRows);\n    var flags = tableRow['flags'];\n    var isDense = flags.indexOf('dense') >= 0;\n    var isSuper = flags.indexOf('super') >= 0;\n    var isCompound = flags.indexOf('compound') >= 0;\n    tableInfo.isCompact = isSuper || isDense || !isCompound;\n    //remove the columns related to Thrift\n    var isStaticCompact = !isSuper && !isDense && !isCompound;\n    if(isStaticCompact) {\n      pruneStaticCompactTableColumns(tableInfo);\n    }\n    else if (isDense) {\n      pruneDenseTableColumns(tableInfo);\n    }\n    callback();\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseAggregate = function (row, callback) {\n  var encoder = this.cc.getEncoder();\n  var aggregate = new Aggregate();\n  aggregate.name = row['aggregate_name'];\n  aggregate.keyspaceName = row['keyspace_name'];\n  aggregate.signature = row['argument_types'] || utils.emptyArray;\n  aggregate.stateFunction = row['state_func'];\n  aggregate.finalFunction = row['final_func'];\n  aggregate.initConditionRaw = row['initcond'];\n  aggregate.initCondition = aggregate.initConditionRaw;\n  var self = this;\n  utils.series([\n    function parseArguments(next) {\n      utils.map(row['argument_types'] || utils.emptyArray, function (name, mapNext) {\n        encoder.parseTypeName(row['keyspace_name'], name, 0, null, self.udtResolver, mapNext);\n      }, function (err, result) {\n        aggregate.argumentTypes = result;\n        next(err);\n      });\n    },\n    function parseStateType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['state_type'], 0, null, self.udtResolver, function (err, type) {\n        aggregate.stateType = type;\n        next(err);\n      });\n    },\n    function parseReturnType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, self.udtResolver, function (err, type) {\n        aggregate.returnType = type;\n        next(err);\n      });\n    }\n  ], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, aggregate);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseFunction = function (row, callback) {\n  var encoder = this.cc.getEncoder();\n  var func = new SchemaFunction();\n  func.name = row['function_name'];\n  func.keyspaceName = row['keyspace_name'];\n  func.signature = row['argument_types'] || utils.emptyArray;\n  func.argumentNames = row['argument_names'] || utils.emptyArray;\n  func.body = row['body'];\n  func.calledOnNullInput = row['called_on_null_input'];\n  func.language = row['language'];\n  var self = this;\n  utils.series([\n    function parseArguments(next) {\n      utils.map(row['argument_types'] || utils.emptyArray, function (name, mapNext) {\n        encoder.parseTypeName(row['keyspace_name'], name, 0, null, self.udtResolver, mapNext);\n      }, function (err, result) {\n        func.argumentTypes = result;\n        next(err);\n      });\n    },\n    function parseReturnType(next) {\n      encoder.parseTypeName(row['keyspace_name'], row['return_type'], 0, null, self.udtResolver, function (err, type) {\n        func.returnType = type;\n        next(err);\n      });\n    }\n  ], function (err) {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, func);\n  });\n};\n\n/** @override */\nSchemaParserV2.prototype._parseUdt = function (udtInfo, row, callback) {\n  var encoder = this.cc.getEncoder();\n  var fieldTypes = row['field_types'];\n  var keyspace = row['keyspace_name'];\n  var fields = new Array(fieldTypes.length);\n  var self = this;\n  utils.forEachOf(row['field_names'], function (name, i, next) {\n    encoder.parseTypeName(keyspace, fieldTypes[i], 0, null, self.udtResolver, function (err, type) {\n      if (err) {\n        return next(err);\n      }\n      fields[i] = {\n        name: name,\n        type: type\n      };\n      next();\n    });\n  }, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    udtInfo.fields = fields;\n    callback(null, udtInfo);\n  });\n};\n\n//noinspection JSValidateJSDoc\n/**\n * Upon migration from thrift to CQL, we internally create a pair of surrogate clustering/regular columns\n * for compact static tables. These columns shouldn't be exposed to the user but are currently returned by C*.\n * We also need to remove the static keyword for all other columns in the table.\n * @param {module:metadata~TableMetadata} tableInfo\n*/\nfunction pruneStaticCompactTableColumns(tableInfo) {\n  var i;\n  var c;\n  //remove \"column1 text\" clustering column\n  for (i = 0; i < tableInfo.clusteringKeys.length; i++) {\n    c = tableInfo.clusteringKeys[i];\n    var index = tableInfo.columns.indexOf(c);\n    tableInfo.columns.splice(index, 1);\n    delete tableInfo.columnsByName[c.name];\n  }\n  tableInfo.clusteringKeys = utils.emptyArray;\n  tableInfo.clusteringOrder = utils.emptyArray;\n  //remove regular columns and set the static columns to non-static\n  i = tableInfo.columns.length;\n  while (i--) {\n    c = tableInfo.columns[i];\n    if (!c.isStatic && tableInfo.partitionKeys.indexOf(c) === -1) {\n      // remove \"value blob\" regular column\n      tableInfo.columns.splice(i, 1);\n      delete tableInfo.columnsByName[c.name];\n      continue;\n    }\n    c.isStatic = false;\n  }\n}\n\n//noinspection JSValidateJSDoc\n/**\n * Upon migration from thrift to CQL, we internally create a surrogate column \"value\" of type custom.\n * This column shouldn't be exposed to the user but is currently returned by C*.\n * @param {module:metadata~TableMetadata} tableInfo\n */\nfunction pruneDenseTableColumns(tableInfo) {\n  var i = tableInfo.columns.length;\n  while (i--) {\n    var c = tableInfo.columns[i];\n    if (!c.isStatic && c.type.code === types.dataTypes.custom && c.type.info === 'empty') {\n      // remove \"value blob\" regular column\n      tableInfo.columns.splice(i, 1);\n      delete tableInfo.columnsByName[c.name];\n      continue;\n    }\n    c.isStatic = false;\n  }\n}\n\nfunction getTokenToReplicaMapper(strategy, strategyOptions) {\n  if (/SimpleStrategy$/.test(strategy)) {\n    var rf = parseInt(strategyOptions['replication_factor'], 10);\n    if (rf > 1) {\n      return getTokenToReplicaSimpleMapper(rf);\n    }\n  }\n  if (/NetworkTopologyStrategy$/.test(strategy)) {\n    //noinspection JSUnresolvedVariable\n    return getTokenToReplicaNetworkMapper(strategyOptions);\n  }\n  //default, wrap in an Array\n  return (function noStrategy(tokenizer, ring, primaryReplicas) {\n    var replicas = {};\n    for (var key in primaryReplicas) {\n      if (!primaryReplicas.hasOwnProperty(key)) {\n        continue;\n      }\n      replicas[key] = [primaryReplicas[key]];\n    }\n    return replicas;\n  });\n}\n\n/**\n * @param {Number} replicationFactor\n * @returns {function}\n */\nfunction getTokenToReplicaSimpleMapper(replicationFactor) {\n  return (function tokenSimpleStrategy(tokenizer, ring, primaryReplicas) {\n    var rf = Math.min(replicationFactor, ring.length);\n    var replicas = {};\n    for (var i = 0; i < ring.length; i++) {\n      var token = ring[i];\n      var key = tokenizer.stringify(token);\n      var tokenReplicas = [primaryReplicas[key]];\n      for (var j = 1; j < rf; j++) {\n        var nextReplicaIndex = i + j;\n        if (nextReplicaIndex >= ring.length) {\n          //circle back\n          nextReplicaIndex = nextReplicaIndex % ring.length;\n        }\n        var nextReplica = primaryReplicas[tokenizer.stringify(ring[nextReplicaIndex])];\n        tokenReplicas.push(nextReplica);\n      }\n      replicas[key] = tokenReplicas;\n    }\n    return replicas;\n  });\n}\n\n/**\n * @param {Object} replicationFactors\n * @returns {Function}\n * @private\n */\nfunction getTokenToReplicaNetworkMapper(replicationFactors) {\n  //                A(DC1)\n  //\n  //           H         B(DC2)\n  //                |\n  //      G       --+--       C(DC1)\n  //                |\n  //           F         D(DC2)\n  //\n  //                E(DC1)\n  return (function tokenNetworkStrategy(tokenizer, ring, primaryReplicas, datacenters) {\n    var replicas = {};\n    for (var i = 0; i < ring.length; i++) {\n      var token = ring[i];\n      var key = tokenizer.stringify(token);\n      var tokenReplicas = [];\n      var replicasByDc = {};\n      var racksPlaced = {};\n      var skippedHosts = [];\n      for (var j = 0; j < ring.length; j++) {\n        var nextReplicaIndex = i + j;\n        if (nextReplicaIndex >= ring.length) {\n          //circle back\n          nextReplicaIndex = nextReplicaIndex % ring.length;\n        }\n        var h = primaryReplicas[tokenizer.stringify(ring[nextReplicaIndex])];\n        var dc = h.datacenter;\n        //Check if the next replica belongs to one of the targeted dcs\n        var dcRf = parseInt(replicationFactors[dc], 10);\n        if (!dcRf) {\n          continue;\n        }\n        dcRf = Math.min(dcRf, datacenters[dc].hostLength);\n        var dcReplicas = replicasByDc[dc] || 0;\n        //Amount of replicas per dc is greater than rf or the amount of host in the datacenter\n        if (dcReplicas >= dcRf) {\n          continue;\n        }\n        var racksPlacedInDc = racksPlaced[dc];\n        if (!racksPlacedInDc) {\n          racksPlacedInDc = racksPlaced[dc] = new utils.HashSet();\n        }\n        if (h.rack &&\n            racksPlacedInDc.contains(h.rack) &&\n            racksPlacedInDc.length < datacenters[dc].racks.length) {\n          // We already selected a replica for this rack\n          // Skip until replicas in other racks are added\n          if (skippedHosts.length < dcRf - dcReplicas) {\n            skippedHosts.push(h);\n          }\n          continue;\n        }\n        replicasByDc[h.datacenter] = ++dcReplicas;\n        tokenReplicas.push(h);\n        if (h.rack && racksPlacedInDc.add(h.rack) && racksPlacedInDc.length === datacenters[dc].racks.length) {\n          // We finished placing all replicas for all racks in this dc\n          // Add the skipped hosts\n          replicasByDc[dc] += addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts);\n        }\n        if (isDoneForToken(replicationFactors, datacenters, replicasByDc)) {\n          break;\n        }\n      }\n      replicas[key] = tokenReplicas;\n    }\n    return replicas;\n  });\n}\n\n/**\n * @returns {Number} The number of skipped hosts added.\n */\nfunction addSkippedHosts(dcRf, dcReplicas, tokenReplicas, skippedHosts) {\n  var i;\n  for (i = 0; i < dcRf - dcReplicas && i < skippedHosts.length; i++) {\n    tokenReplicas.push(skippedHosts[i]);\n  }\n  return i;\n}\n\nfunction isDoneForToken(replicationFactors, datacenters, replicasByDc) {\n  var keys = Object.keys(replicationFactors);\n  for (var i = 0; i < keys.length; i++) {\n    var dcName = keys[i];\n    var dc = datacenters[dcName];\n    if (!dc) {\n      // A DC is included in the RF but the DC does not exist in the topology\n      continue;\n    }\n    var rf = Math.min(parseInt(replicationFactors[dcName], 10), dc.hostLength);\n    if (rf > 0 && (!replicasByDc[dcName] || replicasByDc[dcName] < rf)) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Creates a new instance if the currentInstance is not valid for the\n * provided Cassandra version\n * @param {ControlConnection} cc The control connection to be used\n * @param {Function} udtResolver The function to be used to retrieve the udts.\n * @param {Array.<Number>} [version] The cassandra version\n * @param {SchemaParser} [currentInstance] The current instance\n * @returns {SchemaParser}\n */\nfunction getByVersion(cc, udtResolver, version, currentInstance) {\n  var parserConstructor = SchemaParserV1;\n  if (version && version[0] >= 3) {\n    parserConstructor = SchemaParserV2;\n  }\n  if (!currentInstance || !(currentInstance instanceof parserConstructor)){\n    return new parserConstructor(cc, udtResolver);\n  }\n  return currentInstance;\n}\n\nexports.getByVersion = getByVersion;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/table-metadata.js":"\"use strict\";\nvar util = require('util');\nvar DataCollection = require('./data-collection');\n//noinspection JSValidateJSDoc\n/**\n * Creates a new instance of TableMetadata\n * @classdesc Describes a table\n * @param {String} name Name of the Table\n * @augments {module:metadata~DataCollection}\n * @alias module:metadata~TableMetadata\n * @constructor\n */\nfunction TableMetadata(name) {\n  DataCollection.call(this, name);\n  /**\n   * Applies only to counter tables.\n   * When set to true, replicates writes to all affected replicas regardless of the consistency level specified by\n   * the client for a write request. For counter tables, this should always be set to true.\n   * @type {Boolean}\n   */\n  this.replicateOnWrite = true;\n  /**\n   * Returns the memtable flush period (in milliseconds) option for this table.\n   * <p>\n   * Note: this option is available only on Cassandra 2.x and will return 0 (no periodic\n   * flush) when connected to 1.2 nodes.\n   * </p>\n   * @type {Number}\n   */\n  this.memtableFlushPeriod = 0;\n  /**\n   * Returns the index interval option for this table.\n   * <p>\n   * Note: this option is only available in Cassandra 2.0. It is deprecated in Cassandra 2.1 and above, and will\n   * therefore return {@code null} for 2.1 nodes.\n   * </p>\n   * @type {Number|null}\n   */\n  this.indexInterval = null;\n  /**\n   * Determines  whether the table uses the COMPACT STORAGE option.\n   * @type {Boolean}\n   */\n  this.isCompact = false;\n  /**\n   *\n   * @type {Array.<Index>}\n   */\n  this.indexes = null;\n}\n\n//noinspection JSCheckFunctionSignatures\nutil.inherits(TableMetadata, DataCollection);\n\nmodule.exports = TableMetadata;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/data-collection.js":"\"use strict\";\nvar util = require('util');\nvar events = require('events');\n/**\n * Creates a new instance of DataCollection\n * @param {String} name Name of the data object.\n * @classdesc Describes a table or a view\n * @alias module:metadata~DataCollection\n * @constructor\n * @abstract\n */\nfunction DataCollection(name) {\n  events.EventEmitter.call(this);\n  this.setMaxListeners(0);\n  //private\n  Object.defineProperty(this, 'loading', { value: false, enumerable: false, writable: true });\n  Object.defineProperty(this, 'loaded', { value: false, enumerable: false, writable: true });\n  /**\n   * Name of the object\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * False-positive probability for SSTable Bloom filters.\n   * @type {number}\n   */\n  this.bloomFilterFalsePositiveChance = 0;\n  /**\n   * Level of caching: all, keys_only, rows_only, none\n   * @type {String}\n   */\n  this.caching = null;\n  /**\n   * A human readable comment describing the table.\n   * @type {String}\n   */\n  this.comment = null;\n  /**\n   * Specifies the time to wait before garbage collecting tombstones (deletion markers)\n   * @type {number}\n   */\n  this.gcGraceSeconds = 0;\n  /**\n   * Compaction strategy class used for the table.\n   * @type {String}\n   */\n  this.compactionClass = null;\n  /**\n   * Associative-array containing the compaction options keys and values.\n   * @type {Object}\n   */\n  this.compactionOptions = null;\n  /**\n   * Associative-array containing the compression options.\n   * @type {Object}\n   */\n  this.compression = null;\n  /**\n   * Specifies the probability of read repairs being invoked over all replicas in the current data center.\n   * @type {number}\n   */\n  this.localReadRepairChance = 0;\n  /**\n   * Specifies the probability with which read repairs should be invoked on non-quorum reads. The value must be between 0 and 1.\n   * @type {number}\n   */\n  this.readRepairChance = 0;\n  /**\n   * An associative Array containing extra metadata for the table.\n   * <p>\n   * For Cassandra versions prior to 3.0.0, this method always returns {@code null}.\n   * </p>\n   * @type {Object}\n   */\n  this.extensions = null;\n  /**\n   * When compression is enabled, this option defines the probability\n   * with which checksums for compressed blocks are checked during reads.\n   * The default value for this options is 1.0 (always check).\n   * <p>\n   *   For Cassandra versions prior to 3.0.0, this method always returns {@code null}.\n   * </p>\n   * @type {Number|null}\n   */\n  this.crcCheckChance = null;\n  /**\n   * Whether the populate I/O cache on flush is set on this table.\n   * @type {Boolean}\n   */\n  this.populateCacheOnFlush = false;\n  /**\n   * Returns the default TTL for this table.\n   * <p>\n   * Note: this option is not available in Cassandra 1.2 and will return 0 (no default TTL) when connected to 1.2 nodes.\n   * </p>\n   * @type {Number}\n   */\n  this.defaultTtl = 0;\n  /**\n   * * Returns the speculative retry option for this table.\n   * <p>\n   * Note: this option is not available in Cassandra 1.2 and will return \"NONE\" (no speculative retry) when connected\n   * to 1.2 nodes.\n   * </p>\n   * @type {String}\n   */\n  this.speculativeRetry = 'NONE';\n  /**\n   * Returns the minimum index interval option for this table.\n   * <p>\n   *   Note: this option is available in Cassandra 2.1 and above, and will return {@code null} for earlier versions.\n   * </p>\n   * @type {Number|null}\n   */\n  this.minIndexInterval = 128;\n  /**\n   * Returns the maximum index interval option for this table.\n   * <p>\n   * Note: this option is available in Cassandra 2.1 and above, and will return {@code null} for earlier versions.\n   * </p>\n   * @type {Number|null}\n   */\n  this.maxIndexInterval = 2048;\n  /**\n   * Array describing the table columns.\n   * @type {Array}\n   */\n  this.columns = null;\n  /**\n   * An associative Array of columns by name.\n   * @type {Object}\n   */\n  this.columnsByName = null;\n  /**\n   * Array describing the columns that are part of the partition key.\n   * @type {Array}\n   */\n  this.partitionKeys = [];\n  /**\n   * Array describing the columns that form the clustering key.\n   * @type {Array}\n   */\n  this.clusteringKeys = [];\n  /**\n   * Array describing the clustering order of the columns in the same order as the clusteringKeys.\n   * @type {Array}\n   */\n  this.clusteringOrder = [];\n}\n\nutil.inherits(DataCollection, events.EventEmitter);\n\nmodule.exports = DataCollection;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/aggregate.js":"\"use strict\";\n\n/**\n * Creates a new Aggregate.\n * @classdesc Describes a CQL aggregate.\n * @alias module:metadata~Aggregate\n * @constructor\n */\nfunction Aggregate() {\n  /**\n   * Name of the aggregate.\n   * @type {String}\n   */\n  this.name = null;\n  /**\n   * Name of the keyspace where the aggregate is declared.\n   */\n  this.keyspaceName = null;\n  /**\n   * Signature of the aggregate.\n   * @type {Array.<String>}\n   */\n  this.signature = null;\n  /**\n   * List of the CQL aggregate argument types.\n   * @type {Array.<{code, info}>}\n   */\n  this.argumentTypes = null;\n  /**\n   * State Function.\n   * @type {String}\n   */\n  this.stateFunction = null;\n  /**\n   * State Type.\n   * @type {{code, info}}\n   */\n  this.stateType = null;\n  /**\n   * Final Function.\n   * @type {String}\n   */\n  this.finalFunction = null;\n  this.initConditionRaw = null;\n  /**\n   * Initial state value of this aggregate.\n   * @type {String}\n   */\n  this.initCondition = null;\n  /**\n   * Type of the return value.\n   * @type {{code: number, info: (Object|Array|null)}}\n   */\n  this.returnType = null;\n}\n\nmodule.exports = Aggregate;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/schema-function.js":"\"use strict\";\n\n/**\n * Creates a new SchemaFunction.\n * @classdesc Describes a CQL function.\n * @alias module:metadata~SchemaFunction\n * @constructor\n */\nfunction SchemaFunction() {\n  /**\n   * Name of the cql function.\n   * @type {String}\n   */\n  this.name = null;\n  /**\n   * Name of the keyspace where the cql function is declared.\n   */\n  this.keyspaceName = null;\n  /**\n   * Signature of the function.\n   * @type {Array.<String>}\n   */\n  this.signature = null;\n  /**\n   * List of the function argument names.\n   * @type {Array.<String>}\n   */\n  this.argumentNames = null;\n  /**\n   * List of the function argument types.\n   * @type {Array.<{code, info}>}\n   */\n  this.argumentTypes = null;\n  /**\n   * Body of the function.\n   * @type {String}\n   */\n  this.body = null;\n  /**\n   * Determines if the function is called when the input is null.\n   * @type {Boolean}\n   */\n  this.calledOnNullInput = null;\n  /**\n   * Name of the programming language, for example: java, javascript, ...\n   * @type {String}\n   */\n  this.language = null;\n  /**\n   * Type of the return value.\n   * @type {{code: number, info: (Object|Array|null)}}\n   */\n  this.returnType = null;\n}\n\nmodule.exports = SchemaFunction;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/schema-index.js":"\"use strict\";\nvar util = require('util');\nvar utils = require('../utils');\nvar types = require('../types');\n\n/** @private */\nvar kind = {\n  custom: 0,\n  keys: 1,\n  composites: 2\n};\n/**\n * Creates a new Index instance.\n * @classdesc Describes a CQL index.\n * @param {String} name\n * @param {String} target\n * @param {Number} kind\n * @param {Object} options\n * @alias module:metadata~Index\n * @constructor\n */\nfunction Index(name, target, kind, options) {\n  /**\n   * Name of the index.\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * Target of the index.\n   * @type {String}\n   */\n  this.target = target;\n  /**\n   * A numeric value representing index kind (0: custom, 1: keys, 2: composite);\n   * @type {Number}\n   */\n  this.kind = kind;\n  /**\n   * An associative array containing the index options\n   * @type {Object}\n   */\n  this.options = options;\n}\n\n/**\n * Determines if the index is of composites kind\n * @returns {Boolean}\n */\nIndex.prototype.isCompositesKind = function () {\n  return this.kind === kind.composites;\n};\n\n/**\n * Determines if the index is of keys kind\n * @returns {Boolean}\n */\nIndex.prototype.isKeysKind = function () {\n  return this.kind === kind.keys;\n};\n\n/**\n * Determines if the index is of custom kind\n * @returns {Boolean}\n */\nIndex.prototype.isCustomKind = function () {\n  return this.kind === kind.custom;\n};\n\n/**\n * Parses Index information from rows in the 'system_schema.indexes' table\n * @param {Array.<Row>} indexRows\n * @returns {Array.<Index>}\n */\nIndex.fromRows = function (indexRows) {\n  if (!indexRows || indexRows.length === 0) {\n    return utils.emptyArray;\n  }\n  return indexRows.map(function (row) {\n    var options = row['options'];\n    return new Index(row['index_name'], options['target'], getKindByName(row['kind']), options);\n  });\n};\n\n/**\n * Parses Index information from rows in the legacy 'system.schema_columns' table\n * @param {Array.<Row>} columnRows\n * @param {Object.<String, {name, type}>} columnsByName\n * @returns {Array.<Index>}\n */\nIndex.fromColumnRows = function (columnRows, columnsByName) {\n  var result = [];\n  for (var i = 0; i < columnRows.length; i++) {\n    var row = columnRows[i];\n    var indexName = row['index_name'];\n    if (!indexName) {\n      continue;\n    }\n    var c = columnsByName[row['column_name']];\n    var target;\n    var options = JSON.parse(row['index_options']);\n    if (typeof options['index_keys'] !== 'undefined') {\n      target = util.format(\"keys(%s)\", c.name);\n    }\n    else if (typeof options['index_keys_and_values'] !== 'undefined') {\n      target = util.format(\"entries(%s)\", c.name);\n    }\n    else if (c.type.options.frozen && (c.type.code === types.dataTypes.map || c.type.code === types.dataTypes.list ||\n      c.type.code === types.dataTypes.set)) {\n      target = util.format(\"full(%s)\", c.name);\n    }\n    else {\n      target = c.name;\n    }\n    result.push(new Index(indexName, target, getKindByName(row['index_type']), options));\n  }\n  return result;\n};\n\n/**\n * Gets the number representing the kind based on the name\n * @param {String} name\n * @returns {Number}\n * @private\n */\nfunction getKindByName(name) {\n  if (!name) {\n    return kind.custom;\n  }\n  return kind[name.toLowerCase()];\n}\n\nmodule.exports = Index;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/materialized-view.js":"\"use strict\";\nvar util = require('util');\nvar DataCollection = require('./data-collection');\n//noinspection JSValidateJSDoc\n/**\n * Creates a new MaterializedView.\n * @param {String} name Name of the View.\n * @classdesc Describes a CQL materialized view.\n * @alias module:metadata~MaterializedView\n * @augments {module:metadata~DataCollection}\n * @constructor\n */\nfunction MaterializedView(name) {\n  DataCollection.call(this, name);\n  /**\n   * Name of the table.\n   * @type {String}\n   */\n  this.tableName = null;\n  /**\n   * View where clause.\n   * @type {String}\n   */\n  this.whereClause = null;\n  /**\n   * Determines if all the table columns where are included in the view.\n   * @type {boolean}\n   */\n  this.includeAllColumns = false;\n}\n\n//noinspection JSCheckFunctionSignatures\nutil.inherits(MaterializedView, DataCollection);\n\nmodule.exports = MaterializedView;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/metadata/event-debouncer.js":"\"use strict\";\n\nvar util = require('util');\nvar utils = require('../utils');\n\nvar _queueOverflowThreshold = 1000;\n\n/**\n * Debounce protocol events by acting on those events with a sliding delay.\n * @param {Number} delay\n * @param {Function} logger\n * @ignore\n * @constructor\n */\nfunction EventDebouncer(delay, logger) {\n  this._delay = delay;\n  this._logger = logger;\n  this._queue = null;\n  this._timeout = null;\n}\n\n/**\n * Adds a new event to the queue and moves the delay.\n * @param {{ handler: Function, all: boolean|undefined, keyspace: String|undefined, cqlObject: String|null|undefined,\n * callback: Function|undefined }} event\n * @param {Boolean} processNow\n */\nEventDebouncer.prototype.eventReceived = function (event, processNow) {\n  event.callback = event.callback || utils.noop;\n  this._queue = this._queue || { callbacks: [], keyspaces: {} };\n  var delay = !processNow ? this._delay : 0;\n  if (event.all) {\n    // when an event marked with all is received, it supersedes all the rest of events\n    // a full update (hosts + keyspaces + tokens) is going to be made\n    this._queue.mainEvent = event;\n  }\n  if (this._queue.callbacks.length === _queueOverflowThreshold) {\n    // warn once\n    this._logger('warn', util.format('Event debouncer queue exceeded %d events', _queueOverflowThreshold));\n  }\n  this._queue.callbacks.push(event.callback);\n  if (this._queue.mainEvent) {\n    // a full refresh is scheduled and the callback was added, nothing else to do.\n    return this._slideDelay(delay);\n  }\n  // Insert at keyspace level\n  var keyspaceEvents = this._queue.keyspaces[event.keyspace];\n  if (!keyspaceEvents) {\n    keyspaceEvents = this._queue.keyspaces[event.keyspace] = { events: [] };\n  }\n  if (event.cqlObject === undefined) {\n    // a full refresh of the keyspace, supersedes all child keyspace events\n    keyspaceEvents.mainEvent = event;\n  }\n  keyspaceEvents.events.push(event);\n  this._slideDelay(delay);\n};\n\n/**\n * @param {Number} delay\n * @private\n * */\nEventDebouncer.prototype._slideDelay = function (delay) {\n  var self = this;\n  function process() {\n    var q = self._queue;\n    self._queue = null;\n    self._timeout = null;\n    processQueue(q);\n  }\n  if (delay === 0) {\n    // no delay, process immediately\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n    return process();\n  }\n  var previousTimeout = this._timeout;\n  // add the new timeout before removing the previous one performs better\n  this._timeout = setTimeout(process, delay);\n  if (previousTimeout) {\n    clearTimeout(previousTimeout);\n  }\n};\n\n/**\n * Clears the timeout and invokes all pending callback.\n */\nEventDebouncer.prototype.shutdown = function () {\n  if (!this._queue) {\n    return;\n  }\n  this._queue.callbacks.forEach(function (cb) {\n    cb();\n  });\n  this._queue = null;\n  clearTimeout(this._timeout);\n  this._timeout = null;\n};\n\n/**\n * @param {{callbacks: Array, keyspaces: Object, mainEvent: Object}} q\n * @private\n */\nfunction processQueue (q) {\n  if (q.mainEvent) {\n    // refresh all by invoking 1 handler and invoke all pending callbacks\n    return q.mainEvent.handler(function invokeCallbacks(err) {\n      for (var i = 0; i < q.callbacks.length; i++) {\n        q.callbacks[i](err);\n      }\n    });\n  }\n  utils.each(Object.keys(q.keyspaces), function eachKeyspace(name, next) {\n    var keyspaceEvents = q.keyspaces[name];\n    if (keyspaceEvents.mainEvent) {\n      // refresh a keyspace\n      return keyspaceEvents.mainEvent.handler(function mainEventCallback(err) {\n        for (var i = 0; i < keyspaceEvents.events.length; i++) {\n          keyspaceEvents.events[i].callback(err);\n        }\n        next();\n      });\n    }\n    // deal with individual handlers and callbacks\n    keyspaceEvents.events.forEach(function eachEvent(event) {\n      // sync handlers\n      event.handler();\n      event.callback();\n    });\n    next();\n  });\n}\n\nmodule.exports = EventDebouncer;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/execution-profile.js":"\"use strict\";\nvar utils = require('./utils');\nvar types = require('./types');\n\n/**\n * Creates a new instance of {@link ExecutionProfile}.\n * @classdesc\n * Represents a set configurations to be used in a statement execution to be used for a single {@link Client} instance.\n * <p>\n *   An {@link ExecutionProfile} instance should not be shared across different {@link Client} instances.\n * </p>\n * @param {String} name Name of the execution profile.\n * <p>\n *   Use <code>'default'</code> to specify that the new instance should be the default {@link ExecutionProfile} if no\n *   profile is specified in the execution.\n * </p>\n * @param {Object} [options] Profile options, when any of the options is not specified the {@link Client} will the use\n * the ones defined in the default profile.\n * @param {Number} [options.consistency] The consistency level to use for this profile.\n * @param {LoadBalancingPolicy} [options.loadBalancing] The load-balancing policy to use for this profile.\n * @param {Number} [options.readTimeout] The client per-host request timeout to use for this profile.\n * @param {RetryPolicy} [options.retry] The retry policy to use for this profile.\n * @param {Number} [options.serialConsistency] The serial consistency level to use for this profile.\n * @constructor\n */\nfunction ExecutionProfile(name, options) {\n  if (typeof name !== 'string') {\n    throw new TypeError('Execution profile name must be a string');\n  }\n  options = options || utils.emptyObject;\n  /**\n   * Name of the execution profile.\n   * @type {String}\n   */\n  this.name = name;\n  /**\n   * Consistency level.\n   * @type {Number}\n   */\n  this.consistency = options.consistency;\n  /**\n   * Load-balancing policy\n   * @type {LoadBalancingPolicy}\n   */\n  this.loadBalancing = options.loadBalancing;\n  /**\n   * Client read timeout.\n   * @type {Number}\n   */\n  this.readTimeout = options.readTimeout;\n  /**\n   * Retry policy.\n   * @type {RetryPolicy}\n   */\n  this.retry = options.retry;\n  /**\n   * Serial consistency level.\n   * @type {Number}\n   */\n  this.serialConsistency = options.serialConsistency;\n}\n\n/**\n * @param {ClientOptions} options\n * @constructor\n * @ignore\n */\nfunction ProfileManager(options) {\n  this._profiles = options.profiles || [];\n  this._setDefault(options);\n  // A array of unique load balancing policies\n  this._loadBalancingPolicies = [];\n  // A dictionary of name keys and profile values\n  this._profilesMap = {};\n  this._profiles.forEach(function (p) {\n    this._profilesMap[p.name] = p;\n    // Set required properties\n    p.loadBalancing = p.loadBalancing || this._defaultProfile.loadBalancing;\n    // Using array indexOf is not very efficient (O(n)) but the amount of profiles should be limited\n    // and a handful of load-balancing policies (no hashcode for load-Balancing policies)\n    if (this._loadBalancingPolicies.indexOf(p.loadBalancing) === -1) {\n      this._loadBalancingPolicies.push(p.loadBalancing);\n    }\n    return p;\n  }, this);\n}\n\n/**\n * @param {Client} client\n * @param {HostMap} hosts\n * @param {Function} callback\n */\nProfileManager.prototype.init = function (client, hosts, callback) {\n  utils.eachSeries(this._loadBalancingPolicies, function (policy, next) {\n    policy.init(client, hosts, next);\n  }, callback);\n};\n\n/**\n * Uses the load-balancing policies to get the relative distance to the host and return the closest one.\n * @param {Host} host\n */\nProfileManager.prototype.getDistance = function (host) {\n  var distance = types.distance.ignored;\n  // this is performance critical: we can't use any other language features than for-loop :(\n  for (var i = 0; i < this._loadBalancingPolicies.length; i++) {\n    var d = this._loadBalancingPolicies[i].getDistance(host);\n    if (d < distance) {\n      distance = d;\n      if (distance === types.distance.local) {\n        break;\n      }\n    }\n  }\n  host.setDistance(distance);\n  return distance;\n};\n\n/**\n * @param {String|ExecutionProfile} name\n * @returns {ExecutionProfile|undefined} It returns the execution profile by name or the default profile when name is\n * undefined. It returns undefined when the profile does not exist.\n */\nProfileManager.prototype.getProfile = function (name) {\n  if (name instanceof ExecutionProfile) {\n    return name;\n  }\n  return this._profilesMap[name || 'default'];\n};\n\n/** @returns {ExecutionProfile} */\nProfileManager.prototype.getDefault = function () {\n  return this._defaultProfile;\n};\n\n/** @returns {LoadBalancingPolicy} */\nProfileManager.prototype.getDefaultLoadBalancing = function () {\n  return this._defaultProfile.loadBalancing;\n};\n\n/**\n * @private\n * @param {ClientOptions} options\n */\nProfileManager.prototype._setDefault = function (options) {\n  this._defaultProfile = this._profiles.filter(function (p) { return p.name === 'default'; })[0];\n  if (!this._defaultProfile) {\n    this._profiles.push(this._defaultProfile = new ExecutionProfile('default'));\n  }\n  // set the required properties\n  this._defaultProfile.loadBalancing = this._defaultProfile.loadBalancing || options.policies.loadBalancing;\n  this._defaultProfile.retry = this._defaultProfile.retry || options.policies.retry;\n};\n\nexports.ProfileManager = ProfileManager;\nexports.ExecutionProfile = ExecutionProfile;\n","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/request-handler.js":"'use strict';\nvar util = require('util');\n\nvar errors = require('./errors');\nvar types = require('./types');\nvar utils = require('./utils');\nvar requests = require('./requests');\nvar retry = require('./policies/retry');\n\nvar maxSyncHostIterations = 20;\nvar retryOnNextHostDecision = {\n  decision: retry.RetryPolicy.retryDecision.retry,\n  useCurrentHost: false,\n  consistency: undefined\n};\n\n/**\n * Handles a request to Cassandra, dealing with host fail-over and retries on error\n * @param {Client} client Client instance used to retrieve and set the keyspace.\n * @param {LoadBalancingPolicy} loadBalancingPolicy The load-balancing policy to use for the executions.\n * @param {RetryPolicy} retryPolicy The retry policy to use for the executions.\n * @constructor\n */\nfunction RequestHandler(client, loadBalancingPolicy, retryPolicy) {\n  this.client = client;\n  this.loadBalancingPolicy = loadBalancingPolicy;\n  this.retryPolicy = retryPolicy;\n  this.profileManager = client.profileManager;\n  this.logEmitter = client.options.logEmitter;\n  this.retryCount = 0;\n  //current request being executed.\n  this.request = null;\n  //the options for the request.\n  this.requestOptions = utils.emptyObject;\n  //The host selected by the load balancing policy to execute the request\n  /** @type {Host} */\n  this.host = null;\n  /** @type {Connection} */\n  this.connection = null;\n  /** @type {Function} */\n  this.retryHandler = null;\n  this.stackContainer = null;\n  this.triedHosts = {};\n  this.hostIterations = 0;\n}\n\n/**\n * Gets a connection from the next host according to the load balancing policy\n * @param {QueryOptions} queryOptions\n * @param {function} callback\n * @private\n */\nRequestHandler.prototype._getNextConnection = function (queryOptions, callback) {\n  var self = this;\n  var keyspace = this.client.keyspace;\n  if (this.hostIterator) {\n    return self._iterateThroughHosts(this.hostIterator, callback);\n  }\n  this.loadBalancingPolicy.newQueryPlan(keyspace, queryOptions, function (err, iterator) {\n    if (err) {\n      return callback(err);\n    }\n    self.hostIterator = iterator;\n    self._iterateThroughHosts(self.hostIterator, callback);\n  });\n};\n\n/**\n * Uses the iterator to try to acquire a connection from a host\n * @param {{next: function}} iterator\n * @param {Function} callback callback(err, connection, host) to use\n * @private\n */\nRequestHandler.prototype._iterateThroughHosts = function (iterator, callback) {\n  /** @type {Host} */\n  var host;\n  // get a host that is UP in a sync loop\n  while (true) {\n    var item = iterator.next();\n    if (item.done) {\n      return callback(new errors.NoHostAvailableError(this.triedHosts));\n    }\n    host = item.value;\n    // set the distance relative to the client first\n    var distance = this.profileManager.getDistance(host);\n    if (distance === types.distance.ignored) {\n      //If its marked as ignore by the load balancing policy, move on.\n      continue;\n    }\n    if (host.isUp()) {\n      break;\n    }\n    this.triedHosts[host.address] = 'Host considered as DOWN';\n  }\n  var self = this;\n  this._getPooledConnection(host, function iterateSingleCallback(err, connection) {\n    if (connection) {\n      // Connection acquired\n      self.host = host;\n      return callback(null, connection);\n    }\n    if (err) {\n      self.triedHosts[host.address] = err;\n    }\n    if (++self.hostIterations > maxSyncHostIterations) {\n      //avoid a large number sync recursive calls\n      self.hostIterations = 0;\n      return process.nextTick(function iterateOnNextTick() {\n        self._iterateThroughHosts(iterator, callback);\n      });\n    }\n    //move to next host\n    return self._iterateThroughHosts(iterator, callback);\n  });\n};\n\n/**\n * Gets connection from the host connection pool\n * @param {Host} host\n * @param {Function} callback callback(err, connection, host) to use\n * @private\n */\nRequestHandler.prototype._getPooledConnection = function (host, callback) {\n  // Implementation detail: avoid the overhead of async flow control functions\n  var self = this;\n  host.borrowConnection(function (err, connection) {\n    if (err) {\n      return callback(err);\n    }\n    if (!self.client.keyspace || self.client.keyspace === connection.keyspace) {\n      // connection is ready\n      return callback(null, connection);\n    }\n    // switch keyspace\n    connection.changeKeyspace(self.client.keyspace, function (err) {\n      if (err) {\n        host.removeFromPool(connection);\n        return callback(err);\n      }\n      callback(null, connection);\n    });\n  });\n};\n\nRequestHandler.prototype.log = utils.log;\n\n/**\n * Gets an available connection and sends the request\n * @param request\n * @param {QueryOptions|null} options\n * @param {Function} callback\n */\nRequestHandler.prototype.send = function (request, options, callback) {\n  if (this.request === null) {\n    options = options || utils.emptyObject;\n    if (options.captureStackTrace) {\n      Error.captureStackTrace(this.stackContainer = {});\n    }\n  }\n  this.request = request;\n  this.requestOptions = options;\n  var self = this;\n  this._getNextConnection(options, function (err, c) {\n    if (err) {\n      //No connection available\n      return callback(err);\n    }\n    self.connection = c;\n    self._sendOnConnection(request, options, callback);\n  });\n};\n\n/**\n * Sends a request to the current connection, adapting the result and retrying, if necessary.\n * @param request\n * @param {QueryOptions} options\n * @param {Function} callback\n * @private\n */\nRequestHandler.prototype._sendOnConnection = function (request, options, callback) {\n  var self = this;\n  this.connection.sendStream(request, options, function readCallback(err, response) {\n    if (err) {\n      //Something bad happened, maybe retry or do something about it\n      return self._handleError(err, callback);\n    }\n    response = response || utils.emptyObject;\n    var result = new types.ResultSet(response, self.host.address, self.triedHosts, self.request.consistency);\n    if (result.info.warnings) {\n      //log the warnings\n      result.info.warnings.forEach(function (message, i, warnings) {\n        self.log('warning', util.format(\n          'Received warning (%d of %d) \"%s\" for query \"%s\"',\n          i + 1,\n          warnings.length,\n          message,\n          self.request.query));\n      });\n    }\n    if (response.schemaChange) {\n      return self.client.handleSchemaAgreementAndRefresh(self.connection, response.schemaChange, function schemaCb() {\n        callback(null, result);\n      });\n    }\n    if (response.keyspaceSet) {\n      self.client.keyspace = response.keyspaceSet;\n    }\n    callback(null, result);\n  });\n};\n\n/**\n * Sets the keyspace in any connection that is already opened.\n * @param {Function} callback\n */\nRequestHandler.prototype.setKeyspace = function (callback) {\n  var connection;\n  var hosts = this.client.hosts.values();\n  for (var i = 0; i < hosts.length; i++) {\n    this.host = hosts[i];\n    connection = this.host.getActiveConnection();\n    if (connection) {\n      break;\n    }\n  }\n  if (!connection) {\n    return callback(new errors.DriverInternalError('No active connection found'));\n  }\n  connection.changeKeyspace(this.client.keyspace, callback);\n};\n\n/**\n * Sends multiple prepare requests on the next connection available\n * @param {Array.<string>} queries\n * @param {Array.<function>} callbacksArray\n * @param {QueryOptions} options\n * @param {function} callback\n */\nRequestHandler.prototype.prepareMultiple = function (queries, callbacksArray, options, callback) {\n  Error.captureStackTrace(this.stackContainer = {});\n  var self = this;\n  this.retryHandler = function () {\n    // Use a custom retryHandler\n    self.prepareMultiple(queries, callbacksArray, options, callback);\n  };\n  this._getNextConnection(options, function (err, c) {\n    if (err) {\n      //No connection available, no point on retrying\n      return callback(err);\n    }\n    self.connection = c;\n    self._prepareOnConnection(queries, callbacksArray, callback);\n  });\n};\n\n/**\n * Serially prepares multiple queries on the current connection and handles retry if necessary\n * @param {Array.<string>} queries\n * @param {Array.<function>} callbacksArray\n * @param {function} callback\n * @private\n */\nRequestHandler.prototype._prepareOnConnection = function (queries, callbacksArray, callback) {\n  var self = this;\n  var index = 0;\n  utils.eachSeries(queries, function (query, next) {\n    self.connection.prepareOnce(query, function (err, response) {\n      if (callbacksArray) {\n        callbacksArray[index++](err, response);\n      }\n      next(err);\n    });\n  }, function (err) {\n    if (err) {\n      return self._handleError(err, callback);\n    }\n    callback();\n  });\n};\n\n/**\n * Checks if the error and determines if it should be ignored, retried or rethrown.\n * @param {Object} err\n * @param {Function} callback\n * @private\n */\nRequestHandler.prototype._handleError = function (err, callback) {\n  // add the error to the tried hosts\n  this.triedHosts[this.host.address] = err;\n  err['coordinator'] = this.host.address;\n  if ((err instanceof errors.ResponseError) && err.code === types.responseErrorCodes.unprepared) {\n    //noinspection JSUnresolvedVariable\n    return this._prepareAndRetry(err.queryId, callback);\n  }\n  var decisionInfo = this._getDecision(err);\n  if (err.isSocketError) {\n    this.host.removeFromPool(this.connection);\n  }\n  if (!decisionInfo || decisionInfo.decision === retry.RetryPolicy.retryDecision.rethrow) {\n    // callback in error\n    if (this.requestOptions.captureStackTrace) {\n      utils.fixStack(this.stackContainer.stack, err);\n    }\n    if (this.request instanceof requests.QueryRequest || this.request instanceof requests.ExecuteRequest) {\n      err['query'] = this.request.query;\n    }\n    return callback(err);\n  }\n  if (decisionInfo.decision === retry.RetryPolicy.retryDecision.ignore) {\n    //Return an empty response\n    return callback(\n      null,\n      new types.ResultSet(utils.emptyObject, this.host.address, this.triedHosts, this.request.consistency));\n  }\n  return this._retry(decisionInfo.consistency, decisionInfo.useCurrentHost, callback);\n};\n\n/**\n * @returns {{decision, useCurrentHost, consistency}}\n */\nRequestHandler.prototype._getDecision = function (err) {\n  var operationInfo = {\n    query: this.request && this.request.query,\n    options: this.requestOptions,\n    nbRetry: this.retryCount,\n    // handler, request and retryOnTimeout properties are deprecated and should be removed in the next major version\n    handler: this,\n    request: this.request,\n    retryOnTimeout: false\n  };\n  var self = this;\n  function onRequestError() {\n    if (self.retryHandler) {\n      return retryOnNextHostDecision;\n    }\n    return self.retryPolicy.onRequestError(operationInfo, self.request.consistency, err);\n  }\n  if (err.isSocketError) {\n    if (err.requestNotWritten) {\n      // the request was definitely not applied, it's safe to retry\n      return retryOnNextHostDecision;\n    }\n    return onRequestError();\n  }\n  if (err instanceof errors.OperationTimedOutError) {\n    this.log('warning', err.message);\n    this.host.checkHealth(this.connection);\n    if (this.request instanceof requests.PrepareRequest) {\n      // always retry on next host for PREPARE requests\n      return retryOnNextHostDecision;\n    }\n    operationInfo.retryOnTimeout = this.requestOptions.retryOnTimeout !== false;\n    return onRequestError();\n  }\n  if (err instanceof errors.ResponseError) {\n    switch (err.code) {\n      case types.responseErrorCodes.overloaded:\n      case types.responseErrorCodes.isBootstrapping:\n      case types.responseErrorCodes.truncateError:\n        return onRequestError();\n      case types.responseErrorCodes.unavailableException:\n        //noinspection JSUnresolvedVariable\n        return this.retryPolicy.onUnavailable(operationInfo, err.consistencies, err.required, err.alive);\n      case types.responseErrorCodes.readTimeout:\n        //noinspection JSUnresolvedVariable\n        return this.retryPolicy.onReadTimeout(\n          operationInfo, err.consistencies, err.received, err.blockFor, err.isDataPresent);\n      case types.responseErrorCodes.writeTimeout:\n        //noinspection JSUnresolvedVariable\n        return this.retryPolicy.onWriteTimeout(\n          operationInfo, err.consistencies, err.received, err.blockFor, err.writeType);\n    }\n  }\n  return { decision: retry.RetryPolicy.retryDecision.rethrow };\n};\n\n/**\n * @param {Number} consistency\n * @param {Boolean} useCurrentHost\n * @param {Function} callback\n * @private\n */\nRequestHandler.prototype._retry = function (consistency, useCurrentHost, callback) {\n  this.log('info', 'Retrying request');\n  if (this.retryHandler) {\n    // custom retry handler (not a QueryRequest / ExecuteRequest / BatchRequest)\n    return this.retryHandler(callback);\n  }\n  this.retryCount++;\n  if (typeof consistency === 'number') {\n    this.request.consistency = consistency;\n  }\n  if (useCurrentHost !== false) {\n    // retry on the current host by default\n    return this._sendOnConnection(this.request, this.requestOptions, callback);\n  }\n  // use the next host in the query plan to send the request\n  this.send(this.request, this.requestOptions, callback);\n};\n\n/**\n * Prepares the query and retries on the SAME host\n * @param {Buffer} queryId\n * @param {Function} callback\n * @private\n */\nRequestHandler.prototype._prepareAndRetry = function (queryId, callback) {\n  this.log('info', util.format('Query 0x%s not prepared on host %s, preparing and retrying', queryId.toString('hex'), this.host.address));\n  var self = this;\n  function retryRequest (err) {\n    if (err) {\n      //Could not be prepared or retried, just send the error to caller\n      return callback(err);\n    }\n    self._sendOnConnection(self.request, self.requestOptions, callback);\n  }\n  if (this.request instanceof requests.ExecuteRequest) {\n    //Its a single Execute of a prepared statement\n    this._prepareOnConnection([this.request.query], [function (err, response) {\n      if (err) {\n        // let the error be handle at general callback level\n        return;\n      }\n      if (!Buffer.isBuffer(response.id) ||\n        response.id.length !== self.request.queryId.length ||\n        response.id.toString('hex') !== self.request.queryId.toString('hex')\n      ) {\n        self.log('warning', util.format('Unexpected difference between query ids for query \"%s\" (%s !== %s)',\n          self.request.query,\n          response.id.toString('hex'),\n          self.request.queryId.toString('hex')));\n        self.request.queryId = response.id;\n      }\n    }], retryRequest);\n    return;\n  }\n  if (this.request instanceof requests.BatchRequest) {\n    //Its a BATCH of prepared statements\n    //We need to prepare all the different queries in the batch in the current host\n    var queries = {};\n    this.request.queries.forEach(function (item) {\n      //Unique queries\n      queries[item.query] = item.info;\n    });\n    var queryStrings = Object.keys(queries);\n    var singleCallbacks = new Array(queryStrings.length);\n    queryStrings.forEach(function (query, i) {\n      var info = queries[query];\n      singleCallbacks[i] = function singlePrepareCallback(err, response) {\n        if (err) {\n          // let the error be handle at general callback level\n          return;\n        }\n        if (!Buffer.isBuffer(response.id) ||\n          response.id.length !== info.queryId.length ||\n          response.id.toString('hex') !== info.queryId.toString('hex')\n        ) {\n          self.log('warning', util.format('Unexpected difference between query ids for query \"%s\" (%s !== %s)',\n            info.query,\n            response.id.toString('hex'),\n            info.queryId.toString('hex')));\n          info.queryId = response.id;\n        }\n      };\n    });\n    this._prepareOnConnection(queryStrings, singleCallbacks, retryRequest);\n    return;\n  }\n  return callback(new errors.DriverInternalError('Obtained unprepared from wrong request'));\n};\n\nmodule.exports = RequestHandler;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/auth/index.js":"'use strict';\n/**\n * Authentication module.\n * @module auth\n */\nvar baseProvider = require('./provider.js');\nexports.AuthProvider = baseProvider.AuthProvider;\nexports.Authenticator = baseProvider.Authenticator;\nexports.PlainTextAuthProvider = require('./plain-text-auth-provider.js');","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/auth/provider.js":"'use strict';\n/**\n * @classdesc Provides [Authenticator]{@link module:auth~Authenticator} instances to be used when connecting to a host.\n * @constructor\n * @abstract\n * @alias module:auth~AuthProvider\n */\nfunction AuthProvider() {\n\n}\n\n/**\n * Returns an [Authenticator]{@link module:auth~Authenticator} instance to be used when connecting to a host.\n * @param {String} endpoint The ip address and port number in the format ip:port\n * @param {String} name Authenticator name\n * @abstract\n * @returns {Authenticator}\n */\nAuthProvider.prototype.newAuthenticator = function (endpoint, name) {\n  throw new Error('This is an abstract class, you must implement newAuthenticator method or ' +\n    'use another auth provider that inherits from this class');\n};\n\n/**\n * @class\n * @classdesc Handles SASL authentication with Cassandra servers.\n * Each time a new connection is created and the server requires authentication,\n * a new instance of this class will be created by the corresponding.\n * @constructor\n * @alias module:auth~Authenticator\n */\nfunction Authenticator() {\n\n}\n\n/**\n * Obtain an initial response token for initializing the SASL handshake.\n * @param {Function} callback\n */\nAuthenticator.prototype.initialResponse = function (callback) {\n  callback(new Error('Not implemented'));\n};\n\n/**\n * Evaluates a challenge received from the Server. Generally, this method should callback with\n * no error and no additional params when authentication is complete from the client perspective.\n * @param {Buffer} challenge\n * @param {Function} callback\n */\nAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {\n  callback(new Error('Not implemented'));\n};\n\n/**\n * Called when authentication is successful with the last information\n * optionally sent by the server.\n * @param {Buffer} [token]\n */\nAuthenticator.prototype.onAuthenticationSuccess = function (token) {\n\n};\n\nexports.AuthProvider = AuthProvider;\nexports.Authenticator = Authenticator;","/home/travis/build/npmtest/node-npmtest-cassandra-driver/node_modules/cassandra-driver/lib/auth/plain-text-auth-provider.js":"'use strict';\nvar util = require('util');\n\nvar provider = require('./provider.js');\nvar AuthProvider = provider.AuthProvider;\nvar Authenticator = provider.Authenticator;\n/**\n * Creates a new instance of the Authenticator provider\n * @classdesc Provides plain text [Authenticator]{@link module:auth~Authenticator} instances to be used when\n * connecting to a host.\n * @extends module:auth~AuthProvider\n * @example\n * var authProvider = new cassandra.auth.PlainTextAuthProvider('my_user', 'p@ssword1!');\n * //Set the auth provider in the clientOptions when creating the Client instance\n * var client = new Client({ contactPoints: contactPoints, authProvider: authProvider });\n * @param {String} username User name in plain text\n * @param {String} password Password in plain text\n * @alias module:auth~PlainTextAuthProvider\n * @constructor\n */\nfunction PlainTextAuthProvider(username, password) {\n  this.username = username;\n  this.password = password;\n}\n\nutil.inherits(PlainTextAuthProvider, AuthProvider);\n\n/**\n * Returns a new [Authenticator]{@link module:auth~Authenticator} instance to be used for plain text authentication.\n * @override\n * @returns {Authenticator}\n */\nPlainTextAuthProvider.prototype.newAuthenticator = function () {\n  return new PlainTextAuthenticator(this.username, this.password);\n};\n\n/**\n * @ignore\n */\nfunction PlainTextAuthenticator(username, password) {\n  this.username = username;\n  this.password = password;\n}\n\nutil.inherits(PlainTextAuthenticator, Authenticator);\n\nPlainTextAuthenticator.prototype.initialResponse = function (callback) {\n  var initialToken = Buffer.concat([\n    new Buffer([0]),\n    new Buffer(this.username, 'utf8'),\n    new Buffer([0]),\n    new Buffer(this.password, 'utf8')\n  ]);\n  callback(null, initialToken);\n};\n\nPlainTextAuthenticator.prototype.evaluateChallenge = function (challenge, callback) {\n  //noop\n  callback();\n};\n\nmodule.exports = PlainTextAuthProvider;"}